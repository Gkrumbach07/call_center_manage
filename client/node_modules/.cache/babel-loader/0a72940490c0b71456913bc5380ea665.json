{"ast":null,"code":"const createRetry = require('../retry');\n\nconst createSocket = require('./socket');\n\nconst createRequest = require('../protocol/request');\n\nconst Decoder = require('../protocol/decoder');\n\nconst {\n  KafkaJSConnectionError,\n  KafkaJSConnectionClosedError\n} = require('../errors');\n\nconst {\n  INT_32_MAX_VALUE\n} = require('../constants');\n\nconst getEnv = require('../env');\n\nconst RequestQueue = require('./requestQueue');\n\nconst {\n  CONNECTION_STATUS,\n  CONNECTED_STATUS\n} = require('./connectionStatus');\n\nconst requestInfo = ({\n  apiName,\n  apiKey,\n  apiVersion\n}) => `${apiName}(key: ${apiKey}, version: ${apiVersion})`;\n/**\n * @param {string} host\n * @param {number} port\n * @param {Object} logger\n * @param {string} clientId='kafkajs'\n * @param {number} requestTimeout The maximum amount of time the client will wait for the response of a request,\n *                                in milliseconds\n * @param {string} [rack=null]\n * @param {Object} [ssl=null] Options for the TLS Secure Context. It accepts all options,\n *                            usually \"cert\", \"key\" and \"ca\". More information at\n *                            https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options\n * @param {Object} [sasl=null] Attributes used for SASL authentication. Options based on the\n *                             key \"mechanism\". Connection is not actively using the SASL attributes\n *                             but acting as a data object for this information\n * @param {number} [connectionTimeout=1000] The connection timeout, in milliseconds\n * @param {Object} [retry=null] Configurations for the built-in retry mechanism. More information at the\n *                              retry module inside network\n * @param {number} [maxInFlightRequests=null] The maximum number of unacknowledged requests on a connection before\n *                                            enqueuing\n * @param {InstrumentationEventEmitter} [instrumentationEmitter=null]\n */\n\n\nmodule.exports = class Connection {\n  constructor({\n    host,\n    port,\n    logger,\n    socketFactory,\n    requestTimeout,\n    rack = null,\n    ssl = null,\n    sasl = null,\n    clientId = 'kafkajs',\n    connectionTimeout = 1000,\n    enforceRequestTimeout = false,\n    maxInFlightRequests = null,\n    instrumentationEmitter = null,\n    retry = {}\n  }) {\n    this.host = host;\n    this.port = port;\n    this.rack = rack;\n    this.clientId = clientId;\n    this.broker = `${this.host}:${this.port}`;\n    this.logger = logger.namespace('Connection');\n    this.socketFactory = socketFactory;\n    this.ssl = ssl;\n    this.sasl = sasl;\n    this.retry = retry;\n    this.retrier = createRetry({ ...this.retry\n    });\n    this.requestTimeout = requestTimeout;\n    this.connectionTimeout = connectionTimeout;\n    this.bytesBuffered = 0;\n    this.bytesNeeded = Decoder.int32Size();\n    this.chunks = [];\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTED;\n    this.correlationId = 0;\n    this.requestQueue = new RequestQueue({\n      instrumentationEmitter,\n      maxInFlightRequests,\n      requestTimeout,\n      enforceRequestTimeout,\n      clientId,\n      broker: this.broker,\n      logger: logger.namespace('RequestQueue'),\n      isConnected: () => this.connected\n    });\n    this.authHandlers = null;\n    this.authExpectResponse = false;\n\n    const log = level => (message, extra = {}) => {\n      const logFn = this.logger[level];\n      logFn(message, {\n        broker: this.broker,\n        clientId,\n        ...extra\n      });\n    };\n\n    this.logDebug = log('debug');\n    this.logError = log('error');\n    const env = getEnv();\n    this.shouldLogBuffers = env.KAFKAJS_DEBUG_PROTOCOL_BUFFERS === '1';\n    this.shouldLogFetchBuffer = this.shouldLogBuffers && env.KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS === '1';\n  }\n\n  get connected() {\n    return CONNECTED_STATUS.includes(this.connectionStatus);\n  }\n  /**\n   * @public\n   * @returns {Promise}\n   */\n\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      if (this.connected) {\n        return resolve(true);\n      }\n\n      let timeoutId;\n\n      const onConnect = () => {\n        clearTimeout(timeoutId);\n        this.connectionStatus = CONNECTION_STATUS.CONNECTED;\n        this.requestQueue.scheduleRequestTimeoutCheck();\n        resolve(true);\n      };\n\n      const onData = data => {\n        this.processData(data);\n      };\n\n      const onEnd = async () => {\n        clearTimeout(timeoutId);\n        const wasConnected = this.connected;\n\n        if (this.authHandlers) {\n          this.authHandlers.onError();\n        } else if (wasConnected) {\n          this.logDebug('Kafka server has closed connection');\n          this.rejectRequests(new KafkaJSConnectionClosedError('Closed connection', {\n            host: this.host,\n            port: this.port\n          }));\n        }\n\n        await this.disconnect();\n      };\n\n      const onError = async e => {\n        clearTimeout(timeoutId);\n        const error = new KafkaJSConnectionError(`Connection error: ${e.message}`, {\n          broker: `${this.host}:${this.port}`,\n          code: e.code\n        });\n        this.logError(error.message, {\n          stack: e.stack\n        });\n        this.rejectRequests(error);\n        await this.disconnect();\n        reject(error);\n      };\n\n      const onTimeout = async () => {\n        const error = new KafkaJSConnectionError('Connection timeout', {\n          broker: `${this.host}:${this.port}`\n        });\n        this.logError(error.message);\n        this.rejectRequests(error);\n        await this.disconnect();\n        reject(error);\n      };\n\n      this.logDebug(`Connecting`, {\n        ssl: !!this.ssl,\n        sasl: !!this.sasl\n      });\n\n      try {\n        timeoutId = setTimeout(onTimeout, this.connectionTimeout);\n        this.socket = createSocket({\n          socketFactory: this.socketFactory,\n          host: this.host,\n          port: this.port,\n          ssl: this.ssl,\n          onConnect,\n          onData,\n          onEnd,\n          onError,\n          onTimeout\n        });\n      } catch (e) {\n        clearTimeout(timeoutId);\n        reject(new KafkaJSConnectionError(`Failed to connect: ${e.message}`, {\n          broker: `${this.host}:${this.port}`\n        }));\n      }\n    });\n  }\n  /**\n   * @public\n   * @returns {Promise}\n   */\n\n\n  async disconnect() {\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTING;\n    this.logDebug('disconnecting...');\n    await this.requestQueue.waitForPendingRequests();\n    this.requestQueue.destroy();\n\n    if (this.socket) {\n      this.socket.end();\n      this.socket.unref();\n    }\n\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTED;\n    this.logDebug('disconnected');\n    return true;\n  }\n  /**\n   * @public\n   * @returns {Promise}\n   */\n\n\n  authenticate({\n    authExpectResponse = false,\n    request,\n    response\n  }) {\n    this.authExpectResponse = authExpectResponse;\n    /**\n     * TODO: rewrite removing the async promise executor\n     */\n\n    /* eslint-disable no-async-promise-executor */\n\n    return new Promise(async (resolve, reject) => {\n      this.authHandlers = {\n        onSuccess: rawData => {\n          this.authHandlers = null;\n          this.authExpectResponse = false;\n          response.decode(rawData).then(data => response.parse(data)).then(resolve).catch(reject);\n        },\n        onError: () => {\n          this.authHandlers = null;\n          this.authExpectResponse = false;\n          reject(new KafkaJSConnectionError('Connection closed by the server', {\n            broker: `${this.host}:${this.port}`\n          }));\n        }\n      };\n\n      try {\n        const requestPayload = await request.encode();\n        this.failIfNotConnected();\n        this.socket.write(requestPayload.buffer, 'binary');\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n  /**\n   * @public\n   * @param {object} protocol\n   * @param {object} protocol.request It is defined by the protocol and consists of an object with \"apiKey\",\n   *                         \"apiVersion\", \"apiName\" and an \"encode\" function. The encode function\n   *                         must return an instance of Encoder\n   *\n   * @param {object} protocol.response It is defined by the protocol and consists of an object with two functions:\n   *                          \"decode\" and \"parse\"\n   *\n   * @param {number} [protocol.requestTimeout=null] Override for the default requestTimeout\n   * @param {boolean} [protocol.logResponseError=true] Whether to log errors\n   * @returns {Promise<data>} where data is the return of \"response#parse\"\n   */\n\n\n  async send({\n    request,\n    response,\n    requestTimeout = null,\n    logResponseError = true\n  }) {\n    this.failIfNotConnected();\n    const expectResponse = !request.expectResponse || request.expectResponse();\n\n    const sendRequest = async () => {\n      const {\n        clientId\n      } = this;\n      const correlationId = this.nextCorrelationId();\n      const requestPayload = await createRequest({\n        request,\n        correlationId,\n        clientId\n      });\n      const {\n        apiKey,\n        apiName,\n        apiVersion\n      } = request;\n      this.logDebug(`Request ${requestInfo(request)}`, {\n        correlationId,\n        expectResponse,\n        size: Buffer.byteLength(requestPayload.buffer)\n      });\n      return new Promise((resolve, reject) => {\n        try {\n          this.failIfNotConnected();\n          const entry = {\n            apiKey,\n            apiName,\n            apiVersion,\n            correlationId,\n            resolve,\n            reject\n          };\n          this.requestQueue.push({\n            entry,\n            expectResponse,\n            requestTimeout,\n            sendRequest: () => {\n              this.socket.write(requestPayload.buffer, 'binary');\n            }\n          });\n        } catch (e) {\n          reject(e);\n        }\n      });\n    };\n\n    const {\n      correlationId,\n      size,\n      entry,\n      payload\n    } = await sendRequest();\n\n    if (!expectResponse) {\n      return;\n    }\n\n    try {\n      const payloadDecoded = await response.decode(payload);\n      /**\n       * @see KIP-219\n       * If the response indicates that the client-side needs to throttle, do that.\n       */\n\n      this.requestQueue.maybeThrottle(payloadDecoded.clientSideThrottleTime);\n      const data = await response.parse(payloadDecoded);\n      const isFetchApi = entry.apiName === 'Fetch';\n      this.logDebug(`Response ${requestInfo(entry)}`, {\n        correlationId,\n        size,\n        data: isFetchApi && !this.shouldLogFetchBuffer ? '[filtered]' : data\n      });\n      return data;\n    } catch (e) {\n      if (logResponseError) {\n        this.logError(`Response ${requestInfo(entry)}`, {\n          error: e.message,\n          correlationId,\n          size\n        });\n      }\n\n      const isBuffer = Buffer.isBuffer(payload);\n      this.logDebug(`Response ${requestInfo(entry)}`, {\n        error: e.message,\n        correlationId,\n        payload: isBuffer && !this.shouldLogBuffers ? {\n          type: 'Buffer',\n          data: '[filtered]'\n        } : payload\n      });\n      throw e;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  failIfNotConnected() {\n    if (!this.connected) {\n      throw new KafkaJSConnectionError('Not connected', {\n        broker: `${this.host}:${this.port}`\n      });\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  nextCorrelationId() {\n    if (this.correlationId >= INT_32_MAX_VALUE) {\n      this.correlationId = 0;\n    }\n\n    return this.correlationId++;\n  }\n  /**\n   * @private\n   */\n\n\n  processData(rawData) {\n    if (this.authHandlers && !this.authExpectResponse) {\n      return this.authHandlers.onSuccess(rawData);\n    } // Accumulate the new chunk\n\n\n    this.chunks.push(rawData);\n    this.bytesBuffered += Buffer.byteLength(rawData); // Process data if there are enough bytes to read the expected response size,\n    // otherwise keep buffering\n\n    while (this.bytesNeeded <= this.bytesBuffered) {\n      const buffer = this.chunks.length > 1 ? Buffer.concat(this.chunks) : this.chunks[0];\n      const decoder = new Decoder(buffer);\n      const expectedResponseSize = decoder.readInt32(); // Return early if not enough bytes to read the full response\n\n      if (!decoder.canReadBytes(expectedResponseSize)) {\n        this.chunks = [buffer];\n        this.bytesBuffered = Buffer.byteLength(buffer);\n        this.bytesNeeded = Decoder.int32Size() + expectedResponseSize;\n        return;\n      }\n\n      const response = new Decoder(decoder.readBytes(expectedResponseSize)); // Reset the buffered chunks as the rest of the bytes\n\n      const remainderBuffer = decoder.readAll();\n      this.chunks = [remainderBuffer];\n      this.bytesBuffered = Buffer.byteLength(remainderBuffer);\n      this.bytesNeeded = Decoder.int32Size();\n\n      if (this.authHandlers) {\n        const rawResponseSize = Decoder.int32Size() + expectedResponseSize;\n        const rawResponseBuffer = buffer.slice(0, rawResponseSize);\n        return this.authHandlers.onSuccess(rawResponseBuffer);\n      }\n\n      const correlationId = response.readInt32();\n      const payload = response.readAll();\n      this.requestQueue.fulfillRequest({\n        size: expectedResponseSize,\n        correlationId,\n        payload\n      });\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  rejectRequests(error) {\n    this.requestQueue.rejectAll(error);\n  }\n\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/network/connection.js"],"names":["createRetry","require","createSocket","createRequest","Decoder","KafkaJSConnectionError","KafkaJSConnectionClosedError","INT_32_MAX_VALUE","getEnv","RequestQueue","CONNECTION_STATUS","CONNECTED_STATUS","requestInfo","apiName","apiKey","apiVersion","module","exports","Connection","constructor","host","port","logger","socketFactory","requestTimeout","rack","ssl","sasl","clientId","connectionTimeout","enforceRequestTimeout","maxInFlightRequests","instrumentationEmitter","retry","broker","namespace","retrier","bytesBuffered","bytesNeeded","int32Size","chunks","connectionStatus","DISCONNECTED","correlationId","requestQueue","isConnected","connected","authHandlers","authExpectResponse","log","level","message","extra","logFn","logDebug","logError","env","shouldLogBuffers","KAFKAJS_DEBUG_PROTOCOL_BUFFERS","shouldLogFetchBuffer","KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS","includes","connect","Promise","resolve","reject","timeoutId","onConnect","clearTimeout","CONNECTED","scheduleRequestTimeoutCheck","onData","data","processData","onEnd","wasConnected","onError","rejectRequests","disconnect","e","error","code","stack","onTimeout","setTimeout","socket","DISCONNECTING","waitForPendingRequests","destroy","end","unref","authenticate","request","response","onSuccess","rawData","decode","then","parse","catch","requestPayload","encode","failIfNotConnected","write","buffer","send","logResponseError","expectResponse","sendRequest","nextCorrelationId","size","Buffer","byteLength","entry","push","payload","payloadDecoded","maybeThrottle","clientSideThrottleTime","isFetchApi","isBuffer","type","length","concat","decoder","expectedResponseSize","readInt32","canReadBytes","readBytes","remainderBuffer","readAll","rawResponseSize","rawResponseBuffer","slice","fulfillRequest","rejectAll"],"mappings":"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","sourcesContent":["const createRetry = require('../retry')\nconst createSocket = require('./socket')\nconst createRequest = require('../protocol/request')\nconst Decoder = require('../protocol/decoder')\nconst { KafkaJSConnectionError, KafkaJSConnectionClosedError } = require('../errors')\nconst { INT_32_MAX_VALUE } = require('../constants')\nconst getEnv = require('../env')\nconst RequestQueue = require('./requestQueue')\nconst { CONNECTION_STATUS, CONNECTED_STATUS } = require('./connectionStatus')\n\nconst requestInfo = ({ apiName, apiKey, apiVersion }) =>\n  `${apiName}(key: ${apiKey}, version: ${apiVersion})`\n\n/**\n * @param {string} host\n * @param {number} port\n * @param {Object} logger\n * @param {string} clientId='kafkajs'\n * @param {number} requestTimeout The maximum amount of time the client will wait for the response of a request,\n *                                in milliseconds\n * @param {string} [rack=null]\n * @param {Object} [ssl=null] Options for the TLS Secure Context. It accepts all options,\n *                            usually \"cert\", \"key\" and \"ca\". More information at\n *                            https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options\n * @param {Object} [sasl=null] Attributes used for SASL authentication. Options based on the\n *                             key \"mechanism\". Connection is not actively using the SASL attributes\n *                             but acting as a data object for this information\n * @param {number} [connectionTimeout=1000] The connection timeout, in milliseconds\n * @param {Object} [retry=null] Configurations for the built-in retry mechanism. More information at the\n *                              retry module inside network\n * @param {number} [maxInFlightRequests=null] The maximum number of unacknowledged requests on a connection before\n *                                            enqueuing\n * @param {InstrumentationEventEmitter} [instrumentationEmitter=null]\n */\nmodule.exports = class Connection {\n  constructor({\n    host,\n    port,\n    logger,\n    socketFactory,\n    requestTimeout,\n    rack = null,\n    ssl = null,\n    sasl = null,\n    clientId = 'kafkajs',\n    connectionTimeout = 1000,\n    enforceRequestTimeout = false,\n    maxInFlightRequests = null,\n    instrumentationEmitter = null,\n    retry = {},\n  }) {\n    this.host = host\n    this.port = port\n    this.rack = rack\n    this.clientId = clientId\n    this.broker = `${this.host}:${this.port}`\n    this.logger = logger.namespace('Connection')\n\n    this.socketFactory = socketFactory\n    this.ssl = ssl\n    this.sasl = sasl\n\n    this.retry = retry\n    this.retrier = createRetry({ ...this.retry })\n    this.requestTimeout = requestTimeout\n    this.connectionTimeout = connectionTimeout\n\n    this.bytesBuffered = 0\n    this.bytesNeeded = Decoder.int32Size()\n    this.chunks = []\n\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTED\n    this.correlationId = 0\n    this.requestQueue = new RequestQueue({\n      instrumentationEmitter,\n      maxInFlightRequests,\n      requestTimeout,\n      enforceRequestTimeout,\n      clientId,\n      broker: this.broker,\n      logger: logger.namespace('RequestQueue'),\n      isConnected: () => this.connected,\n    })\n\n    this.authHandlers = null\n    this.authExpectResponse = false\n\n    const log = level => (message, extra = {}) => {\n      const logFn = this.logger[level]\n      logFn(message, { broker: this.broker, clientId, ...extra })\n    }\n\n    this.logDebug = log('debug')\n    this.logError = log('error')\n\n    const env = getEnv()\n    this.shouldLogBuffers = env.KAFKAJS_DEBUG_PROTOCOL_BUFFERS === '1'\n    this.shouldLogFetchBuffer =\n      this.shouldLogBuffers && env.KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS === '1'\n  }\n\n  get connected() {\n    return CONNECTED_STATUS.includes(this.connectionStatus)\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  connect() {\n    return new Promise((resolve, reject) => {\n      if (this.connected) {\n        return resolve(true)\n      }\n\n      let timeoutId\n\n      const onConnect = () => {\n        clearTimeout(timeoutId)\n        this.connectionStatus = CONNECTION_STATUS.CONNECTED\n        this.requestQueue.scheduleRequestTimeoutCheck()\n        resolve(true)\n      }\n\n      const onData = data => {\n        this.processData(data)\n      }\n\n      const onEnd = async () => {\n        clearTimeout(timeoutId)\n\n        const wasConnected = this.connected\n\n        if (this.authHandlers) {\n          this.authHandlers.onError()\n        } else if (wasConnected) {\n          this.logDebug('Kafka server has closed connection')\n          this.rejectRequests(\n            new KafkaJSConnectionClosedError('Closed connection', {\n              host: this.host,\n              port: this.port,\n            })\n          )\n        }\n\n        await this.disconnect()\n      }\n\n      const onError = async e => {\n        clearTimeout(timeoutId)\n\n        const error = new KafkaJSConnectionError(`Connection error: ${e.message}`, {\n          broker: `${this.host}:${this.port}`,\n          code: e.code,\n        })\n\n        this.logError(error.message, { stack: e.stack })\n        this.rejectRequests(error)\n        await this.disconnect()\n\n        reject(error)\n      }\n\n      const onTimeout = async () => {\n        const error = new KafkaJSConnectionError('Connection timeout', {\n          broker: `${this.host}:${this.port}`,\n        })\n\n        this.logError(error.message)\n        this.rejectRequests(error)\n        await this.disconnect()\n        reject(error)\n      }\n\n      this.logDebug(`Connecting`, {\n        ssl: !!this.ssl,\n        sasl: !!this.sasl,\n      })\n\n      try {\n        timeoutId = setTimeout(onTimeout, this.connectionTimeout)\n        this.socket = createSocket({\n          socketFactory: this.socketFactory,\n          host: this.host,\n          port: this.port,\n          ssl: this.ssl,\n          onConnect,\n          onData,\n          onEnd,\n          onError,\n          onTimeout,\n        })\n      } catch (e) {\n        clearTimeout(timeoutId)\n        reject(\n          new KafkaJSConnectionError(`Failed to connect: ${e.message}`, {\n            broker: `${this.host}:${this.port}`,\n          })\n        )\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  async disconnect() {\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTING\n    this.logDebug('disconnecting...')\n\n    await this.requestQueue.waitForPendingRequests()\n    this.requestQueue.destroy()\n\n    if (this.socket) {\n      this.socket.end()\n      this.socket.unref()\n    }\n\n    this.connectionStatus = CONNECTION_STATUS.DISCONNECTED\n    this.logDebug('disconnected')\n    return true\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  authenticate({ authExpectResponse = false, request, response }) {\n    this.authExpectResponse = authExpectResponse\n\n    /**\n     * TODO: rewrite removing the async promise executor\n     */\n\n    /* eslint-disable no-async-promise-executor */\n    return new Promise(async (resolve, reject) => {\n      this.authHandlers = {\n        onSuccess: rawData => {\n          this.authHandlers = null\n          this.authExpectResponse = false\n\n          response\n            .decode(rawData)\n            .then(data => response.parse(data))\n            .then(resolve)\n            .catch(reject)\n        },\n        onError: () => {\n          this.authHandlers = null\n          this.authExpectResponse = false\n\n          reject(\n            new KafkaJSConnectionError('Connection closed by the server', {\n              broker: `${this.host}:${this.port}`,\n            })\n          )\n        },\n      }\n\n      try {\n        const requestPayload = await request.encode()\n\n        this.failIfNotConnected()\n        this.socket.write(requestPayload.buffer, 'binary')\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @param {object} protocol\n   * @param {object} protocol.request It is defined by the protocol and consists of an object with \"apiKey\",\n   *                         \"apiVersion\", \"apiName\" and an \"encode\" function. The encode function\n   *                         must return an instance of Encoder\n   *\n   * @param {object} protocol.response It is defined by the protocol and consists of an object with two functions:\n   *                          \"decode\" and \"parse\"\n   *\n   * @param {number} [protocol.requestTimeout=null] Override for the default requestTimeout\n   * @param {boolean} [protocol.logResponseError=true] Whether to log errors\n   * @returns {Promise<data>} where data is the return of \"response#parse\"\n   */\n  async send({ request, response, requestTimeout = null, logResponseError = true }) {\n    this.failIfNotConnected()\n\n    const expectResponse = !request.expectResponse || request.expectResponse()\n    const sendRequest = async () => {\n      const { clientId } = this\n      const correlationId = this.nextCorrelationId()\n\n      const requestPayload = await createRequest({ request, correlationId, clientId })\n      const { apiKey, apiName, apiVersion } = request\n      this.logDebug(`Request ${requestInfo(request)}`, {\n        correlationId,\n        expectResponse,\n        size: Buffer.byteLength(requestPayload.buffer),\n      })\n\n      return new Promise((resolve, reject) => {\n        try {\n          this.failIfNotConnected()\n          const entry = { apiKey, apiName, apiVersion, correlationId, resolve, reject }\n\n          this.requestQueue.push({\n            entry,\n            expectResponse,\n            requestTimeout,\n            sendRequest: () => {\n              this.socket.write(requestPayload.buffer, 'binary')\n            },\n          })\n        } catch (e) {\n          reject(e)\n        }\n      })\n    }\n\n    const { correlationId, size, entry, payload } = await sendRequest()\n\n    if (!expectResponse) {\n      return\n    }\n\n    try {\n      const payloadDecoded = await response.decode(payload)\n\n      /**\n       * @see KIP-219\n       * If the response indicates that the client-side needs to throttle, do that.\n       */\n      this.requestQueue.maybeThrottle(payloadDecoded.clientSideThrottleTime)\n\n      const data = await response.parse(payloadDecoded)\n      const isFetchApi = entry.apiName === 'Fetch'\n      this.logDebug(`Response ${requestInfo(entry)}`, {\n        correlationId,\n        size,\n        data: isFetchApi && !this.shouldLogFetchBuffer ? '[filtered]' : data,\n      })\n\n      return data\n    } catch (e) {\n      if (logResponseError) {\n        this.logError(`Response ${requestInfo(entry)}`, {\n          error: e.message,\n          correlationId,\n          size,\n        })\n      }\n\n      const isBuffer = Buffer.isBuffer(payload)\n      this.logDebug(`Response ${requestInfo(entry)}`, {\n        error: e.message,\n        correlationId,\n        payload:\n          isBuffer && !this.shouldLogBuffers ? { type: 'Buffer', data: '[filtered]' } : payload,\n      })\n\n      throw e\n    }\n  }\n\n  /**\n   * @private\n   */\n  failIfNotConnected() {\n    if (!this.connected) {\n      throw new KafkaJSConnectionError('Not connected', {\n        broker: `${this.host}:${this.port}`,\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  nextCorrelationId() {\n    if (this.correlationId >= INT_32_MAX_VALUE) {\n      this.correlationId = 0\n    }\n\n    return this.correlationId++\n  }\n\n  /**\n   * @private\n   */\n  processData(rawData) {\n    if (this.authHandlers && !this.authExpectResponse) {\n      return this.authHandlers.onSuccess(rawData)\n    }\n\n    // Accumulate the new chunk\n    this.chunks.push(rawData)\n    this.bytesBuffered += Buffer.byteLength(rawData)\n\n    // Process data if there are enough bytes to read the expected response size,\n    // otherwise keep buffering\n    while (this.bytesNeeded <= this.bytesBuffered) {\n      const buffer = this.chunks.length > 1 ? Buffer.concat(this.chunks) : this.chunks[0]\n      const decoder = new Decoder(buffer)\n      const expectedResponseSize = decoder.readInt32()\n\n      // Return early if not enough bytes to read the full response\n      if (!decoder.canReadBytes(expectedResponseSize)) {\n        this.chunks = [buffer]\n        this.bytesBuffered = Buffer.byteLength(buffer)\n        this.bytesNeeded = Decoder.int32Size() + expectedResponseSize\n        return\n      }\n\n      const response = new Decoder(decoder.readBytes(expectedResponseSize))\n\n      // Reset the buffered chunks as the rest of the bytes\n      const remainderBuffer = decoder.readAll()\n      this.chunks = [remainderBuffer]\n      this.bytesBuffered = Buffer.byteLength(remainderBuffer)\n      this.bytesNeeded = Decoder.int32Size()\n\n      if (this.authHandlers) {\n        const rawResponseSize = Decoder.int32Size() + expectedResponseSize\n        const rawResponseBuffer = buffer.slice(0, rawResponseSize)\n        return this.authHandlers.onSuccess(rawResponseBuffer)\n      }\n\n      const correlationId = response.readInt32()\n      const payload = response.readAll()\n\n      this.requestQueue.fulfillRequest({\n        size: expectedResponseSize,\n        correlationId,\n        payload,\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  rejectRequests(error) {\n    this.requestQueue.rejectAll(error)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}