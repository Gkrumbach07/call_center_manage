{"ast":null,"code":"const Long = require('../utils/long');\n\nconst INT8_SIZE = 1;\nconst INT16_SIZE = 2;\nconst INT32_SIZE = 4;\nconst INT64_SIZE = 8;\nconst MOST_SIGNIFICANT_BIT = 0x80; // 128\n\nconst OTHER_BITS = 0x7f; // 127\n\nconst UNSIGNED_INT32_MAX_NUMBER = 0xffffff80;\nconst UNSIGNED_INT64_MAX_NUMBER = 0xffffffffffffff80n;\nmodule.exports = class Encoder {\n  static encodeZigZag(value) {\n    return value << 1 ^ value >> 31;\n  }\n\n  static encodeZigZag64(value) {\n    const longValue = Long.fromValue(value);\n    return longValue.shiftLeft(1).xor(longValue.shiftRight(63));\n  }\n\n  static sizeOfVarInt(value) {\n    let encodedValue = this.encodeZigZag(value);\n    let bytes = 1;\n\n    while ((encodedValue & UNSIGNED_INT32_MAX_NUMBER) !== 0) {\n      bytes += 1;\n      encodedValue >>>= 7;\n    }\n\n    return bytes;\n  }\n\n  static sizeOfVarLong(value) {\n    let longValue = Encoder.encodeZigZag64(value);\n    let bytes = 1;\n\n    while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {\n      bytes += 1;\n      longValue = longValue.shiftRightUnsigned(7);\n    }\n\n    return bytes;\n  }\n\n  static sizeOfVarIntBytes(value) {\n    const size = value == null ? -1 : Buffer.byteLength(value);\n\n    if (size < 0) {\n      return Encoder.sizeOfVarInt(-1);\n    }\n\n    return Encoder.sizeOfVarInt(size) + size;\n  }\n\n  static nextPowerOfTwo(value) {\n    return 1 << 31 - Math.clz32(value) + 1;\n  }\n  /**\n   * Construct a new encoder with the given initial size\n   *\n   * @param {number} [initialSize] initial size\n   */\n\n\n  constructor(initialSize = 511) {\n    this.buf = Buffer.alloc(Encoder.nextPowerOfTwo(initialSize));\n    this.offset = 0;\n  }\n  /**\n   * @param {Buffer} buffer\n   */\n\n\n  writeBufferInternal(buffer) {\n    const bufferLength = buffer.length;\n    this.ensureAvailable(bufferLength);\n    buffer.copy(this.buf, this.offset, 0);\n    this.offset += bufferLength;\n  }\n\n  ensureAvailable(length) {\n    if (this.offset + length > this.buf.length) {\n      const newLength = Encoder.nextPowerOfTwo(this.offset + length);\n      const newBuffer = Buffer.alloc(newLength);\n      this.buf.copy(newBuffer, 0, 0, this.offset);\n      this.buf = newBuffer;\n    }\n  }\n\n  get buffer() {\n    return this.buf.slice(0, this.offset);\n  }\n\n  writeInt8(value) {\n    this.ensureAvailable(INT8_SIZE);\n    this.buf.writeInt8(value, this.offset);\n    this.offset += INT8_SIZE;\n    return this;\n  }\n\n  writeInt16(value) {\n    this.ensureAvailable(INT16_SIZE);\n    this.buf.writeInt16BE(value, this.offset);\n    this.offset += INT16_SIZE;\n    return this;\n  }\n\n  writeInt32(value) {\n    this.ensureAvailable(INT32_SIZE);\n    this.buf.writeInt32BE(value, this.offset);\n    this.offset += INT32_SIZE;\n    return this;\n  }\n\n  writeUInt32(value) {\n    this.ensureAvailable(INT32_SIZE);\n    this.buf.writeUInt32BE(value, this.offset);\n    this.offset += INT32_SIZE;\n    return this;\n  }\n\n  writeInt64(value) {\n    this.ensureAvailable(INT64_SIZE);\n    const longValue = Long.fromValue(value);\n    this.buf.writeInt32BE(longValue.getHighBits(), this.offset);\n    this.buf.writeInt32BE(longValue.getLowBits(), this.offset + INT32_SIZE);\n    this.offset += INT64_SIZE;\n    return this;\n  }\n\n  writeBoolean(value) {\n    value ? this.writeInt8(1) : this.writeInt8(0);\n    return this;\n  }\n\n  writeString(value) {\n    if (value == null) {\n      this.writeInt16(-1);\n      return this;\n    }\n\n    const byteLength = Buffer.byteLength(value, 'utf8');\n    this.ensureAvailable(INT16_SIZE + byteLength);\n    this.writeInt16(byteLength);\n    this.buf.write(value, this.offset, byteLength, 'utf8');\n    this.offset += byteLength;\n    return this;\n  }\n\n  writeVarIntString(value) {\n    if (value == null) {\n      this.writeVarInt(-1);\n      return this;\n    }\n\n    const byteLength = Buffer.byteLength(value, 'utf8');\n    this.writeVarInt(byteLength);\n    this.ensureAvailable(byteLength);\n    this.buf.write(value, this.offset, byteLength, 'utf8');\n    this.offset += byteLength;\n    return this;\n  }\n\n  writeBytes(value) {\n    if (value == null) {\n      this.writeInt32(-1);\n      return this;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.ensureAvailable(INT32_SIZE + value.length);\n      this.writeInt32(value.length);\n      this.writeBufferInternal(value);\n    } else {\n      const valueToWrite = String(value);\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8');\n      this.ensureAvailable(INT32_SIZE + byteLength);\n      this.writeInt32(byteLength);\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8');\n      this.offset += byteLength;\n    }\n\n    return this;\n  }\n\n  writeVarIntBytes(value) {\n    if (value == null) {\n      this.writeVarInt(-1);\n      return this;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.writeVarInt(value.length);\n      this.writeBufferInternal(value);\n    } else {\n      const valueToWrite = String(value);\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8');\n      this.writeVarInt(byteLength);\n      this.ensureAvailable(byteLength);\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8');\n      this.offset += byteLength;\n    }\n\n    return this;\n  }\n\n  writeEncoder(value) {\n    if (value == null || !Buffer.isBuffer(value.buf)) {\n      throw new Error('value should be an instance of Encoder');\n    }\n\n    this.writeBufferInternal(value.buffer);\n    return this;\n  }\n\n  writeEncoderArray(value) {\n    if (!Array.isArray(value) || value.some(v => v == null || !Buffer.isBuffer(v.buf))) {\n      throw new Error('all values should be an instance of Encoder[]');\n    }\n\n    value.forEach(v => {\n      this.writeBufferInternal(v.buffer);\n    });\n    return this;\n  }\n\n  writeBuffer(value) {\n    if (!Buffer.isBuffer(value)) {\n      throw new Error('value should be an instance of Buffer');\n    }\n\n    this.writeBufferInternal(value);\n    return this;\n  }\n  /**\n   * @param {any[]} array\n   * @param {'int32'|'number'|'string'|'object'} [type]\n   */\n\n\n  writeNullableArray(array, type) {\n    // A null value is encoded with length of -1 and there are no following bytes\n    // On the context of this library, empty array and null are the same thing\n    const length = array.length !== 0 ? array.length : -1;\n    this.writeArray(array, type, length);\n    return this;\n  }\n  /**\n   * @param {any[]} array\n   * @param {'int32'|'number'|'string'|'object'} [type]\n   * @param {number} [length]\n   */\n\n\n  writeArray(array, type, length) {\n    const arrayLength = length == null ? array.length : length;\n    this.writeInt32(arrayLength);\n\n    if (type !== undefined) {\n      switch (type) {\n        case 'int32':\n        case 'number':\n          array.forEach(value => this.writeInt32(value));\n          break;\n\n        case 'string':\n          array.forEach(value => this.writeString(value));\n          break;\n\n        case 'object':\n          this.writeEncoderArray(array);\n          break;\n      }\n    } else {\n      array.forEach(value => {\n        switch (typeof value) {\n          case 'number':\n            this.writeInt32(value);\n            break;\n\n          case 'string':\n            this.writeString(value);\n            break;\n\n          case 'object':\n            this.writeEncoder(value);\n            break;\n        }\n      });\n    }\n\n    return this;\n  }\n\n  writeVarIntArray(array, type) {\n    if (type === 'object') {\n      this.writeVarInt(array.length);\n      this.writeEncoderArray(array);\n    } else {\n      const objectArray = array.filter(v => typeof v === 'object');\n      this.writeVarInt(objectArray.length);\n      this.writeEncoderArray(objectArray);\n    }\n\n    return this;\n  } // Based on:\n  // https://github.com/addthis/stream-lib/blob/master/src/main/java/com/clearspring/analytics/util/Varint.java#L106\n\n\n  writeVarInt(value) {\n    const byteArray = [];\n    let encodedValue = Encoder.encodeZigZag(value);\n\n    while ((encodedValue & UNSIGNED_INT32_MAX_NUMBER) !== 0) {\n      byteArray.push(encodedValue & OTHER_BITS | MOST_SIGNIFICANT_BIT);\n      encodedValue >>>= 7;\n    }\n\n    byteArray.push(encodedValue & OTHER_BITS);\n    this.writeBufferInternal(Buffer.from(byteArray));\n    return this;\n  }\n\n  writeVarLong(value) {\n    const byteArray = [];\n    let longValue = Encoder.encodeZigZag64(value);\n\n    while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {\n      byteArray.push(longValue.and(OTHER_BITS).or(MOST_SIGNIFICANT_BIT).toInt());\n      longValue = longValue.shiftRightUnsigned(7);\n    }\n\n    byteArray.push(longValue.toInt());\n    this.writeBufferInternal(Buffer.from(byteArray));\n    return this;\n  }\n\n  size() {\n    // We can use the offset here directly, because we anyways will not re-encode the buffer when writing\n    return this.offset;\n  }\n\n  toJSON() {\n    return this.buffer.toJSON();\n  }\n\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/encoder.js"],"names":["Long","require","INT8_SIZE","INT16_SIZE","INT32_SIZE","INT64_SIZE","MOST_SIGNIFICANT_BIT","OTHER_BITS","UNSIGNED_INT32_MAX_NUMBER","UNSIGNED_INT64_MAX_NUMBER","module","exports","Encoder","encodeZigZag","value","encodeZigZag64","longValue","fromValue","shiftLeft","xor","shiftRight","sizeOfVarInt","encodedValue","bytes","sizeOfVarLong","and","notEquals","fromInt","shiftRightUnsigned","sizeOfVarIntBytes","size","Buffer","byteLength","nextPowerOfTwo","Math","clz32","constructor","initialSize","buf","alloc","offset","writeBufferInternal","buffer","bufferLength","length","ensureAvailable","copy","newLength","newBuffer","slice","writeInt8","writeInt16","writeInt16BE","writeInt32","writeInt32BE","writeUInt32","writeUInt32BE","writeInt64","getHighBits","getLowBits","writeBoolean","writeString","write","writeVarIntString","writeVarInt","writeBytes","isBuffer","valueToWrite","String","writeVarIntBytes","writeEncoder","Error","writeEncoderArray","Array","isArray","some","v","forEach","writeBuffer","writeNullableArray","array","type","writeArray","arrayLength","undefined","writeVarIntArray","objectArray","filter","byteArray","push","from","writeVarLong","or","toInt","toJSON"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,eAAD,CAApB;;AAEA,MAAMC,SAAS,GAAG,CAAlB;AACA,MAAMC,UAAU,GAAG,CAAnB;AACA,MAAMC,UAAU,GAAG,CAAnB;AACA,MAAMC,UAAU,GAAG,CAAnB;AAEA,MAAMC,oBAAoB,GAAG,IAA7B,C,CAAkC;;AAClC,MAAMC,UAAU,GAAG,IAAnB,C,CAAwB;;AACxB,MAAMC,yBAAyB,GAAG,UAAlC;AACA,MAAMC,yBAAyB,GAAG,mBAAlC;AAEAC,MAAM,CAACC,OAAP,GAAiB,MAAMC,OAAN,CAAc;AAC7B,SAAOC,YAAP,CAAoBC,KAApB,EAA2B;AACzB,WAAQA,KAAK,IAAI,CAAV,GAAgBA,KAAK,IAAI,EAAhC;AACD;;AAED,SAAOC,cAAP,CAAsBD,KAAtB,EAA6B;AAC3B,UAAME,SAAS,GAAGhB,IAAI,CAACiB,SAAL,CAAeH,KAAf,CAAlB;AACA,WAAOE,SAAS,CAACE,SAAV,CAAoB,CAApB,EAAuBC,GAAvB,CAA2BH,SAAS,CAACI,UAAV,CAAqB,EAArB,CAA3B,CAAP;AACD;;AAED,SAAOC,YAAP,CAAoBP,KAApB,EAA2B;AACzB,QAAIQ,YAAY,GAAG,KAAKT,YAAL,CAAkBC,KAAlB,CAAnB;AACA,QAAIS,KAAK,GAAG,CAAZ;;AAEA,WAAO,CAACD,YAAY,GAAGd,yBAAhB,MAA+C,CAAtD,EAAyD;AACvDe,MAAAA,KAAK,IAAI,CAAT;AACAD,MAAAA,YAAY,MAAM,CAAlB;AACD;;AAED,WAAOC,KAAP;AACD;;AAED,SAAOC,aAAP,CAAqBV,KAArB,EAA4B;AAC1B,QAAIE,SAAS,GAAGJ,OAAO,CAACG,cAAR,CAAuBD,KAAvB,CAAhB;AACA,QAAIS,KAAK,GAAG,CAAZ;;AAEA,WAAOP,SAAS,CAACS,GAAV,CAAchB,yBAAd,EAAyCiB,SAAzC,CAAmD1B,IAAI,CAAC2B,OAAL,CAAa,CAAb,CAAnD,CAAP,EAA4E;AAC1EJ,MAAAA,KAAK,IAAI,CAAT;AACAP,MAAAA,SAAS,GAAGA,SAAS,CAACY,kBAAV,CAA6B,CAA7B,CAAZ;AACD;;AAED,WAAOL,KAAP;AACD;;AAED,SAAOM,iBAAP,CAAyBf,KAAzB,EAAgC;AAC9B,UAAMgB,IAAI,GAAGhB,KAAK,IAAI,IAAT,GAAgB,CAAC,CAAjB,GAAqBiB,MAAM,CAACC,UAAP,CAAkBlB,KAAlB,CAAlC;;AAEA,QAAIgB,IAAI,GAAG,CAAX,EAAc;AACZ,aAAOlB,OAAO,CAACS,YAAR,CAAqB,CAAC,CAAtB,CAAP;AACD;;AAED,WAAOT,OAAO,CAACS,YAAR,CAAqBS,IAArB,IAA6BA,IAApC;AACD;;AAED,SAAOG,cAAP,CAAsBnB,KAAtB,EAA6B;AAC3B,WAAO,KAAM,KAAKoB,IAAI,CAACC,KAAL,CAAWrB,KAAX,CAAL,GAAyB,CAAtC;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEsB,EAAAA,WAAW,CAACC,WAAW,GAAG,GAAf,EAAoB;AAC7B,SAAKC,GAAL,GAAWP,MAAM,CAACQ,KAAP,CAAa3B,OAAO,CAACqB,cAAR,CAAuBI,WAAvB,CAAb,CAAX;AACA,SAAKG,MAAL,GAAc,CAAd;AACD;AAED;AACF;AACA;;;AACEC,EAAAA,mBAAmB,CAACC,MAAD,EAAS;AAC1B,UAAMC,YAAY,GAAGD,MAAM,CAACE,MAA5B;AACA,SAAKC,eAAL,CAAqBF,YAArB;AACAD,IAAAA,MAAM,CAACI,IAAP,CAAY,KAAKR,GAAjB,EAAsB,KAAKE,MAA3B,EAAmC,CAAnC;AACA,SAAKA,MAAL,IAAeG,YAAf;AACD;;AAEDE,EAAAA,eAAe,CAACD,MAAD,EAAS;AACtB,QAAI,KAAKJ,MAAL,GAAcI,MAAd,GAAuB,KAAKN,GAAL,CAASM,MAApC,EAA4C;AAC1C,YAAMG,SAAS,GAAGnC,OAAO,CAACqB,cAAR,CAAuB,KAAKO,MAAL,GAAcI,MAArC,CAAlB;AACA,YAAMI,SAAS,GAAGjB,MAAM,CAACQ,KAAP,CAAaQ,SAAb,CAAlB;AACA,WAAKT,GAAL,CAASQ,IAAT,CAAcE,SAAd,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,KAAKR,MAApC;AACA,WAAKF,GAAL,GAAWU,SAAX;AACD;AACF;;AAED,MAAIN,MAAJ,GAAa;AACX,WAAO,KAAKJ,GAAL,CAASW,KAAT,CAAe,CAAf,EAAkB,KAAKT,MAAvB,CAAP;AACD;;AAEDU,EAAAA,SAAS,CAACpC,KAAD,EAAQ;AACf,SAAK+B,eAAL,CAAqB3C,SAArB;AACA,SAAKoC,GAAL,CAASY,SAAT,CAAmBpC,KAAnB,EAA0B,KAAK0B,MAA/B;AACA,SAAKA,MAAL,IAAetC,SAAf;AACA,WAAO,IAAP;AACD;;AAEDiD,EAAAA,UAAU,CAACrC,KAAD,EAAQ;AAChB,SAAK+B,eAAL,CAAqB1C,UAArB;AACA,SAAKmC,GAAL,CAASc,YAAT,CAAsBtC,KAAtB,EAA6B,KAAK0B,MAAlC;AACA,SAAKA,MAAL,IAAerC,UAAf;AACA,WAAO,IAAP;AACD;;AAEDkD,EAAAA,UAAU,CAACvC,KAAD,EAAQ;AAChB,SAAK+B,eAAL,CAAqBzC,UAArB;AACA,SAAKkC,GAAL,CAASgB,YAAT,CAAsBxC,KAAtB,EAA6B,KAAK0B,MAAlC;AACA,SAAKA,MAAL,IAAepC,UAAf;AACA,WAAO,IAAP;AACD;;AAEDmD,EAAAA,WAAW,CAACzC,KAAD,EAAQ;AACjB,SAAK+B,eAAL,CAAqBzC,UAArB;AACA,SAAKkC,GAAL,CAASkB,aAAT,CAAuB1C,KAAvB,EAA8B,KAAK0B,MAAnC;AACA,SAAKA,MAAL,IAAepC,UAAf;AACA,WAAO,IAAP;AACD;;AAEDqD,EAAAA,UAAU,CAAC3C,KAAD,EAAQ;AAChB,SAAK+B,eAAL,CAAqBxC,UAArB;AACA,UAAMW,SAAS,GAAGhB,IAAI,CAACiB,SAAL,CAAeH,KAAf,CAAlB;AACA,SAAKwB,GAAL,CAASgB,YAAT,CAAsBtC,SAAS,CAAC0C,WAAV,EAAtB,EAA+C,KAAKlB,MAApD;AACA,SAAKF,GAAL,CAASgB,YAAT,CAAsBtC,SAAS,CAAC2C,UAAV,EAAtB,EAA8C,KAAKnB,MAAL,GAAcpC,UAA5D;AACA,SAAKoC,MAAL,IAAenC,UAAf;AACA,WAAO,IAAP;AACD;;AAEDuD,EAAAA,YAAY,CAAC9C,KAAD,EAAQ;AAClBA,IAAAA,KAAK,GAAG,KAAKoC,SAAL,CAAe,CAAf,CAAH,GAAuB,KAAKA,SAAL,CAAe,CAAf,CAA5B;AACA,WAAO,IAAP;AACD;;AAEDW,EAAAA,WAAW,CAAC/C,KAAD,EAAQ;AACjB,QAAIA,KAAK,IAAI,IAAb,EAAmB;AACjB,WAAKqC,UAAL,CAAgB,CAAC,CAAjB;AACA,aAAO,IAAP;AACD;;AAED,UAAMnB,UAAU,GAAGD,MAAM,CAACC,UAAP,CAAkBlB,KAAlB,EAAyB,MAAzB,CAAnB;AACA,SAAK+B,eAAL,CAAqB1C,UAAU,GAAG6B,UAAlC;AACA,SAAKmB,UAAL,CAAgBnB,UAAhB;AACA,SAAKM,GAAL,CAASwB,KAAT,CAAehD,KAAf,EAAsB,KAAK0B,MAA3B,EAAmCR,UAAnC,EAA+C,MAA/C;AACA,SAAKQ,MAAL,IAAeR,UAAf;AACA,WAAO,IAAP;AACD;;AAED+B,EAAAA,iBAAiB,CAACjD,KAAD,EAAQ;AACvB,QAAIA,KAAK,IAAI,IAAb,EAAmB;AACjB,WAAKkD,WAAL,CAAiB,CAAC,CAAlB;AACA,aAAO,IAAP;AACD;;AAED,UAAMhC,UAAU,GAAGD,MAAM,CAACC,UAAP,CAAkBlB,KAAlB,EAAyB,MAAzB,CAAnB;AACA,SAAKkD,WAAL,CAAiBhC,UAAjB;AACA,SAAKa,eAAL,CAAqBb,UAArB;AACA,SAAKM,GAAL,CAASwB,KAAT,CAAehD,KAAf,EAAsB,KAAK0B,MAA3B,EAAmCR,UAAnC,EAA+C,MAA/C;AACA,SAAKQ,MAAL,IAAeR,UAAf;AACA,WAAO,IAAP;AACD;;AAEDiC,EAAAA,UAAU,CAACnD,KAAD,EAAQ;AAChB,QAAIA,KAAK,IAAI,IAAb,EAAmB;AACjB,WAAKuC,UAAL,CAAgB,CAAC,CAAjB;AACA,aAAO,IAAP;AACD;;AAED,QAAItB,MAAM,CAACmC,QAAP,CAAgBpD,KAAhB,CAAJ,EAA4B;AAC1B;AACA,WAAK+B,eAAL,CAAqBzC,UAAU,GAAGU,KAAK,CAAC8B,MAAxC;AACA,WAAKS,UAAL,CAAgBvC,KAAK,CAAC8B,MAAtB;AACA,WAAKH,mBAAL,CAAyB3B,KAAzB;AACD,KALD,MAKO;AACL,YAAMqD,YAAY,GAAGC,MAAM,CAACtD,KAAD,CAA3B;AACA,YAAMkB,UAAU,GAAGD,MAAM,CAACC,UAAP,CAAkBmC,YAAlB,EAAgC,MAAhC,CAAnB;AACA,WAAKtB,eAAL,CAAqBzC,UAAU,GAAG4B,UAAlC;AACA,WAAKqB,UAAL,CAAgBrB,UAAhB;AACA,WAAKM,GAAL,CAASwB,KAAT,CAAeK,YAAf,EAA6B,KAAK3B,MAAlC,EAA0CR,UAA1C,EAAsD,MAAtD;AACA,WAAKQ,MAAL,IAAeR,UAAf;AACD;;AAED,WAAO,IAAP;AACD;;AAEDqC,EAAAA,gBAAgB,CAACvD,KAAD,EAAQ;AACtB,QAAIA,KAAK,IAAI,IAAb,EAAmB;AACjB,WAAKkD,WAAL,CAAiB,CAAC,CAAlB;AACA,aAAO,IAAP;AACD;;AAED,QAAIjC,MAAM,CAACmC,QAAP,CAAgBpD,KAAhB,CAAJ,EAA4B;AAC1B;AACA,WAAKkD,WAAL,CAAiBlD,KAAK,CAAC8B,MAAvB;AACA,WAAKH,mBAAL,CAAyB3B,KAAzB;AACD,KAJD,MAIO;AACL,YAAMqD,YAAY,GAAGC,MAAM,CAACtD,KAAD,CAA3B;AACA,YAAMkB,UAAU,GAAGD,MAAM,CAACC,UAAP,CAAkBmC,YAAlB,EAAgC,MAAhC,CAAnB;AACA,WAAKH,WAAL,CAAiBhC,UAAjB;AACA,WAAKa,eAAL,CAAqBb,UAArB;AACA,WAAKM,GAAL,CAASwB,KAAT,CAAeK,YAAf,EAA6B,KAAK3B,MAAlC,EAA0CR,UAA1C,EAAsD,MAAtD;AACA,WAAKQ,MAAL,IAAeR,UAAf;AACD;;AAED,WAAO,IAAP;AACD;;AAEDsC,EAAAA,YAAY,CAACxD,KAAD,EAAQ;AAClB,QAAIA,KAAK,IAAI,IAAT,IAAiB,CAACiB,MAAM,CAACmC,QAAP,CAAgBpD,KAAK,CAACwB,GAAtB,CAAtB,EAAkD;AAChD,YAAM,IAAIiC,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED,SAAK9B,mBAAL,CAAyB3B,KAAK,CAAC4B,MAA/B;AACA,WAAO,IAAP;AACD;;AAED8B,EAAAA,iBAAiB,CAAC1D,KAAD,EAAQ;AACvB,QAAI,CAAC2D,KAAK,CAACC,OAAN,CAAc5D,KAAd,CAAD,IAAyBA,KAAK,CAAC6D,IAAN,CAAWC,CAAC,IAAIA,CAAC,IAAI,IAAL,IAAa,CAAC7C,MAAM,CAACmC,QAAP,CAAgBU,CAAC,CAACtC,GAAlB,CAA9B,CAA7B,EAAoF;AAClF,YAAM,IAAIiC,KAAJ,CAAU,+CAAV,CAAN;AACD;;AAEDzD,IAAAA,KAAK,CAAC+D,OAAN,CAAcD,CAAC,IAAI;AACjB,WAAKnC,mBAAL,CAAyBmC,CAAC,CAAClC,MAA3B;AACD,KAFD;AAGA,WAAO,IAAP;AACD;;AAEDoC,EAAAA,WAAW,CAAChE,KAAD,EAAQ;AACjB,QAAI,CAACiB,MAAM,CAACmC,QAAP,CAAgBpD,KAAhB,CAAL,EAA6B;AAC3B,YAAM,IAAIyD,KAAJ,CAAU,uCAAV,CAAN;AACD;;AAED,SAAK9B,mBAAL,CAAyB3B,KAAzB;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;;AACEiE,EAAAA,kBAAkB,CAACC,KAAD,EAAQC,IAAR,EAAc;AAC9B;AACA;AACA,UAAMrC,MAAM,GAAGoC,KAAK,CAACpC,MAAN,KAAiB,CAAjB,GAAqBoC,KAAK,CAACpC,MAA3B,GAAoC,CAAC,CAApD;AACA,SAAKsC,UAAL,CAAgBF,KAAhB,EAAuBC,IAAvB,EAA6BrC,MAA7B;AACA,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEsC,EAAAA,UAAU,CAACF,KAAD,EAAQC,IAAR,EAAcrC,MAAd,EAAsB;AAC9B,UAAMuC,WAAW,GAAGvC,MAAM,IAAI,IAAV,GAAiBoC,KAAK,CAACpC,MAAvB,GAAgCA,MAApD;AACA,SAAKS,UAAL,CAAgB8B,WAAhB;;AACA,QAAIF,IAAI,KAAKG,SAAb,EAAwB;AACtB,cAAQH,IAAR;AACE,aAAK,OAAL;AACA,aAAK,QAAL;AACED,UAAAA,KAAK,CAACH,OAAN,CAAc/D,KAAK,IAAI,KAAKuC,UAAL,CAAgBvC,KAAhB,CAAvB;AACA;;AACF,aAAK,QAAL;AACEkE,UAAAA,KAAK,CAACH,OAAN,CAAc/D,KAAK,IAAI,KAAK+C,WAAL,CAAiB/C,KAAjB,CAAvB;AACA;;AACF,aAAK,QAAL;AACE,eAAK0D,iBAAL,CAAuBQ,KAAvB;AACA;AAVJ;AAYD,KAbD,MAaO;AACLA,MAAAA,KAAK,CAACH,OAAN,CAAc/D,KAAK,IAAI;AACrB,gBAAQ,OAAOA,KAAf;AACE,eAAK,QAAL;AACE,iBAAKuC,UAAL,CAAgBvC,KAAhB;AACA;;AACF,eAAK,QAAL;AACE,iBAAK+C,WAAL,CAAiB/C,KAAjB;AACA;;AACF,eAAK,QAAL;AACE,iBAAKwD,YAAL,CAAkBxD,KAAlB;AACA;AATJ;AAWD,OAZD;AAaD;;AACD,WAAO,IAAP;AACD;;AAEDuE,EAAAA,gBAAgB,CAACL,KAAD,EAAQC,IAAR,EAAc;AAC5B,QAAIA,IAAI,KAAK,QAAb,EAAuB;AACrB,WAAKjB,WAAL,CAAiBgB,KAAK,CAACpC,MAAvB;AACA,WAAK4B,iBAAL,CAAuBQ,KAAvB;AACD,KAHD,MAGO;AACL,YAAMM,WAAW,GAAGN,KAAK,CAACO,MAAN,CAAaX,CAAC,IAAI,OAAOA,CAAP,KAAa,QAA/B,CAApB;AACA,WAAKZ,WAAL,CAAiBsB,WAAW,CAAC1C,MAA7B;AACA,WAAK4B,iBAAL,CAAuBc,WAAvB;AACD;;AACD,WAAO,IAAP;AACD,GA9R4B,CAgS7B;AACA;;;AACAtB,EAAAA,WAAW,CAAClD,KAAD,EAAQ;AACjB,UAAM0E,SAAS,GAAG,EAAlB;AACA,QAAIlE,YAAY,GAAGV,OAAO,CAACC,YAAR,CAAqBC,KAArB,CAAnB;;AAEA,WAAO,CAACQ,YAAY,GAAGd,yBAAhB,MAA+C,CAAtD,EAAyD;AACvDgF,MAAAA,SAAS,CAACC,IAAV,CAAgBnE,YAAY,GAAGf,UAAhB,GAA8BD,oBAA7C;AACAgB,MAAAA,YAAY,MAAM,CAAlB;AACD;;AAEDkE,IAAAA,SAAS,CAACC,IAAV,CAAenE,YAAY,GAAGf,UAA9B;AACA,SAAKkC,mBAAL,CAAyBV,MAAM,CAAC2D,IAAP,CAAYF,SAAZ,CAAzB;AACA,WAAO,IAAP;AACD;;AAEDG,EAAAA,YAAY,CAAC7E,KAAD,EAAQ;AAClB,UAAM0E,SAAS,GAAG,EAAlB;AACA,QAAIxE,SAAS,GAAGJ,OAAO,CAACG,cAAR,CAAuBD,KAAvB,CAAhB;;AAEA,WAAOE,SAAS,CAACS,GAAV,CAAchB,yBAAd,EAAyCiB,SAAzC,CAAmD1B,IAAI,CAAC2B,OAAL,CAAa,CAAb,CAAnD,CAAP,EAA4E;AAC1E6D,MAAAA,SAAS,CAACC,IAAV,CACEzE,SAAS,CACNS,GADH,CACOlB,UADP,EAEGqF,EAFH,CAEMtF,oBAFN,EAGGuF,KAHH,EADF;AAMA7E,MAAAA,SAAS,GAAGA,SAAS,CAACY,kBAAV,CAA6B,CAA7B,CAAZ;AACD;;AAED4D,IAAAA,SAAS,CAACC,IAAV,CAAezE,SAAS,CAAC6E,KAAV,EAAf;AAEA,SAAKpD,mBAAL,CAAyBV,MAAM,CAAC2D,IAAP,CAAYF,SAAZ,CAAzB;AACA,WAAO,IAAP;AACD;;AAED1D,EAAAA,IAAI,GAAG;AACL;AACA,WAAO,KAAKU,MAAZ;AACD;;AAEDsD,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKpD,MAAL,CAAYoD,MAAZ,EAAP;AACD;;AA3U4B,CAA/B","sourcesContent":["const Long = require('../utils/long')\n\nconst INT8_SIZE = 1\nconst INT16_SIZE = 2\nconst INT32_SIZE = 4\nconst INT64_SIZE = 8\n\nconst MOST_SIGNIFICANT_BIT = 0x80 // 128\nconst OTHER_BITS = 0x7f // 127\nconst UNSIGNED_INT32_MAX_NUMBER = 0xffffff80\nconst UNSIGNED_INT64_MAX_NUMBER = 0xffffffffffffff80n\n\nmodule.exports = class Encoder {\n  static encodeZigZag(value) {\n    return (value << 1) ^ (value >> 31)\n  }\n\n  static encodeZigZag64(value) {\n    const longValue = Long.fromValue(value)\n    return longValue.shiftLeft(1).xor(longValue.shiftRight(63))\n  }\n\n  static sizeOfVarInt(value) {\n    let encodedValue = this.encodeZigZag(value)\n    let bytes = 1\n\n    while ((encodedValue & UNSIGNED_INT32_MAX_NUMBER) !== 0) {\n      bytes += 1\n      encodedValue >>>= 7\n    }\n\n    return bytes\n  }\n\n  static sizeOfVarLong(value) {\n    let longValue = Encoder.encodeZigZag64(value)\n    let bytes = 1\n\n    while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {\n      bytes += 1\n      longValue = longValue.shiftRightUnsigned(7)\n    }\n\n    return bytes\n  }\n\n  static sizeOfVarIntBytes(value) {\n    const size = value == null ? -1 : Buffer.byteLength(value)\n\n    if (size < 0) {\n      return Encoder.sizeOfVarInt(-1)\n    }\n\n    return Encoder.sizeOfVarInt(size) + size\n  }\n\n  static nextPowerOfTwo(value) {\n    return 1 << (31 - Math.clz32(value) + 1)\n  }\n\n  /**\n   * Construct a new encoder with the given initial size\n   *\n   * @param {number} [initialSize] initial size\n   */\n  constructor(initialSize = 511) {\n    this.buf = Buffer.alloc(Encoder.nextPowerOfTwo(initialSize))\n    this.offset = 0\n  }\n\n  /**\n   * @param {Buffer} buffer\n   */\n  writeBufferInternal(buffer) {\n    const bufferLength = buffer.length\n    this.ensureAvailable(bufferLength)\n    buffer.copy(this.buf, this.offset, 0)\n    this.offset += bufferLength\n  }\n\n  ensureAvailable(length) {\n    if (this.offset + length > this.buf.length) {\n      const newLength = Encoder.nextPowerOfTwo(this.offset + length)\n      const newBuffer = Buffer.alloc(newLength)\n      this.buf.copy(newBuffer, 0, 0, this.offset)\n      this.buf = newBuffer\n    }\n  }\n\n  get buffer() {\n    return this.buf.slice(0, this.offset)\n  }\n\n  writeInt8(value) {\n    this.ensureAvailable(INT8_SIZE)\n    this.buf.writeInt8(value, this.offset)\n    this.offset += INT8_SIZE\n    return this\n  }\n\n  writeInt16(value) {\n    this.ensureAvailable(INT16_SIZE)\n    this.buf.writeInt16BE(value, this.offset)\n    this.offset += INT16_SIZE\n    return this\n  }\n\n  writeInt32(value) {\n    this.ensureAvailable(INT32_SIZE)\n    this.buf.writeInt32BE(value, this.offset)\n    this.offset += INT32_SIZE\n    return this\n  }\n\n  writeUInt32(value) {\n    this.ensureAvailable(INT32_SIZE)\n    this.buf.writeUInt32BE(value, this.offset)\n    this.offset += INT32_SIZE\n    return this\n  }\n\n  writeInt64(value) {\n    this.ensureAvailable(INT64_SIZE)\n    const longValue = Long.fromValue(value)\n    this.buf.writeInt32BE(longValue.getHighBits(), this.offset)\n    this.buf.writeInt32BE(longValue.getLowBits(), this.offset + INT32_SIZE)\n    this.offset += INT64_SIZE\n    return this\n  }\n\n  writeBoolean(value) {\n    value ? this.writeInt8(1) : this.writeInt8(0)\n    return this\n  }\n\n  writeString(value) {\n    if (value == null) {\n      this.writeInt16(-1)\n      return this\n    }\n\n    const byteLength = Buffer.byteLength(value, 'utf8')\n    this.ensureAvailable(INT16_SIZE + byteLength)\n    this.writeInt16(byteLength)\n    this.buf.write(value, this.offset, byteLength, 'utf8')\n    this.offset += byteLength\n    return this\n  }\n\n  writeVarIntString(value) {\n    if (value == null) {\n      this.writeVarInt(-1)\n      return this\n    }\n\n    const byteLength = Buffer.byteLength(value, 'utf8')\n    this.writeVarInt(byteLength)\n    this.ensureAvailable(byteLength)\n    this.buf.write(value, this.offset, byteLength, 'utf8')\n    this.offset += byteLength\n    return this\n  }\n\n  writeBytes(value) {\n    if (value == null) {\n      this.writeInt32(-1)\n      return this\n    }\n\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.ensureAvailable(INT32_SIZE + value.length)\n      this.writeInt32(value.length)\n      this.writeBufferInternal(value)\n    } else {\n      const valueToWrite = String(value)\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8')\n      this.ensureAvailable(INT32_SIZE + byteLength)\n      this.writeInt32(byteLength)\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8')\n      this.offset += byteLength\n    }\n\n    return this\n  }\n\n  writeVarIntBytes(value) {\n    if (value == null) {\n      this.writeVarInt(-1)\n      return this\n    }\n\n    if (Buffer.isBuffer(value)) {\n      // raw bytes\n      this.writeVarInt(value.length)\n      this.writeBufferInternal(value)\n    } else {\n      const valueToWrite = String(value)\n      const byteLength = Buffer.byteLength(valueToWrite, 'utf8')\n      this.writeVarInt(byteLength)\n      this.ensureAvailable(byteLength)\n      this.buf.write(valueToWrite, this.offset, byteLength, 'utf8')\n      this.offset += byteLength\n    }\n\n    return this\n  }\n\n  writeEncoder(value) {\n    if (value == null || !Buffer.isBuffer(value.buf)) {\n      throw new Error('value should be an instance of Encoder')\n    }\n\n    this.writeBufferInternal(value.buffer)\n    return this\n  }\n\n  writeEncoderArray(value) {\n    if (!Array.isArray(value) || value.some(v => v == null || !Buffer.isBuffer(v.buf))) {\n      throw new Error('all values should be an instance of Encoder[]')\n    }\n\n    value.forEach(v => {\n      this.writeBufferInternal(v.buffer)\n    })\n    return this\n  }\n\n  writeBuffer(value) {\n    if (!Buffer.isBuffer(value)) {\n      throw new Error('value should be an instance of Buffer')\n    }\n\n    this.writeBufferInternal(value)\n    return this\n  }\n\n  /**\n   * @param {any[]} array\n   * @param {'int32'|'number'|'string'|'object'} [type]\n   */\n  writeNullableArray(array, type) {\n    // A null value is encoded with length of -1 and there are no following bytes\n    // On the context of this library, empty array and null are the same thing\n    const length = array.length !== 0 ? array.length : -1\n    this.writeArray(array, type, length)\n    return this\n  }\n\n  /**\n   * @param {any[]} array\n   * @param {'int32'|'number'|'string'|'object'} [type]\n   * @param {number} [length]\n   */\n  writeArray(array, type, length) {\n    const arrayLength = length == null ? array.length : length\n    this.writeInt32(arrayLength)\n    if (type !== undefined) {\n      switch (type) {\n        case 'int32':\n        case 'number':\n          array.forEach(value => this.writeInt32(value))\n          break\n        case 'string':\n          array.forEach(value => this.writeString(value))\n          break\n        case 'object':\n          this.writeEncoderArray(array)\n          break\n      }\n    } else {\n      array.forEach(value => {\n        switch (typeof value) {\n          case 'number':\n            this.writeInt32(value)\n            break\n          case 'string':\n            this.writeString(value)\n            break\n          case 'object':\n            this.writeEncoder(value)\n            break\n        }\n      })\n    }\n    return this\n  }\n\n  writeVarIntArray(array, type) {\n    if (type === 'object') {\n      this.writeVarInt(array.length)\n      this.writeEncoderArray(array)\n    } else {\n      const objectArray = array.filter(v => typeof v === 'object')\n      this.writeVarInt(objectArray.length)\n      this.writeEncoderArray(objectArray)\n    }\n    return this\n  }\n\n  // Based on:\n  // https://github.com/addthis/stream-lib/blob/master/src/main/java/com/clearspring/analytics/util/Varint.java#L106\n  writeVarInt(value) {\n    const byteArray = []\n    let encodedValue = Encoder.encodeZigZag(value)\n\n    while ((encodedValue & UNSIGNED_INT32_MAX_NUMBER) !== 0) {\n      byteArray.push((encodedValue & OTHER_BITS) | MOST_SIGNIFICANT_BIT)\n      encodedValue >>>= 7\n    }\n\n    byteArray.push(encodedValue & OTHER_BITS)\n    this.writeBufferInternal(Buffer.from(byteArray))\n    return this\n  }\n\n  writeVarLong(value) {\n    const byteArray = []\n    let longValue = Encoder.encodeZigZag64(value)\n\n    while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {\n      byteArray.push(\n        longValue\n          .and(OTHER_BITS)\n          .or(MOST_SIGNIFICANT_BIT)\n          .toInt()\n      )\n      longValue = longValue.shiftRightUnsigned(7)\n    }\n\n    byteArray.push(longValue.toInt())\n\n    this.writeBufferInternal(Buffer.from(byteArray))\n    return this\n  }\n\n  size() {\n    // We can use the offset here directly, because we anyways will not re-encode the buffer when writing\n    return this.offset\n  }\n\n  toJSON() {\n    return this.buffer.toJSON()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}