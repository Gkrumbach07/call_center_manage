{"ast":null,"code":"const Long = require('../utils/long');\n\nconst Lock = require('../utils/lock');\n\nconst {\n  Types: Compression\n} = require('../protocol/message/compression');\n\nconst {\n  requests,\n  lookup\n} = require('../protocol/requests');\n\nconst {\n  KafkaJSNonRetriableError\n} = require('../errors');\n\nconst apiKeys = require('../protocol/requests/apiKeys');\n\nconst SASLAuthenticator = require('./saslAuthenticator');\n\nconst shuffle = require('../utils/shuffle');\n\nconst PRIVATE = {\n  SHOULD_REAUTHENTICATE: Symbol('private:Broker:shouldReauthenticate'),\n  SEND_REQUEST: Symbol('private:Broker:sendRequest')\n};\n/**\n * Each node in a Kafka cluster is called broker. This class contains\n * the high-level operations a node can perform.\n *\n * @type {import(\"../../types\").Broker}\n * @param {Connection} connection\n * @param {Object} logger\n * @param {Object} [versions=null] The object with all available versions and APIs\n *                                 supported by this cluster. The output of broker#apiVersions\n * @param {number} [authenticationTimeout=1000]\n * @param {boolean} [allowAutoTopicCreation=true] If this and the broker config 'auto.create.topics.enable'\n *                                                are true, topics that don't exist will be created when\n *                                                fetching metadata.\n * @param {boolean} [supportAuthenticationProtocol=null] If the server supports the SASLAuthenticate protocol\n */\n\nmodule.exports = class Broker {\n  constructor({\n    connection,\n    logger,\n    nodeId = null,\n    versions = null,\n    authenticationTimeout = 1000,\n    reauthenticationThreshold = 10000,\n    allowAutoTopicCreation = true,\n    supportAuthenticationProtocol = null\n  }) {\n    this.connection = connection;\n    this.nodeId = nodeId;\n    this.rootLogger = logger;\n    this.logger = logger.namespace('Broker');\n    this.versions = versions;\n    this.authenticationTimeout = authenticationTimeout;\n    this.reauthenticationThreshold = reauthenticationThreshold;\n    this.allowAutoTopicCreation = allowAutoTopicCreation;\n    this.supportAuthenticationProtocol = supportAuthenticationProtocol;\n    this.authenticatedAt = null;\n    this.sessionLifetime = Long.ZERO; // The lock timeout has twice the connectionTimeout because the same timeout is used\n    // for the first apiVersions call\n\n    const lockTimeout = 2 * this.connection.connectionTimeout + this.authenticationTimeout;\n    this.brokerAddress = `${this.connection.host}:${this.connection.port}`;\n    this.lock = new Lock({\n      timeout: lockTimeout,\n      description: `connect to broker ${this.brokerAddress}`\n    });\n\n    this.lookupRequest = () => {\n      throw new Error('Broker not connected');\n    };\n  }\n  /**\n   * @public\n   * @returns {boolean}\n   */\n\n\n  isConnected() {\n    const {\n      connected,\n      sasl\n    } = this.connection;\n    const isAuthenticated = this.authenticatedAt != null && !this[PRIVATE.SHOULD_REAUTHENTICATE]();\n    return sasl ? connected && isAuthenticated : connected;\n  }\n  /**\n   * @public\n   * @returns {Promise}\n   */\n\n\n  async connect() {\n    try {\n      await this.lock.acquire();\n\n      if (this.isConnected()) {\n        return;\n      }\n\n      this.authenticatedAt = null;\n      await this.connection.connect();\n\n      if (!this.versions) {\n        this.versions = await this.apiVersions();\n      }\n\n      this.lookupRequest = lookup(this.versions);\n\n      if (this.supportAuthenticationProtocol === null) {\n        try {\n          this.lookupRequest(apiKeys.SaslAuthenticate, requests.SaslAuthenticate);\n          this.supportAuthenticationProtocol = true;\n        } catch (_) {\n          this.supportAuthenticationProtocol = false;\n        }\n\n        this.logger.debug(`Verified support for SaslAuthenticate`, {\n          broker: this.brokerAddress,\n          supportAuthenticationProtocol: this.supportAuthenticationProtocol\n        });\n      }\n\n      if (this.authenticatedAt == null && this.connection.sasl) {\n        const authenticator = new SASLAuthenticator(this.connection, this.rootLogger, this.versions, this.supportAuthenticationProtocol);\n        await authenticator.authenticate();\n        this.authenticatedAt = process.hrtime();\n        this.sessionLifetime = Long.fromValue(authenticator.sessionLifetime);\n      }\n    } finally {\n      await this.lock.release();\n    }\n  }\n  /**\n   * @public\n   * @returns {Promise}\n   */\n\n\n  async disconnect() {\n    this.authenticatedAt = null;\n    await this.connection.disconnect();\n  }\n  /**\n   * @public\n   * @returns {Promise}\n   */\n\n\n  async apiVersions() {\n    let response;\n    const availableVersions = requests.ApiVersions.versions.map(Number).sort().reverse(); // Find the best version implemented by the server\n\n    for (const candidateVersion of availableVersions) {\n      try {\n        const apiVersions = requests.ApiVersions.protocol({\n          version: candidateVersion\n        });\n        response = await this[PRIVATE.SEND_REQUEST]({ ...apiVersions(),\n          requestTimeout: this.connection.connectionTimeout\n        });\n        break;\n      } catch (e) {\n        if (e.type !== 'UNSUPPORTED_VERSION') {\n          throw e;\n        }\n      }\n    }\n\n    if (!response) {\n      throw new KafkaJSNonRetriableError('API Versions not supported');\n    }\n\n    return response.apiVersions.reduce((obj, version) => Object.assign(obj, {\n      [version.apiKey]: {\n        minVersion: version.minVersion,\n        maxVersion: version.maxVersion\n      }\n    }), {});\n  }\n  /**\n   * @public\n   * @type {import(\"../../types\").Broker['metadata']}\n   * @param {Array} [topics=[]] An array of topics to fetch metadata for.\n   *                            If no topics are specified fetch metadata for all topics\n   */\n\n\n  async metadata(topics = []) {\n    const metadata = this.lookupRequest(apiKeys.Metadata, requests.Metadata);\n    const shuffledTopics = shuffle(topics);\n    return await this[PRIVATE.SEND_REQUEST](metadata({\n      topics: shuffledTopics,\n      allowAutoTopicCreation: this.allowAutoTopicCreation\n    }));\n  }\n  /**\n   * @public\n   * @param {Array} topicData An array of messages per topic and per partition, example:\n   *                          [\n   *                            {\n   *                              topic: 'test-topic-1',\n   *                              partitions: [\n   *                                {\n   *                                  partition: 0,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '1', value: 'A' },\n   *                                    { key: '2', value: 'B' },\n   *                                  ]\n   *                                },\n   *                                {\n   *                                  partition: 1,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '3', value: 'C' },\n   *                                  ]\n   *                                }\n   *                              ]\n   *                            },\n   *                            {\n   *                              topic: 'test-topic-2',\n   *                              partitions: [\n   *                                {\n   *                                  partition: 4,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '32', value: 'E' },\n   *                                  ]\n   *                                },\n   *                              ]\n   *                            },\n   *                          ]\n   * @param {number} [acks=-1] Control the number of required acks.\n   *                           -1 = all replicas must acknowledge\n   *                            0 = no acknowledgments\n   *                            1 = only waits for the leader to acknowledge\n   * @param {number} [timeout=30000] The time to await a response in ms\n   * @param {string} [transactionalId=null]\n   * @param {number} [producerId=-1] Broker assigned producerId\n   * @param {number} [producerEpoch=0] Broker assigned producerEpoch\n   * @param {Compression.Types} [compression=Compression.Types.None] Compression codec\n   * @returns {Promise}\n   */\n\n\n  async produce({\n    topicData,\n    transactionalId,\n    producerId,\n    producerEpoch,\n    acks = -1,\n    timeout = 30000,\n    compression = Compression.None\n  }) {\n    const produce = this.lookupRequest(apiKeys.Produce, requests.Produce);\n    return await this[PRIVATE.SEND_REQUEST](produce({\n      acks,\n      timeout,\n      compression,\n      topicData,\n      transactionalId,\n      producerId,\n      producerEpoch\n    }));\n  }\n  /**\n   * @public\n   * @param {number} replicaId=-1 Broker id of the follower. For normal consumers, use -1\n   * @param {number} isolationLevel=1 This setting controls the visibility of transactional records. Default READ_COMMITTED.\n   * @param {number} maxWaitTime=5000 Maximum time in ms to wait for the response\n   * @param {number} minBytes=1 Minimum bytes to accumulate in the response\n   * @param {number} maxBytes=10485760 Maximum bytes to accumulate in the response. Note that this is\n   *                                   not an absolute maximum, if the first message in the first non-empty\n   *                                   partition of the fetch is larger than this value, the message will still\n   *                                   be returned to ensure that progress can be made. Default 10MB.\n   * @param {Array} topics Topics to fetch\n   *                        [\n   *                          {\n   *                            topic: 'topic-name',\n   *                            partitions: [\n   *                              {\n   *                                partition: 0,\n   *                                fetchOffset: '4124',\n   *                                maxBytes: 2048\n   *                              }\n   *                            ]\n   *                          }\n   *                        ]\n   * @param {string} rackId='' A rack identifier for this client. This can be any string value which indicates where this\n   *                           client is physically located. It corresponds with the broker config `broker.rack`.\n   * @returns {Promise}\n   */\n\n\n  async fetch({\n    replicaId,\n    isolationLevel,\n    maxWaitTime = 5000,\n    minBytes = 1,\n    maxBytes = 10485760,\n    topics,\n    rackId = ''\n  }) {\n    // TODO: validate topics not null/empty\n    const fetch = this.lookupRequest(apiKeys.Fetch, requests.Fetch); // Shuffle topic-partitions to ensure fair response allocation across partitions (KIP-74)\n\n    const flattenedTopicPartitions = topics.reduce((topicPartitions, {\n      topic,\n      partitions\n    }) => {\n      partitions.forEach(partition => {\n        topicPartitions.push({\n          topic,\n          partition\n        });\n      });\n      return topicPartitions;\n    }, []);\n    const shuffledTopicPartitions = shuffle(flattenedTopicPartitions); // Consecutive partitions for the same topic can be combined into a single `topic` entry\n\n    const consolidatedTopicPartitions = shuffledTopicPartitions.reduce((topicPartitions, {\n      topic,\n      partition\n    }) => {\n      const last = topicPartitions[topicPartitions.length - 1];\n\n      if (last != null && last.topic === topic) {\n        topicPartitions[topicPartitions.length - 1].partitions.push(partition);\n      } else {\n        topicPartitions.push({\n          topic,\n          partitions: [partition]\n        });\n      }\n\n      return topicPartitions;\n    }, []);\n    return await this[PRIVATE.SEND_REQUEST](fetch({\n      replicaId,\n      isolationLevel,\n      maxWaitTime,\n      minBytes,\n      maxBytes,\n      topics: consolidatedTopicPartitions,\n      rackId\n    }));\n  }\n  /**\n   * @public\n   * @param {string} groupId The group id\n   * @param {number} groupGenerationId The generation of the group\n   * @param {string} memberId The member id assigned by the group coordinator\n   * @returns {Promise}\n   */\n\n\n  async heartbeat({\n    groupId,\n    groupGenerationId,\n    memberId\n  }) {\n    const heartbeat = this.lookupRequest(apiKeys.Heartbeat, requests.Heartbeat);\n    return await this[PRIVATE.SEND_REQUEST](heartbeat({\n      groupId,\n      groupGenerationId,\n      memberId\n    }));\n  }\n  /**\n   * @public\n   * @param {string} groupId The unique group id\n   * @param {CoordinatorType} coordinatorType The type of coordinator to find\n   * @returns {Promise}\n   */\n\n\n  async findGroupCoordinator({\n    groupId,\n    coordinatorType\n  }) {\n    // TODO: validate groupId, mandatory\n    const findCoordinator = this.lookupRequest(apiKeys.GroupCoordinator, requests.GroupCoordinator);\n    return await this[PRIVATE.SEND_REQUEST](findCoordinator({\n      groupId,\n      coordinatorType\n    }));\n  }\n  /**\n   * @public\n   * @param {string} groupId The unique group id\n   * @param {number} sessionTimeout The coordinator considers the consumer dead if it receives\n   *                                no heartbeat after this timeout in ms\n   * @param {number} rebalanceTimeout The maximum time that the coordinator will wait for each member\n   *                                  to rejoin when rebalancing the group\n   * @param {string} [memberId=\"\"] The assigned consumer id or an empty string for a new consumer\n   * @param {string} [protocolType=\"consumer\"] Unique name for class of protocols implemented by group\n   * @param {Array} groupProtocols List of protocols that the member supports (assignment strategy)\n   *                                [{ name: 'AssignerName', metadata: '{\"version\": 1, \"topics\": []}' }]\n   * @returns {Promise}\n   */\n\n\n  async joinGroup({\n    groupId,\n    sessionTimeout,\n    rebalanceTimeout,\n    memberId = '',\n    protocolType = 'consumer',\n    groupProtocols\n  }) {\n    const joinGroup = this.lookupRequest(apiKeys.JoinGroup, requests.JoinGroup);\n\n    const makeRequest = (assignedMemberId = memberId) => this[PRIVATE.SEND_REQUEST](joinGroup({\n      groupId,\n      sessionTimeout,\n      rebalanceTimeout,\n      memberId: assignedMemberId,\n      protocolType,\n      groupProtocols\n    }));\n\n    try {\n      return await makeRequest();\n    } catch (error) {\n      if (error.name === 'KafkaJSMemberIdRequired') {\n        return makeRequest(error.memberId);\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {string} memberId\n   * @returns {Promise}\n   */\n\n\n  async leaveGroup({\n    groupId,\n    memberId\n  }) {\n    const leaveGroup = this.lookupRequest(apiKeys.LeaveGroup, requests.LeaveGroup);\n    return await this[PRIVATE.SEND_REQUEST](leaveGroup({\n      groupId,\n      memberId\n    }));\n  }\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {number} generationId\n   * @param {string} memberId\n   * @param {object} groupAssignment\n   * @returns {Promise}\n   */\n\n\n  async syncGroup({\n    groupId,\n    generationId,\n    memberId,\n    groupAssignment\n  }) {\n    const syncGroup = this.lookupRequest(apiKeys.SyncGroup, requests.SyncGroup);\n    return await this[PRIVATE.SEND_REQUEST](syncGroup({\n      groupId,\n      generationId,\n      memberId,\n      groupAssignment\n    }));\n  }\n  /**\n   * @public\n   * @param {number} replicaId=-1 Broker id of the follower. For normal consumers, use -1\n   * @param {number} isolationLevel=1 This setting controls the visibility of transactional records (default READ_COMMITTED, Kafka >0.11 only)\n   * @param {TopicPartitionOffset[]} topics e.g:\n   *\n   * @typedef {Object} TopicPartitionOffset\n   * @property {string} topic\n   * @property {PartitionOffset[]} partitions\n   *\n   * @typedef {Object} PartitionOffset\n   * @property {number} partition\n   * @property {number} [timestamp=-1]\n   *\n   *\n   * @returns {Promise}\n   */\n\n\n  async listOffsets({\n    replicaId,\n    isolationLevel,\n    topics\n  }) {\n    const listOffsets = this.lookupRequest(apiKeys.ListOffsets, requests.ListOffsets);\n    const result = await this[PRIVATE.SEND_REQUEST](listOffsets({\n      replicaId,\n      isolationLevel,\n      topics\n    })); // ListOffsets >= v1 will return a single `offset` rather than an array of `offsets` (ListOffsets V0).\n    // Normalize to just return `offset`.\n\n    for (const response of result.responses) {\n      response.partitions = response.partitions.map(({\n        offsets,\n        ...partitionData\n      }) => {\n        return offsets ? { ...partitionData,\n          offset: offsets.pop()\n        } : partitionData;\n      });\n    }\n\n    return result;\n  }\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {number} groupGenerationId\n   * @param {string} memberId\n   * @param {number} [retentionTime=-1] -1 signals to the broker that its default configuration\n   *                                    should be used.\n   * @param {object} topics Topics to commit offsets, e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [\n   *                        { partition: 0, offset: '11' }\n   *                      ]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n\n\n  async offsetCommit({\n    groupId,\n    groupGenerationId,\n    memberId,\n    retentionTime,\n    topics\n  }) {\n    const offsetCommit = this.lookupRequest(apiKeys.OffsetCommit, requests.OffsetCommit);\n    return await this[PRIVATE.SEND_REQUEST](offsetCommit({\n      groupId,\n      groupGenerationId,\n      memberId,\n      retentionTime,\n      topics\n    }));\n  }\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {object} topics - If the topic array is null fetch offsets for all topics. e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [\n   *                        { partition: 0 }\n   *                      ]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n\n\n  async offsetFetch({\n    groupId,\n    topics\n  }) {\n    const offsetFetch = this.lookupRequest(apiKeys.OffsetFetch, requests.OffsetFetch);\n    return await this[PRIVATE.SEND_REQUEST](offsetFetch({\n      groupId,\n      topics\n    }));\n  }\n  /**\n   * @public\n   * @param {Array} groupIds\n   * @returns {Promise}\n   */\n\n\n  async describeGroups({\n    groupIds\n  }) {\n    const describeGroups = this.lookupRequest(apiKeys.DescribeGroups, requests.DescribeGroups);\n    return await this[PRIVATE.SEND_REQUEST](describeGroups({\n      groupIds\n    }));\n  }\n  /**\n   * @public\n   * @param {Array} topics e.g:\n   *                 [\n   *                   {\n   *                     topic: 'topic-name',\n   *                     numPartitions: 1,\n   *                     replicationFactor: 1\n   *                   }\n   *                 ]\n   * @param {boolean} [validateOnly=false] If this is true, the request will be validated, but the topic\n   *                                       won't be created\n   * @param {number} [timeout=5000] The time in ms to wait for a topic to be completely created\n   *                                on the controller node\n   * @returns {Promise}\n   */\n\n\n  async createTopics({\n    topics,\n    validateOnly = false,\n    timeout = 5000\n  }) {\n    const createTopics = this.lookupRequest(apiKeys.CreateTopics, requests.CreateTopics);\n    return await this[PRIVATE.SEND_REQUEST](createTopics({\n      topics,\n      validateOnly,\n      timeout\n    }));\n  }\n  /**\n   * @public\n   * @param {Array} topicPartitions e.g:\n   *                 [\n   *                   {\n   *                     topic: 'topic-name',\n   *                     count: 3,\n   *                     assignments: []\n   *                   }\n   *                 ]\n   * @param {boolean} [validateOnly=false] If this is true, the request will be validated, but the topic\n   *                                       won't be created\n   * @param {number} [timeout=5000] The time in ms to wait for a topic to be completely created\n   *                                on the controller node\n   * @returns {Promise<void>}\n   */\n\n\n  async createPartitions({\n    topicPartitions,\n    validateOnly = false,\n    timeout = 5000\n  }) {\n    const createPartitions = this.lookupRequest(apiKeys.CreatePartitions, requests.CreatePartitions);\n    return await this[PRIVATE.SEND_REQUEST](createPartitions({\n      topicPartitions,\n      validateOnly,\n      timeout\n    }));\n  }\n  /**\n   * @public\n   * @param {Array<string>} topics An array of topics to be deleted\n   * @param {number} [timeout=5000] The time in ms to wait for a topic to be completely deleted on the\n   *                                controller node. Values <= 0 will trigger topic deletion and return\n   *                                immediately\n   * @returns {Promise}\n   */\n\n\n  async deleteTopics({\n    topics,\n    timeout = 5000\n  }) {\n    const deleteTopics = this.lookupRequest(apiKeys.DeleteTopics, requests.DeleteTopics);\n    return await this[PRIVATE.SEND_REQUEST](deleteTopics({\n      topics,\n      timeout\n    }));\n  }\n  /**\n   * @public\n   * @param {Array<ResourceQuery>} resources\n   *                                 [{\n   *                                   type: RESOURCE_TYPES.TOPIC,\n   *                                   name: 'topic-name',\n   *                                   configNames: ['compression.type', 'retention.ms']\n   *                                 }]\n   * @param {boolean} [includeSynonyms=false]\n   * @returns {Promise}\n   */\n\n\n  async describeConfigs({\n    resources,\n    includeSynonyms = false\n  }) {\n    const describeConfigs = this.lookupRequest(apiKeys.DescribeConfigs, requests.DescribeConfigs);\n    return await this[PRIVATE.SEND_REQUEST](describeConfigs({\n      resources,\n      includeSynonyms\n    }));\n  }\n  /**\n   * @public\n   * @param {Array<ResourceConfig>} resources\n   *                                 [{\n   *                                  type: RESOURCE_TYPES.TOPIC,\n   *                                  name: 'topic-name',\n   *                                  configEntries: [\n   *                                    {\n   *                                      name: 'cleanup.policy',\n   *                                      value: 'compact'\n   *                                    }\n   *                                  ]\n   *                                 }]\n   * @param {boolean} [validateOnly=false]\n   * @returns {Promise}\n   */\n\n\n  async alterConfigs({\n    resources,\n    validateOnly = false\n  }) {\n    const alterConfigs = this.lookupRequest(apiKeys.AlterConfigs, requests.AlterConfigs);\n    return await this[PRIVATE.SEND_REQUEST](alterConfigs({\n      resources,\n      validateOnly\n    }));\n  }\n  /**\n   * Send an `InitProducerId` request to fetch a PID and bump the producer epoch.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {number} transactionTimeout The time in ms to wait for before aborting idle transactions\n   * @param {number} [transactionalId] The transactional id or null if the producer is not transactional\n   * @returns {Promise}\n   */\n\n\n  async initProducerId({\n    transactionalId,\n    transactionTimeout\n  }) {\n    const initProducerId = this.lookupRequest(apiKeys.InitProducerId, requests.InitProducerId);\n    return await this[PRIVATE.SEND_REQUEST](initProducerId({\n      transactionalId,\n      transactionTimeout\n    }));\n  }\n  /**\n   * Send an `AddPartitionsToTxn` request to mark a TopicPartition as participating in the transaction.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {string} transactionalId The transactional id corresponding to the transaction.\n   * @param {number} producerId Current producer id in use by the transactional id.\n   * @param {number} producerEpoch Current epoch associated with the producer id.\n   * @param {object[]} topics e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [ 0, 1]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n\n\n  async addPartitionsToTxn({\n    transactionalId,\n    producerId,\n    producerEpoch,\n    topics\n  }) {\n    const addPartitionsToTxn = this.lookupRequest(apiKeys.AddPartitionsToTxn, requests.AddPartitionsToTxn);\n    return await this[PRIVATE.SEND_REQUEST](addPartitionsToTxn({\n      transactionalId,\n      producerId,\n      producerEpoch,\n      topics\n    }));\n  }\n  /**\n   * Send an `AddOffsetsToTxn` request.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {string} transactionalId The transactional id corresponding to the transaction.\n   * @param {number} producerId Current producer id in use by the transactional id.\n   * @param {number} producerEpoch Current epoch associated with the producer id.\n   * @param {string} groupId The unique group identifier (for the consumer group)\n   * @returns {Promise}\n   */\n\n\n  async addOffsetsToTxn({\n    transactionalId,\n    producerId,\n    producerEpoch,\n    groupId\n  }) {\n    const addOffsetsToTxn = this.lookupRequest(apiKeys.AddOffsetsToTxn, requests.AddOffsetsToTxn);\n    return await this[PRIVATE.SEND_REQUEST](addOffsetsToTxn({\n      transactionalId,\n      producerId,\n      producerEpoch,\n      groupId\n    }));\n  }\n  /**\n   * Send a `TxnOffsetCommit` request to persist the offsets in the `__consumer_offsets` topics.\n   *\n   * Request should be made to the consumer coordinator.\n   * @public\n   * @param {OffsetCommitTopic[]} topics\n   * @param {string} transactionalId The transactional id corresponding to the transaction.\n   * @param {string} groupId The unique group identifier (for the consumer group)\n   * @param {number} producerId Current producer id in use by the transactional id.\n   * @param {number} producerEpoch Current epoch associated with the producer id.\n   * @param {OffsetCommitTopic[]} topics\n   *\n   * @typedef {Object} OffsetCommitTopic\n   * @property {string} topic\n   * @property {OffsetCommitTopicPartition[]} partitions\n   *\n   * @typedef {Object} OffsetCommitTopicPartition\n   * @property {number} partition\n   * @property {number} offset\n   * @property {string} [metadata]\n   *\n   * @returns {Promise}\n   */\n\n\n  async txnOffsetCommit({\n    transactionalId,\n    groupId,\n    producerId,\n    producerEpoch,\n    topics\n  }) {\n    const txnOffsetCommit = this.lookupRequest(apiKeys.TxnOffsetCommit, requests.TxnOffsetCommit);\n    return await this[PRIVATE.SEND_REQUEST](txnOffsetCommit({\n      transactionalId,\n      groupId,\n      producerId,\n      producerEpoch,\n      topics\n    }));\n  }\n  /**\n   * Send an `EndTxn` request to indicate transaction should be committed or aborted.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {string} transactionalId The transactional id corresponding to the transaction.\n   * @param {number} producerId Current producer id in use by the transactional id.\n   * @param {number} producerEpoch Current epoch associated with the producer id.\n   * @param {boolean} transactionResult The result of the transaction (false = ABORT, true = COMMIT)\n   * @returns {Promise}\n   */\n\n\n  async endTxn({\n    transactionalId,\n    producerId,\n    producerEpoch,\n    transactionResult\n  }) {\n    const endTxn = this.lookupRequest(apiKeys.EndTxn, requests.EndTxn);\n    return await this[PRIVATE.SEND_REQUEST](endTxn({\n      transactionalId,\n      producerId,\n      producerEpoch,\n      transactionResult\n    }));\n  }\n  /**\n   * Send request for list of groups\n   * @public\n   * @returns {Promise}\n   */\n\n\n  async listGroups() {\n    const listGroups = this.lookupRequest(apiKeys.ListGroups, requests.ListGroups);\n    return await this[PRIVATE.SEND_REQUEST](listGroups());\n  }\n  /**\n   * Send request to delete groups\n   * @param {Array<string>} groupIds\n   * @public\n   * @returns {Promise}\n   */\n\n\n  async deleteGroups(groupIds) {\n    const deleteGroups = this.lookupRequest(apiKeys.DeleteGroups, requests.DeleteGroups);\n    return await this[PRIVATE.SEND_REQUEST](deleteGroups(groupIds));\n  }\n  /**\n   * Send request to delete records\n   * @public\n   * @param {Array<Object>} topics\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [\n   *                                { partition: 0, offset 2 },\n   *                                { partition: 1, offset 4 },\n   *                              ],\n   *                            }\n   *                          ]\n   * @returns {Promise<Array>} example:\n   *                          {\n   *                            throttleTime: 0\n   *                           [\n   *                              {\n   *                                topic: 'my-topic-name',\n   *                                partitions: [\n   *                                 { partition: 0, lowWatermark: '2n', errorCode: 0 },\n   *                                 { partition: 1, lowWatermark: '4n', errorCode: 0 },\n   *                               ],\n   *                             },\n   *                           ]\n   *                          }\n   */\n\n\n  async deleteRecords({\n    topics\n  }) {\n    const deleteRecords = this.lookupRequest(apiKeys.DeleteRecords, requests.DeleteRecords);\n    return await this[PRIVATE.SEND_REQUEST](deleteRecords({\n      topics\n    }));\n  }\n  /**\n   * @public\n   * @param {Array} ACL e.g:\n   *                 [\n   *                   {\n   *                     resourceType: AclResourceTypes.TOPIC,\n   *                     resourceName: 'topic-name',\n   *                     resourcePatternType: ResourcePatternTypes.LITERAL,\n   *                     principal: 'User:bob',\n   *                     host: '*',\n   *                     operation: AclOperationTypes.ALL,\n   *                     permissionType: AclPermissionTypes.DENY,\n   *                   }\n   *                 ]\n   * @returns {Promise<void>}\n   */\n\n\n  async createAcls({\n    acl\n  }) {\n    const createAcls = this.lookupRequest(apiKeys.CreateAcls, requests.CreateAcls);\n    return await this[PRIVATE.SEND_REQUEST](createAcls({\n      creations: acl\n    }));\n  }\n  /**\n   * @public\n   * @param {number} resourceType The type of resource\n   * @param {string} resourceName The name of the resource\n   * @param {number} resourcePatternType The resource pattern type filter\n   * @param {string} principal The principal name\n   * @param {string} host The hostname\n   * @param {number} operation The type of operation\n   * @param {number} permissionType The type of permission\n   * @returns {Promise<void>}\n   */\n\n\n  async describeAcls({\n    resourceType,\n    resourceName,\n    resourcePatternType,\n    principal,\n    host,\n    operation,\n    permissionType\n  }) {\n    const describeAcls = this.lookupRequest(apiKeys.DescribeAcls, requests.DescribeAcls);\n    return await this[PRIVATE.SEND_REQUEST](describeAcls({\n      resourceType,\n      resourceName,\n      resourcePatternType,\n      principal,\n      host,\n      operation,\n      permissionType\n    }));\n  }\n  /**\n   * @public\n   * @param {number} resourceType The type of resource\n   * @param {string} resourceName The name of the resource\n   * @param {number} resourcePatternType The resource pattern type filter\n   * @param {string} principal The principal name\n   * @param {string} host The hostname\n   * @param {number} operation The type of operation\n   * @param {number} permissionType The type of permission\n   * @returns {Promise<void>}\n   */\n\n\n  async deleteAcls({\n    filters\n  }) {\n    const deleteAcls = this.lookupRequest(apiKeys.DeleteAcls, requests.DeleteAcls);\n    return await this[PRIVATE.SEND_REQUEST](deleteAcls({\n      filters\n    }));\n  }\n  /***\n   * @private\n   */\n\n\n  [PRIVATE.SHOULD_REAUTHENTICATE]() {\n    if (this.sessionLifetime.equals(Long.ZERO)) {\n      return false;\n    }\n\n    if (this.authenticatedAt == null) {\n      return true;\n    }\n\n    const [secondsSince, remainingNanosSince] = process.hrtime(this.authenticatedAt);\n    const millisSince = Long.fromValue(secondsSince).multiply(1000).add(Long.fromValue(remainingNanosSince).divide(1000000));\n    const reauthenticateAt = millisSince.add(this.reauthenticationThreshold);\n    return reauthenticateAt.greaterThanOrEqual(this.sessionLifetime);\n  }\n  /**\n   * @private\n   */\n\n\n  async [PRIVATE.SEND_REQUEST](protocolRequest) {\n    try {\n      return await this.connection.send(protocolRequest);\n    } catch (e) {\n      if (e.name === 'KafkaJSConnectionClosedError') {\n        await this.disconnect();\n      }\n\n      throw e;\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/broker/index.js"],"names":["Long","require","Lock","Types","Compression","requests","lookup","KafkaJSNonRetriableError","apiKeys","SASLAuthenticator","shuffle","PRIVATE","SHOULD_REAUTHENTICATE","Symbol","SEND_REQUEST","module","exports","Broker","constructor","connection","logger","nodeId","versions","authenticationTimeout","reauthenticationThreshold","allowAutoTopicCreation","supportAuthenticationProtocol","rootLogger","namespace","authenticatedAt","sessionLifetime","ZERO","lockTimeout","connectionTimeout","brokerAddress","host","port","lock","timeout","description","lookupRequest","Error","isConnected","connected","sasl","isAuthenticated","connect","acquire","apiVersions","SaslAuthenticate","_","debug","broker","authenticator","authenticate","process","hrtime","fromValue","release","disconnect","response","availableVersions","ApiVersions","map","Number","sort","reverse","candidateVersion","protocol","version","requestTimeout","e","type","reduce","obj","Object","assign","apiKey","minVersion","maxVersion","metadata","topics","Metadata","shuffledTopics","produce","topicData","transactionalId","producerId","producerEpoch","acks","compression","None","Produce","fetch","replicaId","isolationLevel","maxWaitTime","minBytes","maxBytes","rackId","Fetch","flattenedTopicPartitions","topicPartitions","topic","partitions","forEach","partition","push","shuffledTopicPartitions","consolidatedTopicPartitions","last","length","heartbeat","groupId","groupGenerationId","memberId","Heartbeat","findGroupCoordinator","coordinatorType","findCoordinator","GroupCoordinator","joinGroup","sessionTimeout","rebalanceTimeout","protocolType","groupProtocols","JoinGroup","makeRequest","assignedMemberId","error","name","leaveGroup","LeaveGroup","syncGroup","generationId","groupAssignment","SyncGroup","listOffsets","ListOffsets","result","responses","offsets","partitionData","offset","pop","offsetCommit","retentionTime","OffsetCommit","offsetFetch","OffsetFetch","describeGroups","groupIds","DescribeGroups","createTopics","validateOnly","CreateTopics","createPartitions","CreatePartitions","deleteTopics","DeleteTopics","describeConfigs","resources","includeSynonyms","DescribeConfigs","alterConfigs","AlterConfigs","initProducerId","transactionTimeout","InitProducerId","addPartitionsToTxn","AddPartitionsToTxn","addOffsetsToTxn","AddOffsetsToTxn","txnOffsetCommit","TxnOffsetCommit","endTxn","transactionResult","EndTxn","listGroups","ListGroups","deleteGroups","DeleteGroups","deleteRecords","DeleteRecords","createAcls","acl","CreateAcls","creations","describeAcls","resourceType","resourceName","resourcePatternType","principal","operation","permissionType","DescribeAcls","deleteAcls","filters","DeleteAcls","equals","secondsSince","remainingNanosSince","millisSince","multiply","add","divide","reauthenticateAt","greaterThanOrEqual","protocolRequest","send"],"mappings":"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","sourcesContent":["const Long = require('../utils/long')\nconst Lock = require('../utils/lock')\nconst { Types: Compression } = require('../protocol/message/compression')\nconst { requests, lookup } = require('../protocol/requests')\nconst { KafkaJSNonRetriableError } = require('../errors')\nconst apiKeys = require('../protocol/requests/apiKeys')\nconst SASLAuthenticator = require('./saslAuthenticator')\nconst shuffle = require('../utils/shuffle')\n\nconst PRIVATE = {\n  SHOULD_REAUTHENTICATE: Symbol('private:Broker:shouldReauthenticate'),\n  SEND_REQUEST: Symbol('private:Broker:sendRequest'),\n}\n\n/**\n * Each node in a Kafka cluster is called broker. This class contains\n * the high-level operations a node can perform.\n *\n * @type {import(\"../../types\").Broker}\n * @param {Connection} connection\n * @param {Object} logger\n * @param {Object} [versions=null] The object with all available versions and APIs\n *                                 supported by this cluster. The output of broker#apiVersions\n * @param {number} [authenticationTimeout=1000]\n * @param {boolean} [allowAutoTopicCreation=true] If this and the broker config 'auto.create.topics.enable'\n *                                                are true, topics that don't exist will be created when\n *                                                fetching metadata.\n * @param {boolean} [supportAuthenticationProtocol=null] If the server supports the SASLAuthenticate protocol\n */\nmodule.exports = class Broker {\n  constructor({\n    connection,\n    logger,\n    nodeId = null,\n    versions = null,\n    authenticationTimeout = 1000,\n    reauthenticationThreshold = 10000,\n    allowAutoTopicCreation = true,\n    supportAuthenticationProtocol = null,\n  }) {\n    this.connection = connection\n    this.nodeId = nodeId\n    this.rootLogger = logger\n    this.logger = logger.namespace('Broker')\n    this.versions = versions\n    this.authenticationTimeout = authenticationTimeout\n    this.reauthenticationThreshold = reauthenticationThreshold\n    this.allowAutoTopicCreation = allowAutoTopicCreation\n    this.supportAuthenticationProtocol = supportAuthenticationProtocol\n\n    this.authenticatedAt = null\n    this.sessionLifetime = Long.ZERO\n\n    // The lock timeout has twice the connectionTimeout because the same timeout is used\n    // for the first apiVersions call\n    const lockTimeout = 2 * this.connection.connectionTimeout + this.authenticationTimeout\n    this.brokerAddress = `${this.connection.host}:${this.connection.port}`\n\n    this.lock = new Lock({\n      timeout: lockTimeout,\n      description: `connect to broker ${this.brokerAddress}`,\n    })\n\n    this.lookupRequest = () => {\n      throw new Error('Broker not connected')\n    }\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isConnected() {\n    const { connected, sasl } = this.connection\n    const isAuthenticated = this.authenticatedAt != null && !this[PRIVATE.SHOULD_REAUTHENTICATE]()\n    return sasl ? connected && isAuthenticated : connected\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  async connect() {\n    try {\n      await this.lock.acquire()\n      if (this.isConnected()) {\n        return\n      }\n\n      this.authenticatedAt = null\n      await this.connection.connect()\n\n      if (!this.versions) {\n        this.versions = await this.apiVersions()\n      }\n\n      this.lookupRequest = lookup(this.versions)\n\n      if (this.supportAuthenticationProtocol === null) {\n        try {\n          this.lookupRequest(apiKeys.SaslAuthenticate, requests.SaslAuthenticate)\n          this.supportAuthenticationProtocol = true\n        } catch (_) {\n          this.supportAuthenticationProtocol = false\n        }\n\n        this.logger.debug(`Verified support for SaslAuthenticate`, {\n          broker: this.brokerAddress,\n          supportAuthenticationProtocol: this.supportAuthenticationProtocol,\n        })\n      }\n\n      if (this.authenticatedAt == null && this.connection.sasl) {\n        const authenticator = new SASLAuthenticator(\n          this.connection,\n          this.rootLogger,\n          this.versions,\n          this.supportAuthenticationProtocol\n        )\n\n        await authenticator.authenticate()\n        this.authenticatedAt = process.hrtime()\n        this.sessionLifetime = Long.fromValue(authenticator.sessionLifetime)\n      }\n    } finally {\n      await this.lock.release()\n    }\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  async disconnect() {\n    this.authenticatedAt = null\n    await this.connection.disconnect()\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  async apiVersions() {\n    let response\n    const availableVersions = requests.ApiVersions.versions\n      .map(Number)\n      .sort()\n      .reverse()\n\n    // Find the best version implemented by the server\n    for (const candidateVersion of availableVersions) {\n      try {\n        const apiVersions = requests.ApiVersions.protocol({ version: candidateVersion })\n        response = await this[PRIVATE.SEND_REQUEST]({\n          ...apiVersions(),\n          requestTimeout: this.connection.connectionTimeout,\n        })\n        break\n      } catch (e) {\n        if (e.type !== 'UNSUPPORTED_VERSION') {\n          throw e\n        }\n      }\n    }\n\n    if (!response) {\n      throw new KafkaJSNonRetriableError('API Versions not supported')\n    }\n\n    return response.apiVersions.reduce(\n      (obj, version) =>\n        Object.assign(obj, {\n          [version.apiKey]: {\n            minVersion: version.minVersion,\n            maxVersion: version.maxVersion,\n          },\n        }),\n      {}\n    )\n  }\n\n  /**\n   * @public\n   * @type {import(\"../../types\").Broker['metadata']}\n   * @param {Array} [topics=[]] An array of topics to fetch metadata for.\n   *                            If no topics are specified fetch metadata for all topics\n   */\n  async metadata(topics = []) {\n    const metadata = this.lookupRequest(apiKeys.Metadata, requests.Metadata)\n    const shuffledTopics = shuffle(topics)\n    return await this[PRIVATE.SEND_REQUEST](\n      metadata({ topics: shuffledTopics, allowAutoTopicCreation: this.allowAutoTopicCreation })\n    )\n  }\n\n  /**\n   * @public\n   * @param {Array} topicData An array of messages per topic and per partition, example:\n   *                          [\n   *                            {\n   *                              topic: 'test-topic-1',\n   *                              partitions: [\n   *                                {\n   *                                  partition: 0,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '1', value: 'A' },\n   *                                    { key: '2', value: 'B' },\n   *                                  ]\n   *                                },\n   *                                {\n   *                                  partition: 1,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '3', value: 'C' },\n   *                                  ]\n   *                                }\n   *                              ]\n   *                            },\n   *                            {\n   *                              topic: 'test-topic-2',\n   *                              partitions: [\n   *                                {\n   *                                  partition: 4,\n   *                                  firstSequence: 0,\n   *                                  messages: [\n   *                                    { key: '32', value: 'E' },\n   *                                  ]\n   *                                },\n   *                              ]\n   *                            },\n   *                          ]\n   * @param {number} [acks=-1] Control the number of required acks.\n   *                           -1 = all replicas must acknowledge\n   *                            0 = no acknowledgments\n   *                            1 = only waits for the leader to acknowledge\n   * @param {number} [timeout=30000] The time to await a response in ms\n   * @param {string} [transactionalId=null]\n   * @param {number} [producerId=-1] Broker assigned producerId\n   * @param {number} [producerEpoch=0] Broker assigned producerEpoch\n   * @param {Compression.Types} [compression=Compression.Types.None] Compression codec\n   * @returns {Promise}\n   */\n  async produce({\n    topicData,\n    transactionalId,\n    producerId,\n    producerEpoch,\n    acks = -1,\n    timeout = 30000,\n    compression = Compression.None,\n  }) {\n    const produce = this.lookupRequest(apiKeys.Produce, requests.Produce)\n    return await this[PRIVATE.SEND_REQUEST](\n      produce({\n        acks,\n        timeout,\n        compression,\n        topicData,\n        transactionalId,\n        producerId,\n        producerEpoch,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {number} replicaId=-1 Broker id of the follower. For normal consumers, use -1\n   * @param {number} isolationLevel=1 This setting controls the visibility of transactional records. Default READ_COMMITTED.\n   * @param {number} maxWaitTime=5000 Maximum time in ms to wait for the response\n   * @param {number} minBytes=1 Minimum bytes to accumulate in the response\n   * @param {number} maxBytes=10485760 Maximum bytes to accumulate in the response. Note that this is\n   *                                   not an absolute maximum, if the first message in the first non-empty\n   *                                   partition of the fetch is larger than this value, the message will still\n   *                                   be returned to ensure that progress can be made. Default 10MB.\n   * @param {Array} topics Topics to fetch\n   *                        [\n   *                          {\n   *                            topic: 'topic-name',\n   *                            partitions: [\n   *                              {\n   *                                partition: 0,\n   *                                fetchOffset: '4124',\n   *                                maxBytes: 2048\n   *                              }\n   *                            ]\n   *                          }\n   *                        ]\n   * @param {string} rackId='' A rack identifier for this client. This can be any string value which indicates where this\n   *                           client is physically located. It corresponds with the broker config `broker.rack`.\n   * @returns {Promise}\n   */\n  async fetch({\n    replicaId,\n    isolationLevel,\n    maxWaitTime = 5000,\n    minBytes = 1,\n    maxBytes = 10485760,\n    topics,\n    rackId = '',\n  }) {\n    // TODO: validate topics not null/empty\n    const fetch = this.lookupRequest(apiKeys.Fetch, requests.Fetch)\n\n    // Shuffle topic-partitions to ensure fair response allocation across partitions (KIP-74)\n    const flattenedTopicPartitions = topics.reduce((topicPartitions, { topic, partitions }) => {\n      partitions.forEach(partition => {\n        topicPartitions.push({ topic, partition })\n      })\n      return topicPartitions\n    }, [])\n\n    const shuffledTopicPartitions = shuffle(flattenedTopicPartitions)\n\n    // Consecutive partitions for the same topic can be combined into a single `topic` entry\n    const consolidatedTopicPartitions = shuffledTopicPartitions.reduce(\n      (topicPartitions, { topic, partition }) => {\n        const last = topicPartitions[topicPartitions.length - 1]\n\n        if (last != null && last.topic === topic) {\n          topicPartitions[topicPartitions.length - 1].partitions.push(partition)\n        } else {\n          topicPartitions.push({ topic, partitions: [partition] })\n        }\n\n        return topicPartitions\n      },\n      []\n    )\n\n    return await this[PRIVATE.SEND_REQUEST](\n      fetch({\n        replicaId,\n        isolationLevel,\n        maxWaitTime,\n        minBytes,\n        maxBytes,\n        topics: consolidatedTopicPartitions,\n        rackId,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {string} groupId The group id\n   * @param {number} groupGenerationId The generation of the group\n   * @param {string} memberId The member id assigned by the group coordinator\n   * @returns {Promise}\n   */\n  async heartbeat({ groupId, groupGenerationId, memberId }) {\n    const heartbeat = this.lookupRequest(apiKeys.Heartbeat, requests.Heartbeat)\n    return await this[PRIVATE.SEND_REQUEST](heartbeat({ groupId, groupGenerationId, memberId }))\n  }\n\n  /**\n   * @public\n   * @param {string} groupId The unique group id\n   * @param {CoordinatorType} coordinatorType The type of coordinator to find\n   * @returns {Promise}\n   */\n  async findGroupCoordinator({ groupId, coordinatorType }) {\n    // TODO: validate groupId, mandatory\n    const findCoordinator = this.lookupRequest(apiKeys.GroupCoordinator, requests.GroupCoordinator)\n    return await this[PRIVATE.SEND_REQUEST](findCoordinator({ groupId, coordinatorType }))\n  }\n\n  /**\n   * @public\n   * @param {string} groupId The unique group id\n   * @param {number} sessionTimeout The coordinator considers the consumer dead if it receives\n   *                                no heartbeat after this timeout in ms\n   * @param {number} rebalanceTimeout The maximum time that the coordinator will wait for each member\n   *                                  to rejoin when rebalancing the group\n   * @param {string} [memberId=\"\"] The assigned consumer id or an empty string for a new consumer\n   * @param {string} [protocolType=\"consumer\"] Unique name for class of protocols implemented by group\n   * @param {Array} groupProtocols List of protocols that the member supports (assignment strategy)\n   *                                [{ name: 'AssignerName', metadata: '{\"version\": 1, \"topics\": []}' }]\n   * @returns {Promise}\n   */\n  async joinGroup({\n    groupId,\n    sessionTimeout,\n    rebalanceTimeout,\n    memberId = '',\n    protocolType = 'consumer',\n    groupProtocols,\n  }) {\n    const joinGroup = this.lookupRequest(apiKeys.JoinGroup, requests.JoinGroup)\n    const makeRequest = (assignedMemberId = memberId) =>\n      this[PRIVATE.SEND_REQUEST](\n        joinGroup({\n          groupId,\n          sessionTimeout,\n          rebalanceTimeout,\n          memberId: assignedMemberId,\n          protocolType,\n          groupProtocols,\n        })\n      )\n\n    try {\n      return await makeRequest()\n    } catch (error) {\n      if (error.name === 'KafkaJSMemberIdRequired') {\n        return makeRequest(error.memberId)\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {string} memberId\n   * @returns {Promise}\n   */\n  async leaveGroup({ groupId, memberId }) {\n    const leaveGroup = this.lookupRequest(apiKeys.LeaveGroup, requests.LeaveGroup)\n    return await this[PRIVATE.SEND_REQUEST](leaveGroup({ groupId, memberId }))\n  }\n\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {number} generationId\n   * @param {string} memberId\n   * @param {object} groupAssignment\n   * @returns {Promise}\n   */\n  async syncGroup({ groupId, generationId, memberId, groupAssignment }) {\n    const syncGroup = this.lookupRequest(apiKeys.SyncGroup, requests.SyncGroup)\n    return await this[PRIVATE.SEND_REQUEST](\n      syncGroup({\n        groupId,\n        generationId,\n        memberId,\n        groupAssignment,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {number} replicaId=-1 Broker id of the follower. For normal consumers, use -1\n   * @param {number} isolationLevel=1 This setting controls the visibility of transactional records (default READ_COMMITTED, Kafka >0.11 only)\n   * @param {TopicPartitionOffset[]} topics e.g:\n   *\n   * @typedef {Object} TopicPartitionOffset\n   * @property {string} topic\n   * @property {PartitionOffset[]} partitions\n   *\n   * @typedef {Object} PartitionOffset\n   * @property {number} partition\n   * @property {number} [timestamp=-1]\n   *\n   *\n   * @returns {Promise}\n   */\n  async listOffsets({ replicaId, isolationLevel, topics }) {\n    const listOffsets = this.lookupRequest(apiKeys.ListOffsets, requests.ListOffsets)\n    const result = await this[PRIVATE.SEND_REQUEST](\n      listOffsets({ replicaId, isolationLevel, topics })\n    )\n\n    // ListOffsets >= v1 will return a single `offset` rather than an array of `offsets` (ListOffsets V0).\n    // Normalize to just return `offset`.\n    for (const response of result.responses) {\n      response.partitions = response.partitions.map(({ offsets, ...partitionData }) => {\n        return offsets ? { ...partitionData, offset: offsets.pop() } : partitionData\n      })\n    }\n\n    return result\n  }\n\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {number} groupGenerationId\n   * @param {string} memberId\n   * @param {number} [retentionTime=-1] -1 signals to the broker that its default configuration\n   *                                    should be used.\n   * @param {object} topics Topics to commit offsets, e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [\n   *                        { partition: 0, offset: '11' }\n   *                      ]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n  async offsetCommit({ groupId, groupGenerationId, memberId, retentionTime, topics }) {\n    const offsetCommit = this.lookupRequest(apiKeys.OffsetCommit, requests.OffsetCommit)\n    return await this[PRIVATE.SEND_REQUEST](\n      offsetCommit({\n        groupId,\n        groupGenerationId,\n        memberId,\n        retentionTime,\n        topics,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {object} topics - If the topic array is null fetch offsets for all topics. e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [\n   *                        { partition: 0 }\n   *                      ]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n  async offsetFetch({ groupId, topics }) {\n    const offsetFetch = this.lookupRequest(apiKeys.OffsetFetch, requests.OffsetFetch)\n    return await this[PRIVATE.SEND_REQUEST](offsetFetch({ groupId, topics }))\n  }\n\n  /**\n   * @public\n   * @param {Array} groupIds\n   * @returns {Promise}\n   */\n  async describeGroups({ groupIds }) {\n    const describeGroups = this.lookupRequest(apiKeys.DescribeGroups, requests.DescribeGroups)\n    return await this[PRIVATE.SEND_REQUEST](describeGroups({ groupIds }))\n  }\n\n  /**\n   * @public\n   * @param {Array} topics e.g:\n   *                 [\n   *                   {\n   *                     topic: 'topic-name',\n   *                     numPartitions: 1,\n   *                     replicationFactor: 1\n   *                   }\n   *                 ]\n   * @param {boolean} [validateOnly=false] If this is true, the request will be validated, but the topic\n   *                                       won't be created\n   * @param {number} [timeout=5000] The time in ms to wait for a topic to be completely created\n   *                                on the controller node\n   * @returns {Promise}\n   */\n  async createTopics({ topics, validateOnly = false, timeout = 5000 }) {\n    const createTopics = this.lookupRequest(apiKeys.CreateTopics, requests.CreateTopics)\n    return await this[PRIVATE.SEND_REQUEST](createTopics({ topics, validateOnly, timeout }))\n  }\n\n  /**\n   * @public\n   * @param {Array} topicPartitions e.g:\n   *                 [\n   *                   {\n   *                     topic: 'topic-name',\n   *                     count: 3,\n   *                     assignments: []\n   *                   }\n   *                 ]\n   * @param {boolean} [validateOnly=false] If this is true, the request will be validated, but the topic\n   *                                       won't be created\n   * @param {number} [timeout=5000] The time in ms to wait for a topic to be completely created\n   *                                on the controller node\n   * @returns {Promise<void>}\n   */\n  async createPartitions({ topicPartitions, validateOnly = false, timeout = 5000 }) {\n    const createPartitions = this.lookupRequest(apiKeys.CreatePartitions, requests.CreatePartitions)\n    return await this[PRIVATE.SEND_REQUEST](\n      createPartitions({ topicPartitions, validateOnly, timeout })\n    )\n  }\n\n  /**\n   * @public\n   * @param {Array<string>} topics An array of topics to be deleted\n   * @param {number} [timeout=5000] The time in ms to wait for a topic to be completely deleted on the\n   *                                controller node. Values <= 0 will trigger topic deletion and return\n   *                                immediately\n   * @returns {Promise}\n   */\n  async deleteTopics({ topics, timeout = 5000 }) {\n    const deleteTopics = this.lookupRequest(apiKeys.DeleteTopics, requests.DeleteTopics)\n    return await this[PRIVATE.SEND_REQUEST](deleteTopics({ topics, timeout }))\n  }\n\n  /**\n   * @public\n   * @param {Array<ResourceQuery>} resources\n   *                                 [{\n   *                                   type: RESOURCE_TYPES.TOPIC,\n   *                                   name: 'topic-name',\n   *                                   configNames: ['compression.type', 'retention.ms']\n   *                                 }]\n   * @param {boolean} [includeSynonyms=false]\n   * @returns {Promise}\n   */\n  async describeConfigs({ resources, includeSynonyms = false }) {\n    const describeConfigs = this.lookupRequest(apiKeys.DescribeConfigs, requests.DescribeConfigs)\n    return await this[PRIVATE.SEND_REQUEST](describeConfigs({ resources, includeSynonyms }))\n  }\n\n  /**\n   * @public\n   * @param {Array<ResourceConfig>} resources\n   *                                 [{\n   *                                  type: RESOURCE_TYPES.TOPIC,\n   *                                  name: 'topic-name',\n   *                                  configEntries: [\n   *                                    {\n   *                                      name: 'cleanup.policy',\n   *                                      value: 'compact'\n   *                                    }\n   *                                  ]\n   *                                 }]\n   * @param {boolean} [validateOnly=false]\n   * @returns {Promise}\n   */\n  async alterConfigs({ resources, validateOnly = false }) {\n    const alterConfigs = this.lookupRequest(apiKeys.AlterConfigs, requests.AlterConfigs)\n    return await this[PRIVATE.SEND_REQUEST](alterConfigs({ resources, validateOnly }))\n  }\n\n  /**\n   * Send an `InitProducerId` request to fetch a PID and bump the producer epoch.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {number} transactionTimeout The time in ms to wait for before aborting idle transactions\n   * @param {number} [transactionalId] The transactional id or null if the producer is not transactional\n   * @returns {Promise}\n   */\n  async initProducerId({ transactionalId, transactionTimeout }) {\n    const initProducerId = this.lookupRequest(apiKeys.InitProducerId, requests.InitProducerId)\n    return await this[PRIVATE.SEND_REQUEST](initProducerId({ transactionalId, transactionTimeout }))\n  }\n\n  /**\n   * Send an `AddPartitionsToTxn` request to mark a TopicPartition as participating in the transaction.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {string} transactionalId The transactional id corresponding to the transaction.\n   * @param {number} producerId Current producer id in use by the transactional id.\n   * @param {number} producerEpoch Current epoch associated with the producer id.\n   * @param {object[]} topics e.g:\n   *                  [\n   *                    {\n   *                      topic: 'topic-name',\n   *                      partitions: [ 0, 1]\n   *                    }\n   *                  ]\n   * @returns {Promise}\n   */\n  async addPartitionsToTxn({ transactionalId, producerId, producerEpoch, topics }) {\n    const addPartitionsToTxn = this.lookupRequest(\n      apiKeys.AddPartitionsToTxn,\n      requests.AddPartitionsToTxn\n    )\n    return await this[PRIVATE.SEND_REQUEST](\n      addPartitionsToTxn({ transactionalId, producerId, producerEpoch, topics })\n    )\n  }\n\n  /**\n   * Send an `AddOffsetsToTxn` request.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {string} transactionalId The transactional id corresponding to the transaction.\n   * @param {number} producerId Current producer id in use by the transactional id.\n   * @param {number} producerEpoch Current epoch associated with the producer id.\n   * @param {string} groupId The unique group identifier (for the consumer group)\n   * @returns {Promise}\n   */\n  async addOffsetsToTxn({ transactionalId, producerId, producerEpoch, groupId }) {\n    const addOffsetsToTxn = this.lookupRequest(apiKeys.AddOffsetsToTxn, requests.AddOffsetsToTxn)\n    return await this[PRIVATE.SEND_REQUEST](\n      addOffsetsToTxn({ transactionalId, producerId, producerEpoch, groupId })\n    )\n  }\n\n  /**\n   * Send a `TxnOffsetCommit` request to persist the offsets in the `__consumer_offsets` topics.\n   *\n   * Request should be made to the consumer coordinator.\n   * @public\n   * @param {OffsetCommitTopic[]} topics\n   * @param {string} transactionalId The transactional id corresponding to the transaction.\n   * @param {string} groupId The unique group identifier (for the consumer group)\n   * @param {number} producerId Current producer id in use by the transactional id.\n   * @param {number} producerEpoch Current epoch associated with the producer id.\n   * @param {OffsetCommitTopic[]} topics\n   *\n   * @typedef {Object} OffsetCommitTopic\n   * @property {string} topic\n   * @property {OffsetCommitTopicPartition[]} partitions\n   *\n   * @typedef {Object} OffsetCommitTopicPartition\n   * @property {number} partition\n   * @property {number} offset\n   * @property {string} [metadata]\n   *\n   * @returns {Promise}\n   */\n  async txnOffsetCommit({ transactionalId, groupId, producerId, producerEpoch, topics }) {\n    const txnOffsetCommit = this.lookupRequest(apiKeys.TxnOffsetCommit, requests.TxnOffsetCommit)\n    return await this[PRIVATE.SEND_REQUEST](\n      txnOffsetCommit({ transactionalId, groupId, producerId, producerEpoch, topics })\n    )\n  }\n\n  /**\n   * Send an `EndTxn` request to indicate transaction should be committed or aborted.\n   *\n   * Request should be made to the transaction coordinator.\n   * @public\n   * @param {string} transactionalId The transactional id corresponding to the transaction.\n   * @param {number} producerId Current producer id in use by the transactional id.\n   * @param {number} producerEpoch Current epoch associated with the producer id.\n   * @param {boolean} transactionResult The result of the transaction (false = ABORT, true = COMMIT)\n   * @returns {Promise}\n   */\n  async endTxn({ transactionalId, producerId, producerEpoch, transactionResult }) {\n    const endTxn = this.lookupRequest(apiKeys.EndTxn, requests.EndTxn)\n    return await this[PRIVATE.SEND_REQUEST](\n      endTxn({ transactionalId, producerId, producerEpoch, transactionResult })\n    )\n  }\n\n  /**\n   * Send request for list of groups\n   * @public\n   * @returns {Promise}\n   */\n  async listGroups() {\n    const listGroups = this.lookupRequest(apiKeys.ListGroups, requests.ListGroups)\n    return await this[PRIVATE.SEND_REQUEST](listGroups())\n  }\n\n  /**\n   * Send request to delete groups\n   * @param {Array<string>} groupIds\n   * @public\n   * @returns {Promise}\n   */\n  async deleteGroups(groupIds) {\n    const deleteGroups = this.lookupRequest(apiKeys.DeleteGroups, requests.DeleteGroups)\n    return await this[PRIVATE.SEND_REQUEST](deleteGroups(groupIds))\n  }\n\n  /**\n   * Send request to delete records\n   * @public\n   * @param {Array<Object>} topics\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [\n   *                                { partition: 0, offset 2 },\n   *                                { partition: 1, offset 4 },\n   *                              ],\n   *                            }\n   *                          ]\n   * @returns {Promise<Array>} example:\n   *                          {\n   *                            throttleTime: 0\n   *                           [\n   *                              {\n   *                                topic: 'my-topic-name',\n   *                                partitions: [\n   *                                 { partition: 0, lowWatermark: '2n', errorCode: 0 },\n   *                                 { partition: 1, lowWatermark: '4n', errorCode: 0 },\n   *                               ],\n   *                             },\n   *                           ]\n   *                          }\n   */\n  async deleteRecords({ topics }) {\n    const deleteRecords = this.lookupRequest(apiKeys.DeleteRecords, requests.DeleteRecords)\n    return await this[PRIVATE.SEND_REQUEST](deleteRecords({ topics }))\n  }\n\n  /**\n   * @public\n   * @param {Array} ACL e.g:\n   *                 [\n   *                   {\n   *                     resourceType: AclResourceTypes.TOPIC,\n   *                     resourceName: 'topic-name',\n   *                     resourcePatternType: ResourcePatternTypes.LITERAL,\n   *                     principal: 'User:bob',\n   *                     host: '*',\n   *                     operation: AclOperationTypes.ALL,\n   *                     permissionType: AclPermissionTypes.DENY,\n   *                   }\n   *                 ]\n   * @returns {Promise<void>}\n   */\n  async createAcls({ acl }) {\n    const createAcls = this.lookupRequest(apiKeys.CreateAcls, requests.CreateAcls)\n    return await this[PRIVATE.SEND_REQUEST](createAcls({ creations: acl }))\n  }\n\n  /**\n   * @public\n   * @param {number} resourceType The type of resource\n   * @param {string} resourceName The name of the resource\n   * @param {number} resourcePatternType The resource pattern type filter\n   * @param {string} principal The principal name\n   * @param {string} host The hostname\n   * @param {number} operation The type of operation\n   * @param {number} permissionType The type of permission\n   * @returns {Promise<void>}\n   */\n  async describeAcls({\n    resourceType,\n    resourceName,\n    resourcePatternType,\n    principal,\n    host,\n    operation,\n    permissionType,\n  }) {\n    const describeAcls = this.lookupRequest(apiKeys.DescribeAcls, requests.DescribeAcls)\n    return await this[PRIVATE.SEND_REQUEST](\n      describeAcls({\n        resourceType,\n        resourceName,\n        resourcePatternType,\n        principal,\n        host,\n        operation,\n        permissionType,\n      })\n    )\n  }\n\n  /**\n   * @public\n   * @param {number} resourceType The type of resource\n   * @param {string} resourceName The name of the resource\n   * @param {number} resourcePatternType The resource pattern type filter\n   * @param {string} principal The principal name\n   * @param {string} host The hostname\n   * @param {number} operation The type of operation\n   * @param {number} permissionType The type of permission\n   * @returns {Promise<void>}\n   */\n  async deleteAcls({ filters }) {\n    const deleteAcls = this.lookupRequest(apiKeys.DeleteAcls, requests.DeleteAcls)\n    return await this[PRIVATE.SEND_REQUEST](deleteAcls({ filters }))\n  }\n\n  /***\n   * @private\n   */\n  [PRIVATE.SHOULD_REAUTHENTICATE]() {\n    if (this.sessionLifetime.equals(Long.ZERO)) {\n      return false\n    }\n\n    if (this.authenticatedAt == null) {\n      return true\n    }\n\n    const [secondsSince, remainingNanosSince] = process.hrtime(this.authenticatedAt)\n    const millisSince = Long.fromValue(secondsSince)\n      .multiply(1000)\n      .add(Long.fromValue(remainingNanosSince).divide(1000000))\n\n    const reauthenticateAt = millisSince.add(this.reauthenticationThreshold)\n    return reauthenticateAt.greaterThanOrEqual(this.sessionLifetime)\n  }\n\n  /**\n   * @private\n   */\n  async [PRIVATE.SEND_REQUEST](protocolRequest) {\n    try {\n      return await this.connection.send(protocolRequest)\n    } catch (e) {\n      if (e.name === 'KafkaJSConnectionClosedError') {\n        await this.disconnect()\n      }\n\n      throw e\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}