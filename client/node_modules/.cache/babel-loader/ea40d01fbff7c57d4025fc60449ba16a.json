{"ast":null,"code":"const Encoder = require('../../../encoder');\n\nconst Header = require('../../header/v0');\n/**\n * v0\n * Record =>\n *   Length => Varint\n *   Attributes => Int8\n *   TimestampDelta => Varlong\n *   OffsetDelta => Varint\n *   Key => varInt|Bytes\n *   Value => varInt|Bytes\n *   Headers => [HeaderKey HeaderValue]\n *     HeaderKey => VarInt|String\n *     HeaderValue => VarInt|Bytes\n */\n\n/**\n * @param [offsetDelta=0] {Integer}\n * @param [timestampDelta=0] {Long}\n * @param key {Buffer}\n * @param value {Buffer}\n * @param [headers={}] {Object}\n */\n\n\nmodule.exports = ({\n  offsetDelta = 0,\n  timestampDelta = 0,\n  key,\n  value,\n  headers = {}\n}) => {\n  const headersArray = Object.keys(headers).map(headerKey => ({\n    key: headerKey,\n    value: headers[headerKey]\n  }));\n  const sizeOfBody = 1 + // always one byte for attributes\n  Encoder.sizeOfVarLong(timestampDelta) + Encoder.sizeOfVarInt(offsetDelta) + Encoder.sizeOfVarIntBytes(key) + Encoder.sizeOfVarIntBytes(value) + sizeOfHeaders(headersArray);\n  return new Encoder().writeVarInt(sizeOfBody).writeInt8(0) // no used record attributes at the moment\n  .writeVarLong(timestampDelta).writeVarInt(offsetDelta).writeVarIntBytes(key).writeVarIntBytes(value).writeVarIntArray(headersArray.map(Header));\n};\n\nconst sizeOfHeaders = headersArray => {\n  let size = Encoder.sizeOfVarInt(headersArray.length);\n\n  for (const header of headersArray) {\n    const keySize = Buffer.byteLength(header.key);\n    const valueSize = Buffer.byteLength(header.value);\n    size += Encoder.sizeOfVarInt(keySize) + keySize;\n\n    if (header.value === null) {\n      size += Encoder.sizeOfVarInt(-1);\n    } else {\n      size += Encoder.sizeOfVarInt(valueSize) + valueSize;\n    }\n  }\n\n  return size;\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/recordBatch/record/v0/index.js"],"names":["Encoder","require","Header","module","exports","offsetDelta","timestampDelta","key","value","headers","headersArray","Object","keys","map","headerKey","sizeOfBody","sizeOfVarLong","sizeOfVarInt","sizeOfVarIntBytes","sizeOfHeaders","writeVarInt","writeInt8","writeVarLong","writeVarIntBytes","writeVarIntArray","size","length","header","keySize","Buffer","byteLength","valueSize"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,iBAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAE,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,WAAW,GAAG,CAAhB;AAAmBC,EAAAA,cAAc,GAAG,CAApC;AAAuCC,EAAAA,GAAvC;AAA4CC,EAAAA,KAA5C;AAAmDC,EAAAA,OAAO,GAAG;AAA7D,CAAD,KAAuE;AACtF,QAAMC,YAAY,GAAGC,MAAM,CAACC,IAAP,CAAYH,OAAZ,EAAqBI,GAArB,CAAyBC,SAAS,KAAK;AAC1DP,IAAAA,GAAG,EAAEO,SADqD;AAE1DN,IAAAA,KAAK,EAAEC,OAAO,CAACK,SAAD;AAF4C,GAAL,CAAlC,CAArB;AAKA,QAAMC,UAAU,GACd,IAAI;AACJf,EAAAA,OAAO,CAACgB,aAAR,CAAsBV,cAAtB,CADA,GAEAN,OAAO,CAACiB,YAAR,CAAqBZ,WAArB,CAFA,GAGAL,OAAO,CAACkB,iBAAR,CAA0BX,GAA1B,CAHA,GAIAP,OAAO,CAACkB,iBAAR,CAA0BV,KAA1B,CAJA,GAKAW,aAAa,CAACT,YAAD,CANf;AAQA,SAAO,IAAIV,OAAJ,GACJoB,WADI,CACQL,UADR,EAEJM,SAFI,CAEM,CAFN,EAES;AAFT,GAGJC,YAHI,CAGShB,cAHT,EAIJc,WAJI,CAIQf,WAJR,EAKJkB,gBALI,CAKahB,GALb,EAMJgB,gBANI,CAMaf,KANb,EAOJgB,gBAPI,CAOad,YAAY,CAACG,GAAb,CAAiBX,MAAjB,CAPb,CAAP;AAQD,CAtBD;;AAwBA,MAAMiB,aAAa,GAAGT,YAAY,IAAI;AACpC,MAAIe,IAAI,GAAGzB,OAAO,CAACiB,YAAR,CAAqBP,YAAY,CAACgB,MAAlC,CAAX;;AAEA,OAAK,MAAMC,MAAX,IAAqBjB,YAArB,EAAmC;AACjC,UAAMkB,OAAO,GAAGC,MAAM,CAACC,UAAP,CAAkBH,MAAM,CAACpB,GAAzB,CAAhB;AACA,UAAMwB,SAAS,GAAGF,MAAM,CAACC,UAAP,CAAkBH,MAAM,CAACnB,KAAzB,CAAlB;AAEAiB,IAAAA,IAAI,IAAIzB,OAAO,CAACiB,YAAR,CAAqBW,OAArB,IAAgCA,OAAxC;;AAEA,QAAID,MAAM,CAACnB,KAAP,KAAiB,IAArB,EAA2B;AACzBiB,MAAAA,IAAI,IAAIzB,OAAO,CAACiB,YAAR,CAAqB,CAAC,CAAtB,CAAR;AACD,KAFD,MAEO;AACLQ,MAAAA,IAAI,IAAIzB,OAAO,CAACiB,YAAR,CAAqBc,SAArB,IAAkCA,SAA1C;AACD;AACF;;AAED,SAAON,IAAP;AACD,CAjBD","sourcesContent":["const Encoder = require('../../../encoder')\nconst Header = require('../../header/v0')\n\n/**\n * v0\n * Record =>\n *   Length => Varint\n *   Attributes => Int8\n *   TimestampDelta => Varlong\n *   OffsetDelta => Varint\n *   Key => varInt|Bytes\n *   Value => varInt|Bytes\n *   Headers => [HeaderKey HeaderValue]\n *     HeaderKey => VarInt|String\n *     HeaderValue => VarInt|Bytes\n */\n\n/**\n * @param [offsetDelta=0] {Integer}\n * @param [timestampDelta=0] {Long}\n * @param key {Buffer}\n * @param value {Buffer}\n * @param [headers={}] {Object}\n */\nmodule.exports = ({ offsetDelta = 0, timestampDelta = 0, key, value, headers = {} }) => {\n  const headersArray = Object.keys(headers).map(headerKey => ({\n    key: headerKey,\n    value: headers[headerKey],\n  }))\n\n  const sizeOfBody =\n    1 + // always one byte for attributes\n    Encoder.sizeOfVarLong(timestampDelta) +\n    Encoder.sizeOfVarInt(offsetDelta) +\n    Encoder.sizeOfVarIntBytes(key) +\n    Encoder.sizeOfVarIntBytes(value) +\n    sizeOfHeaders(headersArray)\n\n  return new Encoder()\n    .writeVarInt(sizeOfBody)\n    .writeInt8(0) // no used record attributes at the moment\n    .writeVarLong(timestampDelta)\n    .writeVarInt(offsetDelta)\n    .writeVarIntBytes(key)\n    .writeVarIntBytes(value)\n    .writeVarIntArray(headersArray.map(Header))\n}\n\nconst sizeOfHeaders = headersArray => {\n  let size = Encoder.sizeOfVarInt(headersArray.length)\n\n  for (const header of headersArray) {\n    const keySize = Buffer.byteLength(header.key)\n    const valueSize = Buffer.byteLength(header.value)\n\n    size += Encoder.sizeOfVarInt(keySize) + keySize\n\n    if (header.value === null) {\n      size += Encoder.sizeOfVarInt(-1)\n    } else {\n      size += Encoder.sizeOfVarInt(valueSize) + valueSize\n    }\n  }\n\n  return size\n}\n"]},"metadata":{},"sourceType":"script"}