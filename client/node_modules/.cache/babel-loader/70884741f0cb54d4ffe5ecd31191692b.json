{"ast":null,"code":"const EventEmitter = require('events');\n\nconst SocketRequest = require('./socketRequest');\n\nconst events = require('../instrumentationEvents');\n\nconst {\n  KafkaJSInvariantViolation\n} = require('../../errors');\n\nconst PRIVATE = {\n  EMIT_QUEUE_SIZE_EVENT: Symbol('private:RequestQueue:emitQueueSizeEvent'),\n  EMIT_REQUEST_QUEUE_EMPTY: Symbol('private:RequestQueue:emitQueueEmpty')\n};\nconst REQUEST_QUEUE_EMPTY = 'requestQueueEmpty';\nmodule.exports = class RequestQueue extends EventEmitter {\n  /**\n   * @param {number} maxInFlightRequests\n   * @param {number} requestTimeout\n   * @param {string} clientId\n   * @param {string} broker\n   * @param {Logger} logger\n   * @param {InstrumentationEventEmitter} [instrumentationEmitter=null]\n   */\n  constructor({\n    instrumentationEmitter = null,\n    maxInFlightRequests,\n    requestTimeout,\n    enforceRequestTimeout,\n    clientId,\n    broker,\n    logger,\n    isConnected = () => true\n  }) {\n    super();\n    this.instrumentationEmitter = instrumentationEmitter;\n    this.maxInFlightRequests = maxInFlightRequests;\n    this.requestTimeout = requestTimeout;\n    this.enforceRequestTimeout = enforceRequestTimeout;\n    this.clientId = clientId;\n    this.broker = broker;\n    this.logger = logger;\n    this.isConnected = isConnected;\n    this.inflight = new Map();\n    this.pending = [];\n    /**\n     * Until when this request queue is throttled and shouldn't send requests\n     *\n     * The value represents the timestamp of the end of the throttling in ms-since-epoch. If the value\n     * is smaller than the current timestamp no throttling is active.\n     *\n     * @type {number}\n     */\n\n    this.throttledUntil = -1;\n    /**\n     * Timeout id if we have scheduled a check for pending requests due to client-side throttling\n     *\n     * @type {null|NodeJS.Timeout}\n     */\n\n    this.throttleCheckTimeoutId = null;\n\n    this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY] = () => {\n      if (this.pending.length === 0 && this.inflight.size === 0) {\n        this.emit(REQUEST_QUEUE_EMPTY);\n      }\n    };\n\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT] = () => {\n      instrumentationEmitter && instrumentationEmitter.emit(events.NETWORK_REQUEST_QUEUE_SIZE, {\n        broker: this.broker,\n        clientId: this.clientId,\n        queueSize: this.pending.length\n      });\n      this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]();\n    };\n  }\n  /**\n   * @public\n   */\n\n\n  scheduleRequestTimeoutCheck() {\n    if (this.enforceRequestTimeout) {\n      this.destroy();\n      this.requestTimeoutIntervalId = setInterval(() => {\n        this.inflight.forEach(request => {\n          if (Date.now() - request.sentAt > request.requestTimeout) {\n            request.timeoutRequest();\n          }\n        });\n\n        if (!this.isConnected()) {\n          this.destroy();\n        }\n      }, Math.min(this.requestTimeout, 100));\n    }\n  }\n\n  maybeThrottle(clientSideThrottleTime) {\n    if (clientSideThrottleTime) {\n      const minimumThrottledUntil = Date.now() + clientSideThrottleTime;\n      this.throttledUntil = Math.max(minimumThrottledUntil, this.throttledUntil);\n    }\n  }\n  /**\n   * @typedef {Object} PushedRequest\n   * @property {RequestEntry} entry\n   * @property {boolean} expectResponse\n   * @property {Function} sendRequest\n   * @property {number} [requestTimeout]\n   *\n   * @public\n   * @param {PushedRequest} pushedRequest\n   */\n\n\n  push(pushedRequest) {\n    const {\n      correlationId\n    } = pushedRequest.entry;\n    const defaultRequestTimeout = this.requestTimeout;\n    const customRequestTimeout = pushedRequest.requestTimeout; // Some protocol requests have custom request timeouts (e.g JoinGroup, Fetch, etc). The custom\n    // timeouts are influenced by user configurations, which can be lower than the default requestTimeout\n\n    const requestTimeout = Math.max(defaultRequestTimeout, customRequestTimeout || 0);\n    const socketRequest = new SocketRequest({\n      entry: pushedRequest.entry,\n      expectResponse: pushedRequest.expectResponse,\n      broker: this.broker,\n      clientId: this.clientId,\n      instrumentationEmitter: this.instrumentationEmitter,\n      requestTimeout,\n      send: () => {\n        if (this.inflight.has(correlationId)) {\n          throw new KafkaJSInvariantViolation('Correlation id already exists');\n        }\n\n        this.inflight.set(correlationId, socketRequest);\n        pushedRequest.sendRequest();\n      },\n      timeout: () => {\n        this.inflight.delete(correlationId);\n        this.checkPendingRequests();\n      }\n    });\n\n    if (this.canSendSocketRequestImmediately()) {\n      this.sendSocketRequest(socketRequest);\n      return;\n    }\n\n    this.pending.push(socketRequest);\n    this.scheduleCheckPendingRequests();\n    this.logger.debug(`Request enqueued`, {\n      clientId: this.clientId,\n      broker: this.broker,\n      correlationId\n    });\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]();\n  }\n  /**\n   * @param {SocketRequest} socketRequest\n   */\n\n\n  sendSocketRequest(socketRequest) {\n    socketRequest.send();\n\n    if (!socketRequest.expectResponse) {\n      this.logger.debug(`Request does not expect a response, resolving immediately`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId: socketRequest.correlationId\n      });\n      this.inflight.delete(socketRequest.correlationId);\n      socketRequest.completed({\n        size: 0,\n        payload: null\n      });\n    }\n  }\n  /**\n   * @public\n   * @param {number} correlationId\n   * @param {Buffer} payload\n   * @param {number} size\n   */\n\n\n  fulfillRequest({\n    correlationId,\n    payload,\n    size\n  }) {\n    const socketRequest = this.inflight.get(correlationId);\n    this.inflight.delete(correlationId);\n    this.checkPendingRequests();\n\n    if (socketRequest) {\n      socketRequest.completed({\n        size,\n        payload\n      });\n    } else {\n      this.logger.warn(`Response without match`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId\n      });\n    }\n\n    this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]();\n  }\n  /**\n   * @public\n   * @param {Error} error\n   */\n\n\n  rejectAll(error) {\n    const requests = [...this.inflight.values(), ...this.pending];\n\n    for (const socketRequest of requests) {\n      socketRequest.rejected(error);\n      this.inflight.delete(socketRequest.correlationId);\n    }\n\n    this.pending = [];\n    this.inflight.clear();\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]();\n  }\n  /**\n   * @public\n   */\n\n\n  waitForPendingRequests() {\n    return new Promise(resolve => {\n      if (this.pending.length === 0 && this.inflight.size === 0) {\n        return resolve();\n      }\n\n      this.logger.debug('Waiting for pending requests', {\n        clientId: this.clientId,\n        broker: this.broker,\n        currentInflightRequests: this.inflight.size,\n        currentPendingQueueSize: this.pending.length\n      });\n      this.once(REQUEST_QUEUE_EMPTY, () => resolve());\n    });\n  }\n  /**\n   * @public\n   */\n\n\n  destroy() {\n    clearInterval(this.requestTimeoutIntervalId);\n    clearTimeout(this.throttleCheckTimeoutId);\n    this.throttleCheckTimeoutId = null;\n  }\n\n  canSendSocketRequestImmediately() {\n    const shouldEnqueue = this.maxInFlightRequests != null && this.inflight.size >= this.maxInFlightRequests || this.throttledUntil > Date.now();\n    return !shouldEnqueue;\n  }\n  /**\n   * Check and process pending requests either now or in the future\n   *\n   * This function will send out as many pending requests as possible taking throttling and\n   * in-flight limits into account.\n   */\n\n\n  checkPendingRequests() {\n    while (this.pending.length > 0 && this.canSendSocketRequestImmediately()) {\n      const pendingRequest = this.pending.shift(); // first in first out\n\n      this.sendSocketRequest(pendingRequest);\n      this.logger.debug(`Consumed pending request`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId: pendingRequest.correlationId,\n        pendingDuration: pendingRequest.pendingDuration,\n        currentPendingQueueSize: this.pending.length\n      });\n      this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]();\n    }\n\n    this.scheduleCheckPendingRequests();\n  }\n  /**\n   * Ensure that pending requests will be checked in the future\n   *\n   * If there is a client-side throttling in place this will ensure that we will check\n   * the pending request queue eventually.\n   */\n\n\n  scheduleCheckPendingRequests() {\n    // If we're throttled: Schedule checkPendingRequests when the throttle\n    // should be resolved. If there is already something scheduled we assume that that\n    // will be fine, and potentially fix up a new timeout if needed at that time.\n    // Note that if we're merely \"overloaded\" by having too many inflight requests\n    // we will anyways check the queue when one of them gets fulfilled.\n    const timeUntilUnthrottled = this.throttledUntil - Date.now();\n\n    if (timeUntilUnthrottled > 0 && !this.throttleCheckTimeoutId) {\n      this.throttleCheckTimeoutId = setTimeout(() => {\n        this.throttleCheckTimeoutId = null;\n        this.checkPendingRequests();\n      }, timeUntilUnthrottled);\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/network/requestQueue/index.js"],"names":["EventEmitter","require","SocketRequest","events","KafkaJSInvariantViolation","PRIVATE","EMIT_QUEUE_SIZE_EVENT","Symbol","EMIT_REQUEST_QUEUE_EMPTY","REQUEST_QUEUE_EMPTY","module","exports","RequestQueue","constructor","instrumentationEmitter","maxInFlightRequests","requestTimeout","enforceRequestTimeout","clientId","broker","logger","isConnected","inflight","Map","pending","throttledUntil","throttleCheckTimeoutId","length","size","emit","NETWORK_REQUEST_QUEUE_SIZE","queueSize","scheduleRequestTimeoutCheck","destroy","requestTimeoutIntervalId","setInterval","forEach","request","Date","now","sentAt","timeoutRequest","Math","min","maybeThrottle","clientSideThrottleTime","minimumThrottledUntil","max","push","pushedRequest","correlationId","entry","defaultRequestTimeout","customRequestTimeout","socketRequest","expectResponse","send","has","set","sendRequest","timeout","delete","checkPendingRequests","canSendSocketRequestImmediately","sendSocketRequest","scheduleCheckPendingRequests","debug","completed","payload","fulfillRequest","get","warn","rejectAll","error","requests","values","rejected","clear","waitForPendingRequests","Promise","resolve","currentInflightRequests","currentPendingQueueSize","once","clearInterval","clearTimeout","shouldEnqueue","pendingRequest","shift","pendingDuration","timeUntilUnthrottled","setTimeout"],"mappings":"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","sourcesContent":["const EventEmitter = require('events')\nconst SocketRequest = require('./socketRequest')\nconst events = require('../instrumentationEvents')\nconst { KafkaJSInvariantViolation } = require('../../errors')\n\nconst PRIVATE = {\n  EMIT_QUEUE_SIZE_EVENT: Symbol('private:RequestQueue:emitQueueSizeEvent'),\n  EMIT_REQUEST_QUEUE_EMPTY: Symbol('private:RequestQueue:emitQueueEmpty'),\n}\n\nconst REQUEST_QUEUE_EMPTY = 'requestQueueEmpty'\n\nmodule.exports = class RequestQueue extends EventEmitter {\n  /**\n   * @param {number} maxInFlightRequests\n   * @param {number} requestTimeout\n   * @param {string} clientId\n   * @param {string} broker\n   * @param {Logger} logger\n   * @param {InstrumentationEventEmitter} [instrumentationEmitter=null]\n   */\n  constructor({\n    instrumentationEmitter = null,\n    maxInFlightRequests,\n    requestTimeout,\n    enforceRequestTimeout,\n    clientId,\n    broker,\n    logger,\n    isConnected = () => true,\n  }) {\n    super()\n    this.instrumentationEmitter = instrumentationEmitter\n    this.maxInFlightRequests = maxInFlightRequests\n    this.requestTimeout = requestTimeout\n    this.enforceRequestTimeout = enforceRequestTimeout\n    this.clientId = clientId\n    this.broker = broker\n    this.logger = logger\n    this.isConnected = isConnected\n\n    this.inflight = new Map()\n    this.pending = []\n\n    /**\n     * Until when this request queue is throttled and shouldn't send requests\n     *\n     * The value represents the timestamp of the end of the throttling in ms-since-epoch. If the value\n     * is smaller than the current timestamp no throttling is active.\n     *\n     * @type {number}\n     */\n    this.throttledUntil = -1\n\n    /**\n     * Timeout id if we have scheduled a check for pending requests due to client-side throttling\n     *\n     * @type {null|NodeJS.Timeout}\n     */\n    this.throttleCheckTimeoutId = null\n\n    this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY] = () => {\n      if (this.pending.length === 0 && this.inflight.size === 0) {\n        this.emit(REQUEST_QUEUE_EMPTY)\n      }\n    }\n\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT] = () => {\n      instrumentationEmitter &&\n        instrumentationEmitter.emit(events.NETWORK_REQUEST_QUEUE_SIZE, {\n          broker: this.broker,\n          clientId: this.clientId,\n          queueSize: this.pending.length,\n        })\n\n      this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]()\n    }\n  }\n\n  /**\n   * @public\n   */\n  scheduleRequestTimeoutCheck() {\n    if (this.enforceRequestTimeout) {\n      this.destroy()\n\n      this.requestTimeoutIntervalId = setInterval(() => {\n        this.inflight.forEach(request => {\n          if (Date.now() - request.sentAt > request.requestTimeout) {\n            request.timeoutRequest()\n          }\n        })\n\n        if (!this.isConnected()) {\n          this.destroy()\n        }\n      }, Math.min(this.requestTimeout, 100))\n    }\n  }\n\n  maybeThrottle(clientSideThrottleTime) {\n    if (clientSideThrottleTime) {\n      const minimumThrottledUntil = Date.now() + clientSideThrottleTime\n      this.throttledUntil = Math.max(minimumThrottledUntil, this.throttledUntil)\n    }\n  }\n\n  /**\n   * @typedef {Object} PushedRequest\n   * @property {RequestEntry} entry\n   * @property {boolean} expectResponse\n   * @property {Function} sendRequest\n   * @property {number} [requestTimeout]\n   *\n   * @public\n   * @param {PushedRequest} pushedRequest\n   */\n  push(pushedRequest) {\n    const { correlationId } = pushedRequest.entry\n    const defaultRequestTimeout = this.requestTimeout\n    const customRequestTimeout = pushedRequest.requestTimeout\n\n    // Some protocol requests have custom request timeouts (e.g JoinGroup, Fetch, etc). The custom\n    // timeouts are influenced by user configurations, which can be lower than the default requestTimeout\n    const requestTimeout = Math.max(defaultRequestTimeout, customRequestTimeout || 0)\n\n    const socketRequest = new SocketRequest({\n      entry: pushedRequest.entry,\n      expectResponse: pushedRequest.expectResponse,\n      broker: this.broker,\n      clientId: this.clientId,\n      instrumentationEmitter: this.instrumentationEmitter,\n      requestTimeout,\n      send: () => {\n        if (this.inflight.has(correlationId)) {\n          throw new KafkaJSInvariantViolation('Correlation id already exists')\n        }\n        this.inflight.set(correlationId, socketRequest)\n        pushedRequest.sendRequest()\n      },\n      timeout: () => {\n        this.inflight.delete(correlationId)\n        this.checkPendingRequests()\n      },\n    })\n\n    if (this.canSendSocketRequestImmediately()) {\n      this.sendSocketRequest(socketRequest)\n      return\n    }\n\n    this.pending.push(socketRequest)\n    this.scheduleCheckPendingRequests()\n\n    this.logger.debug(`Request enqueued`, {\n      clientId: this.clientId,\n      broker: this.broker,\n      correlationId,\n    })\n\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]()\n  }\n\n  /**\n   * @param {SocketRequest} socketRequest\n   */\n  sendSocketRequest(socketRequest) {\n    socketRequest.send()\n\n    if (!socketRequest.expectResponse) {\n      this.logger.debug(`Request does not expect a response, resolving immediately`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId: socketRequest.correlationId,\n      })\n\n      this.inflight.delete(socketRequest.correlationId)\n      socketRequest.completed({ size: 0, payload: null })\n    }\n  }\n\n  /**\n   * @public\n   * @param {number} correlationId\n   * @param {Buffer} payload\n   * @param {number} size\n   */\n  fulfillRequest({ correlationId, payload, size }) {\n    const socketRequest = this.inflight.get(correlationId)\n    this.inflight.delete(correlationId)\n    this.checkPendingRequests()\n\n    if (socketRequest) {\n      socketRequest.completed({ size, payload })\n    } else {\n      this.logger.warn(`Response without match`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId,\n      })\n    }\n\n    this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]()\n  }\n\n  /**\n   * @public\n   * @param {Error} error\n   */\n  rejectAll(error) {\n    const requests = [...this.inflight.values(), ...this.pending]\n\n    for (const socketRequest of requests) {\n      socketRequest.rejected(error)\n      this.inflight.delete(socketRequest.correlationId)\n    }\n\n    this.pending = []\n    this.inflight.clear()\n    this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]()\n  }\n\n  /**\n   * @public\n   */\n  waitForPendingRequests() {\n    return new Promise(resolve => {\n      if (this.pending.length === 0 && this.inflight.size === 0) {\n        return resolve()\n      }\n\n      this.logger.debug('Waiting for pending requests', {\n        clientId: this.clientId,\n        broker: this.broker,\n        currentInflightRequests: this.inflight.size,\n        currentPendingQueueSize: this.pending.length,\n      })\n\n      this.once(REQUEST_QUEUE_EMPTY, () => resolve())\n    })\n  }\n\n  /**\n   * @public\n   */\n  destroy() {\n    clearInterval(this.requestTimeoutIntervalId)\n    clearTimeout(this.throttleCheckTimeoutId)\n    this.throttleCheckTimeoutId = null\n  }\n\n  canSendSocketRequestImmediately() {\n    const shouldEnqueue =\n      (this.maxInFlightRequests != null && this.inflight.size >= this.maxInFlightRequests) ||\n      this.throttledUntil > Date.now()\n\n    return !shouldEnqueue\n  }\n\n  /**\n   * Check and process pending requests either now or in the future\n   *\n   * This function will send out as many pending requests as possible taking throttling and\n   * in-flight limits into account.\n   */\n  checkPendingRequests() {\n    while (this.pending.length > 0 && this.canSendSocketRequestImmediately()) {\n      const pendingRequest = this.pending.shift() // first in first out\n      this.sendSocketRequest(pendingRequest)\n\n      this.logger.debug(`Consumed pending request`, {\n        clientId: this.clientId,\n        broker: this.broker,\n        correlationId: pendingRequest.correlationId,\n        pendingDuration: pendingRequest.pendingDuration,\n        currentPendingQueueSize: this.pending.length,\n      })\n\n      this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]()\n    }\n\n    this.scheduleCheckPendingRequests()\n  }\n\n  /**\n   * Ensure that pending requests will be checked in the future\n   *\n   * If there is a client-side throttling in place this will ensure that we will check\n   * the pending request queue eventually.\n   */\n  scheduleCheckPendingRequests() {\n    // If we're throttled: Schedule checkPendingRequests when the throttle\n    // should be resolved. If there is already something scheduled we assume that that\n    // will be fine, and potentially fix up a new timeout if needed at that time.\n    // Note that if we're merely \"overloaded\" by having too many inflight requests\n    // we will anyways check the queue when one of them gets fulfilled.\n    const timeUntilUnthrottled = this.throttledUntil - Date.now()\n    if (timeUntilUnthrottled > 0 && !this.throttleCheckTimeoutId) {\n      this.throttleCheckTimeoutId = setTimeout(() => {\n        this.throttleCheckTimeoutId = null\n        this.checkPendingRequests()\n      }, timeUntilUnthrottled)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}