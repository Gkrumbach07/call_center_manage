{"ast":null,"code":"const createRetry = require('../../retry');\n\nconst {\n  KafkaJSNonRetriableError\n} = require('../../errors');\n\nconst COORDINATOR_TYPES = require('../../protocol/coordinatorTypes');\n\nconst createStateMachine = require('./transactionStateMachine');\n\nconst assert = require('assert');\n\nconst STATES = require('./transactionStates');\n\nconst NO_PRODUCER_ID = -1;\nconst SEQUENCE_START = 0;\nconst INT_32_MAX_VALUE = Math.pow(2, 32);\nconst INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS = ['NOT_COORDINATOR_FOR_GROUP', 'GROUP_COORDINATOR_NOT_AVAILABLE', 'GROUP_LOAD_IN_PROGRESS',\n/**\n * The producer might have crashed and never committed the transaction; retry the\n * request so Kafka can abort the current transaction\n * @see https://github.com/apache/kafka/blob/201da0542726472d954080d54bc585b111aaf86f/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1001-L1002\n */\n'CONCURRENT_TRANSACTIONS'];\nconst COMMIT_RETRIABLE_PROTOCOL_ERRORS = ['UNKNOWN_TOPIC_OR_PARTITION', 'COORDINATOR_LOAD_IN_PROGRESS'];\nconst COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS = ['COORDINATOR_NOT_AVAILABLE', 'NOT_COORDINATOR'];\n/**\n * Manage behavior for an idempotent producer and transactions.\n */\n\nmodule.exports = ({\n  logger,\n  cluster,\n  transactionTimeout = 60000,\n  transactional,\n  transactionalId\n}) => {\n  if (transactional && !transactionalId) {\n    throw new KafkaJSNonRetriableError('Cannot manage transactions without a transactionalId');\n  }\n\n  const retrier = createRetry(cluster.retry);\n  /**\n   * Current producer ID\n   */\n\n  let producerId = NO_PRODUCER_ID;\n  /**\n   * Current producer epoch\n   */\n\n  let producerEpoch = 0;\n  /**\n   * Idempotent production requires that the producer track the sequence number of messages.\n   *\n   * Sequences are sent with every Record Batch and tracked per Topic-Partition\n   */\n\n  let producerSequence = {};\n  /**\n   * Topic partitions already participating in the transaction\n   */\n\n  let transactionTopicPartitions = {};\n  const stateMachine = createStateMachine({\n    logger\n  });\n  stateMachine.on('transition', ({\n    to\n  }) => {\n    if (to === STATES.READY) {\n      transactionTopicPartitions = {};\n    }\n  });\n\n  const findTransactionCoordinator = () => {\n    return cluster.findGroupCoordinator({\n      groupId: transactionalId,\n      coordinatorType: COORDINATOR_TYPES.TRANSACTION\n    });\n  };\n\n  const transactionalGuard = () => {\n    if (!transactional) {\n      throw new KafkaJSNonRetriableError('Method unavailable if non-transactional');\n    }\n  };\n\n  const eosManager = stateMachine.createGuarded({\n    /**\n     * Get the current producer id\n     * @returns {number}\n     */\n    getProducerId() {\n      return producerId;\n    },\n\n    /**\n     * Get the current producer epoch\n     * @returns {number}\n     */\n    getProducerEpoch() {\n      return producerEpoch;\n    },\n\n    getTransactionalId() {\n      return transactionalId;\n    },\n\n    /**\n     * Initialize the idempotent producer by making an `InitProducerId` request.\n     * Overwrites any existing state in this transaction manager\n     */\n    async initProducerId() {\n      return retrier(async (bail, retryCount, retryTime) => {\n        try {\n          await cluster.refreshMetadataIfNecessary(); // If non-transactional we can request the PID from any broker\n\n          const broker = await (transactional ? findTransactionCoordinator() : cluster.findControllerBroker());\n          const result = await broker.initProducerId({\n            transactionalId: transactional ? transactionalId : undefined,\n            transactionTimeout\n          });\n          stateMachine.transitionTo(STATES.READY);\n          producerId = result.producerId;\n          producerEpoch = result.producerEpoch;\n          producerSequence = {};\n          logger.debug('Initialized producer id & epoch', {\n            producerId,\n            producerEpoch\n          });\n        } catch (e) {\n          if (INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {\n            if (e.type === 'CONCURRENT_TRANSACTIONS') {\n              logger.debug('There is an ongoing transaction on this transactionId, retrying', {\n                error: e.message,\n                stack: e.stack,\n                transactionalId,\n                retryCount,\n                retryTime\n              });\n            }\n\n            throw e;\n          }\n\n          bail(e);\n        }\n      });\n    },\n\n    /**\n     * Get the current sequence for a given Topic-Partition. Defaults to 0.\n     *\n     * @param {string} topic\n     * @param {string} partition\n     * @returns {number}\n     */\n    getSequence(topic, partition) {\n      if (!eosManager.isInitialized()) {\n        return SEQUENCE_START;\n      }\n\n      producerSequence[topic] = producerSequence[topic] || {};\n      producerSequence[topic][partition] = producerSequence[topic][partition] || SEQUENCE_START;\n      return producerSequence[topic][partition];\n    },\n\n    /**\n     * Update the sequence for a given Topic-Partition.\n     *\n     * Do nothing if not yet initialized (not idempotent)\n     * @param {string} topic\n     * @param {string} partition\n     * @param {number} increment\n     */\n    updateSequence(topic, partition, increment) {\n      if (!eosManager.isInitialized()) {\n        return;\n      }\n\n      const previous = eosManager.getSequence(topic, partition);\n      let sequence = previous + increment; // Sequence is defined as Int32 in the Record Batch,\n      // so theoretically should need to rotate here\n\n      if (sequence >= INT_32_MAX_VALUE) {\n        logger.debug(`Sequence for ${topic} ${partition} exceeds max value (${sequence}). Rotating to 0.`);\n        sequence = 0;\n      }\n\n      producerSequence[topic][partition] = sequence;\n    },\n\n    /**\n     * Begin a transaction\n     */\n    beginTransaction() {\n      transactionalGuard();\n      stateMachine.transitionTo(STATES.TRANSACTING);\n    },\n\n    /**\n     * Add partitions to a transaction if they are not already marked as participating.\n     *\n     * Should be called prior to sending any messages during a transaction\n     * @param {TopicData[]} topicData\n     *\n     * @typedef {Object} TopicData\n     * @property {string} topic\n     * @property {object[]} partitions\n     * @property {number} partitions[].partition\n     */\n    async addPartitionsToTransaction(topicData) {\n      transactionalGuard();\n      const newTopicPartitions = {};\n      topicData.forEach(({\n        topic,\n        partitions\n      }) => {\n        transactionTopicPartitions[topic] = transactionTopicPartitions[topic] || {};\n        partitions.forEach(({\n          partition\n        }) => {\n          if (!transactionTopicPartitions[topic][partition]) {\n            newTopicPartitions[topic] = newTopicPartitions[topic] || [];\n            newTopicPartitions[topic].push(partition);\n          }\n        });\n      });\n      const topics = Object.keys(newTopicPartitions).map(topic => ({\n        topic,\n        partitions: newTopicPartitions[topic]\n      }));\n\n      if (topics.length) {\n        const broker = await findTransactionCoordinator();\n        await broker.addPartitionsToTxn({\n          transactionalId,\n          producerId,\n          producerEpoch,\n          topics\n        });\n      }\n\n      topics.forEach(({\n        topic,\n        partitions\n      }) => {\n        partitions.forEach(partition => {\n          transactionTopicPartitions[topic][partition] = true;\n        });\n      });\n    },\n\n    /**\n     * Commit the ongoing transaction\n     */\n    async commit() {\n      transactionalGuard();\n      stateMachine.transitionTo(STATES.COMMITTING);\n      const broker = await findTransactionCoordinator();\n      await broker.endTxn({\n        producerId,\n        producerEpoch,\n        transactionalId,\n        transactionResult: true\n      });\n      stateMachine.transitionTo(STATES.READY);\n    },\n\n    /**\n     * Abort the ongoing transaction\n     */\n    async abort() {\n      transactionalGuard();\n      stateMachine.transitionTo(STATES.ABORTING);\n      const broker = await findTransactionCoordinator();\n      await broker.endTxn({\n        producerId,\n        producerEpoch,\n        transactionalId,\n        transactionResult: false\n      });\n      stateMachine.transitionTo(STATES.READY);\n    },\n\n    /**\n     * Whether the producer id has already been initialized\n     */\n    isInitialized() {\n      return producerId !== NO_PRODUCER_ID;\n    },\n\n    isTransactional() {\n      return transactional;\n    },\n\n    isInTransaction() {\n      return stateMachine.state() === STATES.TRANSACTING;\n    },\n\n    /**\n     * Mark the provided offsets as participating in the transaction for the given consumer group.\n     *\n     * This allows us to commit an offset as consumed only if the transaction passes.\n     * @param {string} consumerGroupId The unique group identifier\n     * @param {OffsetCommitTopic[]} topics The unique group identifier\n     * @returns {Promise}\n     *\n     * @typedef {Object} OffsetCommitTopic\n     * @property {string} topic\n     * @property {OffsetCommitTopicPartition[]} partitions\n     *\n     * @typedef {Object} OffsetCommitTopicPartition\n     * @property {number} partition\n     * @property {number} offset\n     */\n    async sendOffsets({\n      consumerGroupId,\n      topics\n    }) {\n      assert(consumerGroupId, 'Missing consumerGroupId');\n      assert(topics, 'Missing offset topics');\n      const transactionCoordinator = await findTransactionCoordinator(); // Do we need to add offsets if we've already done so for this consumer group?\n\n      await transactionCoordinator.addOffsetsToTxn({\n        transactionalId,\n        producerId,\n        producerEpoch,\n        groupId: consumerGroupId\n      });\n      let groupCoordinator = await cluster.findGroupCoordinator({\n        groupId: consumerGroupId,\n        coordinatorType: COORDINATOR_TYPES.GROUP\n      });\n      return retrier(async (bail, retryCount, retryTime) => {\n        try {\n          await groupCoordinator.txnOffsetCommit({\n            transactionalId,\n            producerId,\n            producerEpoch,\n            groupId: consumerGroupId,\n            topics\n          });\n        } catch (e) {\n          if (COMMIT_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {\n            logger.debug('Group coordinator is not ready yet, retrying', {\n              error: e.message,\n              stack: e.stack,\n              transactionalId,\n              retryCount,\n              retryTime\n            });\n            throw e;\n          }\n\n          if (COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS.includes(e.type) || e.code === 'ECONNREFUSED') {\n            logger.debug('Invalid group coordinator, finding new group coordinator and retrying', {\n              error: e.message,\n              stack: e.stack,\n              transactionalId,\n              retryCount,\n              retryTime\n            });\n            groupCoordinator = await cluster.findGroupCoordinator({\n              groupId: consumerGroupId,\n              coordinatorType: COORDINATOR_TYPES.GROUP\n            });\n            throw e;\n          }\n\n          bail(e);\n        }\n      });\n    }\n\n  },\n  /**\n   * Transaction state guards\n   */\n  {\n    initProducerId: {\n      legalStates: [STATES.UNINITIALIZED, STATES.READY]\n    },\n    beginTransaction: {\n      legalStates: [STATES.READY],\n      async: false\n    },\n    addPartitionsToTransaction: {\n      legalStates: [STATES.TRANSACTING]\n    },\n    sendOffsets: {\n      legalStates: [STATES.TRANSACTING]\n    },\n    commit: {\n      legalStates: [STATES.TRANSACTING]\n    },\n    abort: {\n      legalStates: [STATES.TRANSACTING]\n    }\n  });\n  return eosManager;\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/producer/eosManager/index.js"],"names":["createRetry","require","KafkaJSNonRetriableError","COORDINATOR_TYPES","createStateMachine","assert","STATES","NO_PRODUCER_ID","SEQUENCE_START","INT_32_MAX_VALUE","Math","pow","INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS","COMMIT_RETRIABLE_PROTOCOL_ERRORS","COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS","module","exports","logger","cluster","transactionTimeout","transactional","transactionalId","retrier","retry","producerId","producerEpoch","producerSequence","transactionTopicPartitions","stateMachine","on","to","READY","findTransactionCoordinator","findGroupCoordinator","groupId","coordinatorType","TRANSACTION","transactionalGuard","eosManager","createGuarded","getProducerId","getProducerEpoch","getTransactionalId","initProducerId","bail","retryCount","retryTime","refreshMetadataIfNecessary","broker","findControllerBroker","result","undefined","transitionTo","debug","e","includes","type","error","message","stack","getSequence","topic","partition","isInitialized","updateSequence","increment","previous","sequence","beginTransaction","TRANSACTING","addPartitionsToTransaction","topicData","newTopicPartitions","forEach","partitions","push","topics","Object","keys","map","length","addPartitionsToTxn","commit","COMMITTING","endTxn","transactionResult","abort","ABORTING","isTransactional","isInTransaction","state","sendOffsets","consumerGroupId","transactionCoordinator","addOffsetsToTxn","groupCoordinator","GROUP","txnOffsetCommit","code","legalStates","UNINITIALIZED","async"],"mappings":"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","sourcesContent":["const createRetry = require('../../retry')\nconst { KafkaJSNonRetriableError } = require('../../errors')\nconst COORDINATOR_TYPES = require('../../protocol/coordinatorTypes')\nconst createStateMachine = require('./transactionStateMachine')\nconst assert = require('assert')\n\nconst STATES = require('./transactionStates')\nconst NO_PRODUCER_ID = -1\nconst SEQUENCE_START = 0\nconst INT_32_MAX_VALUE = Math.pow(2, 32)\nconst INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS = [\n  'NOT_COORDINATOR_FOR_GROUP',\n  'GROUP_COORDINATOR_NOT_AVAILABLE',\n  'GROUP_LOAD_IN_PROGRESS',\n  /**\n   * The producer might have crashed and never committed the transaction; retry the\n   * request so Kafka can abort the current transaction\n   * @see https://github.com/apache/kafka/blob/201da0542726472d954080d54bc585b111aaf86f/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1001-L1002\n   */\n  'CONCURRENT_TRANSACTIONS',\n]\nconst COMMIT_RETRIABLE_PROTOCOL_ERRORS = [\n  'UNKNOWN_TOPIC_OR_PARTITION',\n  'COORDINATOR_LOAD_IN_PROGRESS',\n]\nconst COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS = ['COORDINATOR_NOT_AVAILABLE', 'NOT_COORDINATOR']\n\n/**\n * Manage behavior for an idempotent producer and transactions.\n */\nmodule.exports = ({\n  logger,\n  cluster,\n  transactionTimeout = 60000,\n  transactional,\n  transactionalId,\n}) => {\n  if (transactional && !transactionalId) {\n    throw new KafkaJSNonRetriableError('Cannot manage transactions without a transactionalId')\n  }\n\n  const retrier = createRetry(cluster.retry)\n\n  /**\n   * Current producer ID\n   */\n  let producerId = NO_PRODUCER_ID\n\n  /**\n   * Current producer epoch\n   */\n  let producerEpoch = 0\n\n  /**\n   * Idempotent production requires that the producer track the sequence number of messages.\n   *\n   * Sequences are sent with every Record Batch and tracked per Topic-Partition\n   */\n  let producerSequence = {}\n\n  /**\n   * Topic partitions already participating in the transaction\n   */\n  let transactionTopicPartitions = {}\n\n  const stateMachine = createStateMachine({ logger })\n  stateMachine.on('transition', ({ to }) => {\n    if (to === STATES.READY) {\n      transactionTopicPartitions = {}\n    }\n  })\n\n  const findTransactionCoordinator = () => {\n    return cluster.findGroupCoordinator({\n      groupId: transactionalId,\n      coordinatorType: COORDINATOR_TYPES.TRANSACTION,\n    })\n  }\n\n  const transactionalGuard = () => {\n    if (!transactional) {\n      throw new KafkaJSNonRetriableError('Method unavailable if non-transactional')\n    }\n  }\n\n  const eosManager = stateMachine.createGuarded(\n    {\n      /**\n       * Get the current producer id\n       * @returns {number}\n       */\n      getProducerId() {\n        return producerId\n      },\n\n      /**\n       * Get the current producer epoch\n       * @returns {number}\n       */\n      getProducerEpoch() {\n        return producerEpoch\n      },\n\n      getTransactionalId() {\n        return transactionalId\n      },\n\n      /**\n       * Initialize the idempotent producer by making an `InitProducerId` request.\n       * Overwrites any existing state in this transaction manager\n       */\n      async initProducerId() {\n        return retrier(async (bail, retryCount, retryTime) => {\n          try {\n            await cluster.refreshMetadataIfNecessary()\n\n            // If non-transactional we can request the PID from any broker\n            const broker = await (transactional\n              ? findTransactionCoordinator()\n              : cluster.findControllerBroker())\n\n            const result = await broker.initProducerId({\n              transactionalId: transactional ? transactionalId : undefined,\n              transactionTimeout,\n            })\n\n            stateMachine.transitionTo(STATES.READY)\n            producerId = result.producerId\n            producerEpoch = result.producerEpoch\n            producerSequence = {}\n\n            logger.debug('Initialized producer id & epoch', { producerId, producerEpoch })\n          } catch (e) {\n            if (INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {\n              if (e.type === 'CONCURRENT_TRANSACTIONS') {\n                logger.debug('There is an ongoing transaction on this transactionId, retrying', {\n                  error: e.message,\n                  stack: e.stack,\n                  transactionalId,\n                  retryCount,\n                  retryTime,\n                })\n              }\n\n              throw e\n            }\n\n            bail(e)\n          }\n        })\n      },\n\n      /**\n       * Get the current sequence for a given Topic-Partition. Defaults to 0.\n       *\n       * @param {string} topic\n       * @param {string} partition\n       * @returns {number}\n       */\n      getSequence(topic, partition) {\n        if (!eosManager.isInitialized()) {\n          return SEQUENCE_START\n        }\n\n        producerSequence[topic] = producerSequence[topic] || {}\n        producerSequence[topic][partition] = producerSequence[topic][partition] || SEQUENCE_START\n\n        return producerSequence[topic][partition]\n      },\n\n      /**\n       * Update the sequence for a given Topic-Partition.\n       *\n       * Do nothing if not yet initialized (not idempotent)\n       * @param {string} topic\n       * @param {string} partition\n       * @param {number} increment\n       */\n      updateSequence(topic, partition, increment) {\n        if (!eosManager.isInitialized()) {\n          return\n        }\n\n        const previous = eosManager.getSequence(topic, partition)\n        let sequence = previous + increment\n\n        // Sequence is defined as Int32 in the Record Batch,\n        // so theoretically should need to rotate here\n        if (sequence >= INT_32_MAX_VALUE) {\n          logger.debug(\n            `Sequence for ${topic} ${partition} exceeds max value (${sequence}). Rotating to 0.`\n          )\n          sequence = 0\n        }\n\n        producerSequence[topic][partition] = sequence\n      },\n\n      /**\n       * Begin a transaction\n       */\n      beginTransaction() {\n        transactionalGuard()\n        stateMachine.transitionTo(STATES.TRANSACTING)\n      },\n\n      /**\n       * Add partitions to a transaction if they are not already marked as participating.\n       *\n       * Should be called prior to sending any messages during a transaction\n       * @param {TopicData[]} topicData\n       *\n       * @typedef {Object} TopicData\n       * @property {string} topic\n       * @property {object[]} partitions\n       * @property {number} partitions[].partition\n       */\n      async addPartitionsToTransaction(topicData) {\n        transactionalGuard()\n        const newTopicPartitions = {}\n\n        topicData.forEach(({ topic, partitions }) => {\n          transactionTopicPartitions[topic] = transactionTopicPartitions[topic] || {}\n\n          partitions.forEach(({ partition }) => {\n            if (!transactionTopicPartitions[topic][partition]) {\n              newTopicPartitions[topic] = newTopicPartitions[topic] || []\n              newTopicPartitions[topic].push(partition)\n            }\n          })\n        })\n\n        const topics = Object.keys(newTopicPartitions).map(topic => ({\n          topic,\n          partitions: newTopicPartitions[topic],\n        }))\n\n        if (topics.length) {\n          const broker = await findTransactionCoordinator()\n          await broker.addPartitionsToTxn({ transactionalId, producerId, producerEpoch, topics })\n        }\n\n        topics.forEach(({ topic, partitions }) => {\n          partitions.forEach(partition => {\n            transactionTopicPartitions[topic][partition] = true\n          })\n        })\n      },\n\n      /**\n       * Commit the ongoing transaction\n       */\n      async commit() {\n        transactionalGuard()\n        stateMachine.transitionTo(STATES.COMMITTING)\n\n        const broker = await findTransactionCoordinator()\n        await broker.endTxn({\n          producerId,\n          producerEpoch,\n          transactionalId,\n          transactionResult: true,\n        })\n\n        stateMachine.transitionTo(STATES.READY)\n      },\n\n      /**\n       * Abort the ongoing transaction\n       */\n      async abort() {\n        transactionalGuard()\n        stateMachine.transitionTo(STATES.ABORTING)\n\n        const broker = await findTransactionCoordinator()\n        await broker.endTxn({\n          producerId,\n          producerEpoch,\n          transactionalId,\n          transactionResult: false,\n        })\n\n        stateMachine.transitionTo(STATES.READY)\n      },\n\n      /**\n       * Whether the producer id has already been initialized\n       */\n      isInitialized() {\n        return producerId !== NO_PRODUCER_ID\n      },\n\n      isTransactional() {\n        return transactional\n      },\n\n      isInTransaction() {\n        return stateMachine.state() === STATES.TRANSACTING\n      },\n\n      /**\n       * Mark the provided offsets as participating in the transaction for the given consumer group.\n       *\n       * This allows us to commit an offset as consumed only if the transaction passes.\n       * @param {string} consumerGroupId The unique group identifier\n       * @param {OffsetCommitTopic[]} topics The unique group identifier\n       * @returns {Promise}\n       *\n       * @typedef {Object} OffsetCommitTopic\n       * @property {string} topic\n       * @property {OffsetCommitTopicPartition[]} partitions\n       *\n       * @typedef {Object} OffsetCommitTopicPartition\n       * @property {number} partition\n       * @property {number} offset\n       */\n      async sendOffsets({ consumerGroupId, topics }) {\n        assert(consumerGroupId, 'Missing consumerGroupId')\n        assert(topics, 'Missing offset topics')\n\n        const transactionCoordinator = await findTransactionCoordinator()\n\n        // Do we need to add offsets if we've already done so for this consumer group?\n        await transactionCoordinator.addOffsetsToTxn({\n          transactionalId,\n          producerId,\n          producerEpoch,\n          groupId: consumerGroupId,\n        })\n\n        let groupCoordinator = await cluster.findGroupCoordinator({\n          groupId: consumerGroupId,\n          coordinatorType: COORDINATOR_TYPES.GROUP,\n        })\n\n        return retrier(async (bail, retryCount, retryTime) => {\n          try {\n            await groupCoordinator.txnOffsetCommit({\n              transactionalId,\n              producerId,\n              producerEpoch,\n              groupId: consumerGroupId,\n              topics,\n            })\n          } catch (e) {\n            if (COMMIT_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {\n              logger.debug('Group coordinator is not ready yet, retrying', {\n                error: e.message,\n                stack: e.stack,\n                transactionalId,\n                retryCount,\n                retryTime,\n              })\n\n              throw e\n            }\n\n            if (\n              COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS.includes(e.type) ||\n              e.code === 'ECONNREFUSED'\n            ) {\n              logger.debug(\n                'Invalid group coordinator, finding new group coordinator and retrying',\n                {\n                  error: e.message,\n                  stack: e.stack,\n                  transactionalId,\n                  retryCount,\n                  retryTime,\n                }\n              )\n\n              groupCoordinator = await cluster.findGroupCoordinator({\n                groupId: consumerGroupId,\n                coordinatorType: COORDINATOR_TYPES.GROUP,\n              })\n\n              throw e\n            }\n\n            bail(e)\n          }\n        })\n      },\n    },\n\n    /**\n     * Transaction state guards\n     */\n    {\n      initProducerId: { legalStates: [STATES.UNINITIALIZED, STATES.READY] },\n      beginTransaction: { legalStates: [STATES.READY], async: false },\n      addPartitionsToTransaction: { legalStates: [STATES.TRANSACTING] },\n      sendOffsets: { legalStates: [STATES.TRANSACTING] },\n      commit: { legalStates: [STATES.TRANSACTING] },\n      abort: { legalStates: [STATES.TRANSACTING] },\n    }\n  )\n\n  return eosManager\n}\n"]},"metadata":{},"sourceType":"script"}