{"ast":null,"code":"const {\n  KafkaJSNonRetriableError\n} = require('../errors');\n\nconst REJECTED_ERROR = new KafkaJSNonRetriableError('Queued function aborted due to earlier promise rejection');\n\nfunction NOOP() {}\n\nconst concurrency = ({\n  limit,\n  onChange = NOOP\n} = {}) => {\n  if (isNaN(limit) || typeof limit !== 'number' || limit < 1) {\n    throw new KafkaJSNonRetriableError(`\"limit\" cannot be less than 1`);\n  }\n\n  let waiting = [];\n  let semaphore = 0;\n\n  const clear = () => {\n    for (const lazyAction of waiting) {\n      lazyAction((_1, _2, reject) => reject(REJECTED_ERROR));\n    }\n\n    waiting = [];\n    semaphore = 0;\n  };\n\n  const next = () => {\n    semaphore--;\n    onChange(semaphore);\n\n    if (waiting.length > 0) {\n      const lazyAction = waiting.shift();\n      lazyAction();\n    }\n  };\n\n  const invoke = (action, resolve, reject) => {\n    semaphore++;\n    onChange(semaphore);\n    action().then(result => {\n      resolve(result);\n      next();\n    }).catch(error => {\n      reject(error);\n      clear();\n    });\n  };\n\n  const push = (action, resolve, reject) => {\n    if (semaphore < limit) {\n      invoke(action, resolve, reject);\n    } else {\n      waiting.push(override => {\n        const execute = override || invoke;\n        execute(action, resolve, reject);\n      });\n    }\n  };\n\n  return action => new Promise((resolve, reject) => push(action, resolve, reject));\n};\n\nmodule.exports = concurrency;","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/utils/concurrency.js"],"names":["KafkaJSNonRetriableError","require","REJECTED_ERROR","NOOP","concurrency","limit","onChange","isNaN","waiting","semaphore","clear","lazyAction","_1","_2","reject","next","length","shift","invoke","action","resolve","then","result","catch","error","push","override","execute","Promise","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAA+BC,OAAO,CAAC,WAAD,CAA5C;;AAEA,MAAMC,cAAc,GAAG,IAAIF,wBAAJ,CACrB,0DADqB,CAAvB;;AAGA,SAASG,IAAT,GAAgB,CAAE;;AAElB,MAAMC,WAAW,GAAG,CAAC;AAAEC,EAAAA,KAAF;AAASC,EAAAA,QAAQ,GAAGH;AAApB,IAA6B,EAA9B,KAAqC;AACvD,MAAII,KAAK,CAACF,KAAD,CAAL,IAAgB,OAAOA,KAAP,KAAiB,QAAjC,IAA6CA,KAAK,GAAG,CAAzD,EAA4D;AAC1D,UAAM,IAAIL,wBAAJ,CAA8B,+BAA9B,CAAN;AACD;;AAED,MAAIQ,OAAO,GAAG,EAAd;AACA,MAAIC,SAAS,GAAG,CAAhB;;AAEA,QAAMC,KAAK,GAAG,MAAM;AAClB,SAAK,MAAMC,UAAX,IAAyBH,OAAzB,EAAkC;AAChCG,MAAAA,UAAU,CAAC,CAACC,EAAD,EAAKC,EAAL,EAASC,MAAT,KAAoBA,MAAM,CAACZ,cAAD,CAA3B,CAAV;AACD;;AACDM,IAAAA,OAAO,GAAG,EAAV;AACAC,IAAAA,SAAS,GAAG,CAAZ;AACD,GAND;;AAQA,QAAMM,IAAI,GAAG,MAAM;AACjBN,IAAAA,SAAS;AACTH,IAAAA,QAAQ,CAACG,SAAD,CAAR;;AAEA,QAAID,OAAO,CAACQ,MAAR,GAAiB,CAArB,EAAwB;AACtB,YAAML,UAAU,GAAGH,OAAO,CAACS,KAAR,EAAnB;AACAN,MAAAA,UAAU;AACX;AACF,GARD;;AAUA,QAAMO,MAAM,GAAG,CAACC,MAAD,EAASC,OAAT,EAAkBN,MAAlB,KAA6B;AAC1CL,IAAAA,SAAS;AACTH,IAAAA,QAAQ,CAACG,SAAD,CAAR;AAEAU,IAAAA,MAAM,GACHE,IADH,CACQC,MAAM,IAAI;AACdF,MAAAA,OAAO,CAACE,MAAD,CAAP;AACAP,MAAAA,IAAI;AACL,KAJH,EAKGQ,KALH,CAKSC,KAAK,IAAI;AACdV,MAAAA,MAAM,CAACU,KAAD,CAAN;AACAd,MAAAA,KAAK;AACN,KARH;AASD,GAbD;;AAeA,QAAMe,IAAI,GAAG,CAACN,MAAD,EAASC,OAAT,EAAkBN,MAAlB,KAA6B;AACxC,QAAIL,SAAS,GAAGJ,KAAhB,EAAuB;AACrBa,MAAAA,MAAM,CAACC,MAAD,EAASC,OAAT,EAAkBN,MAAlB,CAAN;AACD,KAFD,MAEO;AACLN,MAAAA,OAAO,CAACiB,IAAR,CAAaC,QAAQ,IAAI;AACvB,cAAMC,OAAO,GAAGD,QAAQ,IAAIR,MAA5B;AACAS,QAAAA,OAAO,CAACR,MAAD,EAASC,OAAT,EAAkBN,MAAlB,CAAP;AACD,OAHD;AAID;AACF,GATD;;AAWA,SAAOK,MAAM,IAAI,IAAIS,OAAJ,CAAY,CAACR,OAAD,EAAUN,MAAV,KAAqBW,IAAI,CAACN,MAAD,EAASC,OAAT,EAAkBN,MAAlB,CAArC,CAAjB;AACD,CArDD;;AAuDAe,MAAM,CAACC,OAAP,GAAiB1B,WAAjB","sourcesContent":["const { KafkaJSNonRetriableError } = require('../errors')\n\nconst REJECTED_ERROR = new KafkaJSNonRetriableError(\n  'Queued function aborted due to earlier promise rejection'\n)\nfunction NOOP() {}\n\nconst concurrency = ({ limit, onChange = NOOP } = {}) => {\n  if (isNaN(limit) || typeof limit !== 'number' || limit < 1) {\n    throw new KafkaJSNonRetriableError(`\"limit\" cannot be less than 1`)\n  }\n\n  let waiting = []\n  let semaphore = 0\n\n  const clear = () => {\n    for (const lazyAction of waiting) {\n      lazyAction((_1, _2, reject) => reject(REJECTED_ERROR))\n    }\n    waiting = []\n    semaphore = 0\n  }\n\n  const next = () => {\n    semaphore--\n    onChange(semaphore)\n\n    if (waiting.length > 0) {\n      const lazyAction = waiting.shift()\n      lazyAction()\n    }\n  }\n\n  const invoke = (action, resolve, reject) => {\n    semaphore++\n    onChange(semaphore)\n\n    action()\n      .then(result => {\n        resolve(result)\n        next()\n      })\n      .catch(error => {\n        reject(error)\n        clear()\n      })\n  }\n\n  const push = (action, resolve, reject) => {\n    if (semaphore < limit) {\n      invoke(action, resolve, reject)\n    } else {\n      waiting.push(override => {\n        const execute = override || invoke\n        execute(action, resolve, reject)\n      })\n    }\n  }\n\n  return action => new Promise((resolve, reject) => push(action, resolve, reject))\n}\n\nmodule.exports = concurrency\n"]},"metadata":{},"sourceType":"script"}