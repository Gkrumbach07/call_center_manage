{"ast":null,"code":"const defaultErrorHandler = e => {\n  throw e;\n};\n/**\n * Generator that processes the given promises, and yields their result in the order of them resolving.\n *\n * @template T\n * @param {Promise<T>[]} promises promises to process\n * @param {(err: Error) => any} [handleError] optional error handler\n * @returns {Generator<Promise<T>>}\n */\n\n\nfunction* BufferedAsyncIterator(promises, handleError = defaultErrorHandler) {\n  /** Queue of promises in order of resolution */\n  const promisesQueue = [];\n  /** Queue of {resolve, reject} in the same order as `promisesQueue` */\n\n  const resolveRejectQueue = [];\n  promises.forEach(promise => {\n    // Create a new promise into the promises queue, and keep the {resolve,reject}\n    // in the resolveRejectQueue\n    let resolvePromise;\n    let rejectPromise;\n    promisesQueue.push(new Promise((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    }));\n    resolveRejectQueue.push({\n      resolve: resolvePromise,\n      reject: rejectPromise\n    }); // When the promise resolves pick the next available {resolve, reject}, and\n    // through that resolve the next promise in the queue\n\n    promise.then(result => {\n      const {\n        resolve\n      } = resolveRejectQueue.pop();\n      resolve(result);\n    }, async err => {\n      const {\n        reject\n      } = resolveRejectQueue.pop();\n\n      try {\n        await handleError(err);\n        reject(err);\n      } catch (newError) {\n        reject(newError);\n      }\n    });\n  }); // While there are promises left pick the next one to yield\n  // The caller will then wait for the value to resolve.\n\n  while (promisesQueue.length > 0) {\n    const nextPromise = promisesQueue.pop();\n    yield nextPromise;\n  }\n}\n\nmodule.exports = BufferedAsyncIterator;","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/utils/bufferedAsyncIterator.js"],"names":["defaultErrorHandler","e","BufferedAsyncIterator","promises","handleError","promisesQueue","resolveRejectQueue","forEach","promise","resolvePromise","rejectPromise","push","Promise","resolve","reject","then","result","pop","err","newError","length","nextPromise","module","exports"],"mappings":"AAAA,MAAMA,mBAAmB,GAAGC,CAAC,IAAI;AAC/B,QAAMA,CAAN;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAUC,qBAAV,CAAgCC,QAAhC,EAA0CC,WAAW,GAAGJ,mBAAxD,EAA6E;AAC3E;AACA,QAAMK,aAAa,GAAG,EAAtB;AACA;;AACA,QAAMC,kBAAkB,GAAG,EAA3B;AAEAH,EAAAA,QAAQ,CAACI,OAAT,CAAiBC,OAAO,IAAI;AAC1B;AACA;AACA,QAAIC,cAAJ;AACA,QAAIC,aAAJ;AACAL,IAAAA,aAAa,CAACM,IAAd,CACE,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC/BL,MAAAA,cAAc,GAAGI,OAAjB;AACAH,MAAAA,aAAa,GAAGI,MAAhB;AACD,KAHD,CADF;AAMAR,IAAAA,kBAAkB,CAACK,IAAnB,CAAwB;AAAEE,MAAAA,OAAO,EAAEJ,cAAX;AAA2BK,MAAAA,MAAM,EAAEJ;AAAnC,KAAxB,EAX0B,CAa1B;AACA;;AACAF,IAAAA,OAAO,CAACO,IAAR,CACEC,MAAM,IAAI;AACR,YAAM;AAAEH,QAAAA;AAAF,UAAcP,kBAAkB,CAACW,GAAnB,EAApB;AACAJ,MAAAA,OAAO,CAACG,MAAD,CAAP;AACD,KAJH,EAKE,MAAME,GAAN,IAAa;AACX,YAAM;AAAEJ,QAAAA;AAAF,UAAaR,kBAAkB,CAACW,GAAnB,EAAnB;;AACA,UAAI;AACF,cAAMb,WAAW,CAACc,GAAD,CAAjB;AACAJ,QAAAA,MAAM,CAACI,GAAD,CAAN;AACD,OAHD,CAGE,OAAOC,QAAP,EAAiB;AACjBL,QAAAA,MAAM,CAACK,QAAD,CAAN;AACD;AACF,KAbH;AAeD,GA9BD,EAN2E,CAsC3E;AACA;;AACA,SAAOd,aAAa,CAACe,MAAd,GAAuB,CAA9B,EAAiC;AAC/B,UAAMC,WAAW,GAAGhB,aAAa,CAACY,GAAd,EAApB;AACA,UAAMI,WAAN;AACD;AACF;;AAEDC,MAAM,CAACC,OAAP,GAAiBrB,qBAAjB","sourcesContent":["const defaultErrorHandler = e => {\n  throw e\n}\n\n/**\n * Generator that processes the given promises, and yields their result in the order of them resolving.\n *\n * @template T\n * @param {Promise<T>[]} promises promises to process\n * @param {(err: Error) => any} [handleError] optional error handler\n * @returns {Generator<Promise<T>>}\n */\nfunction* BufferedAsyncIterator(promises, handleError = defaultErrorHandler) {\n  /** Queue of promises in order of resolution */\n  const promisesQueue = []\n  /** Queue of {resolve, reject} in the same order as `promisesQueue` */\n  const resolveRejectQueue = []\n\n  promises.forEach(promise => {\n    // Create a new promise into the promises queue, and keep the {resolve,reject}\n    // in the resolveRejectQueue\n    let resolvePromise\n    let rejectPromise\n    promisesQueue.push(\n      new Promise((resolve, reject) => {\n        resolvePromise = resolve\n        rejectPromise = reject\n      })\n    )\n    resolveRejectQueue.push({ resolve: resolvePromise, reject: rejectPromise })\n\n    // When the promise resolves pick the next available {resolve, reject}, and\n    // through that resolve the next promise in the queue\n    promise.then(\n      result => {\n        const { resolve } = resolveRejectQueue.pop()\n        resolve(result)\n      },\n      async err => {\n        const { reject } = resolveRejectQueue.pop()\n        try {\n          await handleError(err)\n          reject(err)\n        } catch (newError) {\n          reject(newError)\n        }\n      }\n    )\n  })\n\n  // While there are promises left pick the next one to yield\n  // The caller will then wait for the value to resolve.\n  while (promisesQueue.length > 0) {\n    const nextPromise = promisesQueue.pop()\n    yield nextPromise\n  }\n}\n\nmodule.exports = BufferedAsyncIterator\n"]},"metadata":{},"sourceType":"script"}