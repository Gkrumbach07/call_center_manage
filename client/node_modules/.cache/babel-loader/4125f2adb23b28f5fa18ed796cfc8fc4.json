{"ast":null,"code":"const Decoder = require('../../../decoder');\n\nconst {\n  parse: parseV1\n} = require('../v1/response');\n\nconst decodeMessages = require('./decodeMessages');\n/**\n * Fetch Response (Version: 4) => throttle_time_ms [responses]\n *   throttle_time_ms => INT32\n *   responses => topic [partition_responses]\n *     topic => STRING\n *     partition_responses => partition_header record_set\n *       partition_header => partition error_code high_watermark last_stable_offset [aborted_transactions]\n *         partition => INT32\n *         error_code => INT16\n *         high_watermark => INT64\n *         last_stable_offset => INT64\n *         aborted_transactions => producer_id first_offset\n *           producer_id => INT64\n *           first_offset => INT64\n *       record_set => RECORDS\n */\n\n\nconst decodeAbortedTransactions = decoder => ({\n  producerId: decoder.readInt64().toString(),\n  firstOffset: decoder.readInt64().toString()\n});\n\nconst decodePartition = async decoder => ({\n  partition: decoder.readInt32(),\n  errorCode: decoder.readInt16(),\n  highWatermark: decoder.readInt64().toString(),\n  lastStableOffset: decoder.readInt64().toString(),\n  abortedTransactions: decoder.readArray(decodeAbortedTransactions),\n  messages: await decodeMessages(decoder)\n});\n\nconst decodeResponse = async decoder => ({\n  topicName: decoder.readString(),\n  partitions: await decoder.readArrayAsync(decodePartition)\n});\n\nconst decode = async rawData => {\n  const decoder = new Decoder(rawData);\n  const throttleTime = decoder.readInt32();\n  const responses = await decoder.readArrayAsync(decodeResponse);\n  return {\n    throttleTime,\n    responses\n  };\n};\n\nmodule.exports = {\n  decode,\n  parse: parseV1\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/requests/fetch/v4/response.js"],"names":["Decoder","require","parse","parseV1","decodeMessages","decodeAbortedTransactions","decoder","producerId","readInt64","toString","firstOffset","decodePartition","partition","readInt32","errorCode","readInt16","highWatermark","lastStableOffset","abortedTransactions","readArray","messages","decodeResponse","topicName","readString","partitions","readArrayAsync","decode","rawData","throttleTime","responses","module","exports"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA,KAAK,EAAEC;AAAT,IAAqBF,OAAO,CAAC,gBAAD,CAAlC;;AACA,MAAMG,cAAc,GAAGH,OAAO,CAAC,kBAAD,CAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMI,yBAAyB,GAAGC,OAAO,KAAK;AAC5CC,EAAAA,UAAU,EAAED,OAAO,CAACE,SAAR,GAAoBC,QAApB,EADgC;AAE5CC,EAAAA,WAAW,EAAEJ,OAAO,CAACE,SAAR,GAAoBC,QAApB;AAF+B,CAAL,CAAzC;;AAKA,MAAME,eAAe,GAAG,MAAML,OAAN,KAAkB;AACxCM,EAAAA,SAAS,EAAEN,OAAO,CAACO,SAAR,EAD6B;AAExCC,EAAAA,SAAS,EAAER,OAAO,CAACS,SAAR,EAF6B;AAGxCC,EAAAA,aAAa,EAAEV,OAAO,CAACE,SAAR,GAAoBC,QAApB,EAHyB;AAIxCQ,EAAAA,gBAAgB,EAAEX,OAAO,CAACE,SAAR,GAAoBC,QAApB,EAJsB;AAKxCS,EAAAA,mBAAmB,EAAEZ,OAAO,CAACa,SAAR,CAAkBd,yBAAlB,CALmB;AAMxCe,EAAAA,QAAQ,EAAE,MAAMhB,cAAc,CAACE,OAAD;AANU,CAAlB,CAAxB;;AASA,MAAMe,cAAc,GAAG,MAAMf,OAAN,KAAkB;AACvCgB,EAAAA,SAAS,EAAEhB,OAAO,CAACiB,UAAR,EAD4B;AAEvCC,EAAAA,UAAU,EAAE,MAAMlB,OAAO,CAACmB,cAAR,CAAuBd,eAAvB;AAFqB,CAAlB,CAAvB;;AAKA,MAAMe,MAAM,GAAG,MAAMC,OAAN,IAAiB;AAC9B,QAAMrB,OAAO,GAAG,IAAIN,OAAJ,CAAY2B,OAAZ,CAAhB;AACA,QAAMC,YAAY,GAAGtB,OAAO,CAACO,SAAR,EAArB;AACA,QAAMgB,SAAS,GAAG,MAAMvB,OAAO,CAACmB,cAAR,CAAuBJ,cAAvB,CAAxB;AAEA,SAAO;AACLO,IAAAA,YADK;AAELC,IAAAA;AAFK,GAAP;AAID,CATD;;AAWAC,MAAM,CAACC,OAAP,GAAiB;AACfL,EAAAA,MADe;AAEfxB,EAAAA,KAAK,EAAEC;AAFQ,CAAjB","sourcesContent":["const Decoder = require('../../../decoder')\nconst { parse: parseV1 } = require('../v1/response')\nconst decodeMessages = require('./decodeMessages')\n\n/**\n * Fetch Response (Version: 4) => throttle_time_ms [responses]\n *   throttle_time_ms => INT32\n *   responses => topic [partition_responses]\n *     topic => STRING\n *     partition_responses => partition_header record_set\n *       partition_header => partition error_code high_watermark last_stable_offset [aborted_transactions]\n *         partition => INT32\n *         error_code => INT16\n *         high_watermark => INT64\n *         last_stable_offset => INT64\n *         aborted_transactions => producer_id first_offset\n *           producer_id => INT64\n *           first_offset => INT64\n *       record_set => RECORDS\n */\n\nconst decodeAbortedTransactions = decoder => ({\n  producerId: decoder.readInt64().toString(),\n  firstOffset: decoder.readInt64().toString(),\n})\n\nconst decodePartition = async decoder => ({\n  partition: decoder.readInt32(),\n  errorCode: decoder.readInt16(),\n  highWatermark: decoder.readInt64().toString(),\n  lastStableOffset: decoder.readInt64().toString(),\n  abortedTransactions: decoder.readArray(decodeAbortedTransactions),\n  messages: await decodeMessages(decoder),\n})\n\nconst decodeResponse = async decoder => ({\n  topicName: decoder.readString(),\n  partitions: await decoder.readArrayAsync(decodePartition),\n})\n\nconst decode = async rawData => {\n  const decoder = new Decoder(rawData)\n  const throttleTime = decoder.readInt32()\n  const responses = await decoder.readArrayAsync(decodeResponse)\n\n  return {\n    throttleTime,\n    responses,\n  }\n}\n\nmodule.exports = {\n  decode,\n  parse: parseV1,\n}\n"]},"metadata":{},"sourceType":"script"}