{"ast":null,"code":"const Long = require('../../../utils/long');\n\nconst Encoder = require('../../encoder');\n\nconst crc32C = require('../crc32C');\n\nconst {\n  Types: Compression,\n  lookupCodec,\n  COMPRESSION_CODEC_MASK\n} = require('../../message/compression');\n\nconst MAGIC_BYTE = 2;\nconst TIMESTAMP_MASK = 0; // The fourth lowest bit, always set this bit to 0 (since 0.10.0)\n\nconst TRANSACTIONAL_MASK = 16; // The fifth lowest bit\n\n/**\n * v0\n * RecordBatch =>\n *  FirstOffset => int64\n *  Length => int32\n *  PartitionLeaderEpoch => int32\n *  Magic => int8\n *  CRC => int32\n *  Attributes => int16\n *  LastOffsetDelta => int32\n *  FirstTimestamp => int64\n *  MaxTimestamp => int64\n *  ProducerId => int64\n *  ProducerEpoch => int16\n *  FirstSequence => int32\n *  Records => [Record]\n */\n\nconst RecordBatch = async ({\n  compression = Compression.None,\n  firstOffset = Long.fromInt(0),\n  firstTimestamp = Date.now(),\n  maxTimestamp = Date.now(),\n  partitionLeaderEpoch = 0,\n  lastOffsetDelta = 0,\n  transactional = false,\n  producerId = Long.fromValue(-1),\n  // for idempotent messages\n  producerEpoch = 0,\n  // for idempotent messages\n  firstSequence = 0,\n  // for idempotent messages\n  records = []\n}) => {\n  const COMPRESSION_CODEC = compression & COMPRESSION_CODEC_MASK;\n  const IN_TRANSACTION = transactional ? TRANSACTIONAL_MASK : 0;\n  const attributes = COMPRESSION_CODEC | TIMESTAMP_MASK | IN_TRANSACTION;\n  const batchBody = new Encoder().writeInt16(attributes).writeInt32(lastOffsetDelta).writeInt64(firstTimestamp).writeInt64(maxTimestamp).writeInt64(producerId).writeInt16(producerEpoch).writeInt32(firstSequence);\n\n  if (compression === Compression.None) {\n    if (records.every(v => typeof v === typeof records[0])) {\n      batchBody.writeArray(records, typeof records[0]);\n    } else {\n      batchBody.writeArray(records);\n    }\n  } else {\n    const compressedRecords = await compressRecords(compression, records);\n    batchBody.writeInt32(records.length).writeBuffer(compressedRecords);\n  } // CRC32C validation is happening here:\n  // https://github.com/apache/kafka/blob/0.11.0.1/clients/src/main/java/org/apache/kafka/common/record/DefaultRecordBatch.java#L148\n\n\n  const batch = new Encoder().writeInt32(partitionLeaderEpoch).writeInt8(MAGIC_BYTE).writeUInt32(crc32C(batchBody.buffer)).writeEncoder(batchBody);\n  return new Encoder().writeInt64(firstOffset).writeBytes(batch.buffer);\n};\n\nconst compressRecords = async (compression, records) => {\n  const codec = lookupCodec(compression);\n  const recordsEncoder = new Encoder();\n  recordsEncoder.writeEncoderArray(records);\n  return codec.compress(recordsEncoder);\n};\n\nmodule.exports = {\n  RecordBatch,\n  MAGIC_BYTE\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/recordBatch/v0/index.js"],"names":["Long","require","Encoder","crc32C","Types","Compression","lookupCodec","COMPRESSION_CODEC_MASK","MAGIC_BYTE","TIMESTAMP_MASK","TRANSACTIONAL_MASK","RecordBatch","compression","None","firstOffset","fromInt","firstTimestamp","Date","now","maxTimestamp","partitionLeaderEpoch","lastOffsetDelta","transactional","producerId","fromValue","producerEpoch","firstSequence","records","COMPRESSION_CODEC","IN_TRANSACTION","attributes","batchBody","writeInt16","writeInt32","writeInt64","every","v","writeArray","compressedRecords","compressRecords","length","writeBuffer","batch","writeInt8","writeUInt32","buffer","writeEncoder","writeBytes","codec","recordsEncoder","writeEncoderArray","compress","module","exports"],"mappings":"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","sourcesContent":["const Long = require('../../../utils/long')\nconst Encoder = require('../../encoder')\nconst crc32C = require('../crc32C')\nconst {\n  Types: Compression,\n  lookupCodec,\n  COMPRESSION_CODEC_MASK,\n} = require('../../message/compression')\n\nconst MAGIC_BYTE = 2\nconst TIMESTAMP_MASK = 0 // The fourth lowest bit, always set this bit to 0 (since 0.10.0)\nconst TRANSACTIONAL_MASK = 16 // The fifth lowest bit\n\n/**\n * v0\n * RecordBatch =>\n *  FirstOffset => int64\n *  Length => int32\n *  PartitionLeaderEpoch => int32\n *  Magic => int8\n *  CRC => int32\n *  Attributes => int16\n *  LastOffsetDelta => int32\n *  FirstTimestamp => int64\n *  MaxTimestamp => int64\n *  ProducerId => int64\n *  ProducerEpoch => int16\n *  FirstSequence => int32\n *  Records => [Record]\n */\n\nconst RecordBatch = async ({\n  compression = Compression.None,\n  firstOffset = Long.fromInt(0),\n  firstTimestamp = Date.now(),\n  maxTimestamp = Date.now(),\n  partitionLeaderEpoch = 0,\n  lastOffsetDelta = 0,\n  transactional = false,\n  producerId = Long.fromValue(-1), // for idempotent messages\n  producerEpoch = 0, // for idempotent messages\n  firstSequence = 0, // for idempotent messages\n  records = [],\n}) => {\n  const COMPRESSION_CODEC = compression & COMPRESSION_CODEC_MASK\n  const IN_TRANSACTION = transactional ? TRANSACTIONAL_MASK : 0\n  const attributes = COMPRESSION_CODEC | TIMESTAMP_MASK | IN_TRANSACTION\n\n  const batchBody = new Encoder()\n    .writeInt16(attributes)\n    .writeInt32(lastOffsetDelta)\n    .writeInt64(firstTimestamp)\n    .writeInt64(maxTimestamp)\n    .writeInt64(producerId)\n    .writeInt16(producerEpoch)\n    .writeInt32(firstSequence)\n\n  if (compression === Compression.None) {\n    if (records.every(v => typeof v === typeof records[0])) {\n      batchBody.writeArray(records, typeof records[0])\n    } else {\n      batchBody.writeArray(records)\n    }\n  } else {\n    const compressedRecords = await compressRecords(compression, records)\n    batchBody.writeInt32(records.length).writeBuffer(compressedRecords)\n  }\n\n  // CRC32C validation is happening here:\n  // https://github.com/apache/kafka/blob/0.11.0.1/clients/src/main/java/org/apache/kafka/common/record/DefaultRecordBatch.java#L148\n\n  const batch = new Encoder()\n    .writeInt32(partitionLeaderEpoch)\n    .writeInt8(MAGIC_BYTE)\n    .writeUInt32(crc32C(batchBody.buffer))\n    .writeEncoder(batchBody)\n\n  return new Encoder().writeInt64(firstOffset).writeBytes(batch.buffer)\n}\n\nconst compressRecords = async (compression, records) => {\n  const codec = lookupCodec(compression)\n  const recordsEncoder = new Encoder()\n\n  recordsEncoder.writeEncoderArray(records)\n\n  return codec.compress(recordsEncoder)\n}\n\nmodule.exports = {\n  RecordBatch,\n  MAGIC_BYTE,\n}\n"]},"metadata":{},"sourceType":"script"}