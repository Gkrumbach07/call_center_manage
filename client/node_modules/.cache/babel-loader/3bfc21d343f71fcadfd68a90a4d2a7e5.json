{"ast":null,"code":"const Long = require('../../utils/long');\n\nconst flatten = require('../../utils/flatten');\n\nconst isInvalidOffset = require('./isInvalidOffset');\n\nconst initializeConsumerOffsets = require('./initializeConsumerOffsets');\n\nconst {\n  events: {\n    COMMIT_OFFSETS\n  }\n} = require('../instrumentationEvents');\n\nconst {\n  keys,\n  assign\n} = Object;\n\nconst indexTopics = topics => topics.reduce((obj, topic) => assign(obj, {\n  [topic]: {}\n}), {});\n\nconst PRIVATE = {\n  COMMITTED_OFFSETS: Symbol('private:OffsetManager:committedOffsets')\n};\nmodule.exports = class OffsetManager {\n  constructor({\n    cluster,\n    coordinator,\n    memberAssignment,\n    autoCommitInterval,\n    autoCommitThreshold,\n    topicConfigurations,\n    instrumentationEmitter,\n    groupId,\n    generationId,\n    memberId\n  }) {\n    this.cluster = cluster;\n    this.coordinator = coordinator; // memberAssignment format:\n    // {\n    //   'topic1': [0, 1, 2, 3],\n    //   'topic2': [0, 1, 2, 3, 4, 5],\n    // }\n\n    this.memberAssignment = memberAssignment;\n    this.topicConfigurations = topicConfigurations;\n    this.instrumentationEmitter = instrumentationEmitter;\n    this.groupId = groupId;\n    this.generationId = generationId;\n    this.memberId = memberId;\n    this.autoCommitInterval = autoCommitInterval;\n    this.autoCommitThreshold = autoCommitThreshold;\n    this.lastCommit = Date.now();\n    this.topics = keys(memberAssignment);\n    this.clearAllOffsets();\n  }\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   * @returns {Long}\n   */\n\n\n  nextOffset(topic, partition) {\n    if (!this.resolvedOffsets[topic][partition]) {\n      this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition];\n    }\n\n    let offset = this.resolvedOffsets[topic][partition];\n\n    if (isInvalidOffset(offset)) {\n      offset = '0';\n    }\n\n    return Long.fromValue(offset);\n  }\n  /**\n   * @returns {Broker}\n   */\n\n\n  async getCoordinator() {\n    if (!this.coordinator.isConnected()) {\n      this.coordinator = await this.cluster.findBroker(this.coordinator);\n    }\n\n    return this.coordinator;\n  }\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   */\n\n\n  resetOffset({\n    topic,\n    partition\n  }) {\n    this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition];\n  }\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   * @param {string} offset\n   */\n\n\n  resolveOffset({\n    topic,\n    partition,\n    offset\n  }) {\n    this.resolvedOffsets[topic][partition] = Long.fromValue(offset).add(1).toString();\n  }\n  /**\n   * @returns {Long}\n   */\n\n\n  countResolvedOffsets() {\n    const committedOffsets = this.committedOffsets();\n\n    const subtractOffsets = (resolvedOffset, committedOffset) => {\n      const resolvedOffsetLong = Long.fromValue(resolvedOffset);\n      return isInvalidOffset(committedOffset) ? resolvedOffsetLong : resolvedOffsetLong.subtract(Long.fromValue(committedOffset));\n    };\n\n    const subtractPartitionOffsets = (resolvedTopicOffsets, committedTopicOffsets) => keys(resolvedTopicOffsets).map(partition => subtractOffsets(resolvedTopicOffsets[partition], committedTopicOffsets[partition]));\n\n    const subtractTopicOffsets = topic => subtractPartitionOffsets(this.resolvedOffsets[topic], committedOffsets[topic]);\n\n    const offsetsDiff = this.topics.map(subtractTopicOffsets);\n    return flatten(offsetsDiff).reduce((sum, offset) => sum.add(offset), Long.fromValue(0));\n  }\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   */\n\n\n  async setDefaultOffset({\n    topic,\n    partition\n  }) {\n    const {\n      groupId,\n      generationId,\n      memberId\n    } = this;\n    const defaultOffset = this.cluster.defaultOffset(this.topicConfigurations[topic]);\n    const coordinator = await this.getCoordinator();\n    await coordinator.offsetCommit({\n      groupId,\n      memberId,\n      groupGenerationId: generationId,\n      topics: [{\n        topic,\n        partitions: [{\n          partition,\n          offset: defaultOffset\n        }]\n      }]\n    });\n    this.clearOffsets({\n      topic,\n      partition\n    });\n  }\n  /**\n   * Commit the given offset to the topic/partition. If the consumer isn't assigned to the given\n   * topic/partition this method will be a NO-OP.\n   *\n   * @param {string} topic\n   * @param {number} partition\n   * @param {string} offset\n   */\n\n\n  async seek({\n    topic,\n    partition,\n    offset\n  }) {\n    if (!this.memberAssignment[topic] || !this.memberAssignment[topic].includes(partition)) {\n      return;\n    }\n\n    const {\n      groupId,\n      generationId,\n      memberId\n    } = this;\n    const coordinator = await this.getCoordinator();\n    await coordinator.offsetCommit({\n      groupId,\n      memberId,\n      groupGenerationId: generationId,\n      topics: [{\n        topic,\n        partitions: [{\n          partition,\n          offset\n        }]\n      }]\n    });\n    this.clearOffsets({\n      topic,\n      partition\n    });\n  }\n\n  async commitOffsetsIfNecessary() {\n    const now = Date.now();\n    const timeoutReached = this.autoCommitInterval != null && now >= this.lastCommit + this.autoCommitInterval;\n    const thresholdReached = this.autoCommitThreshold != null && this.countResolvedOffsets().gte(Long.fromValue(this.autoCommitThreshold));\n\n    if (timeoutReached || thresholdReached) {\n      return this.commitOffsets();\n    }\n  }\n  /**\n   * Return all locally resolved offsets which are not marked as committed, by topic-partition.\n   * @returns {OffsetsByTopicPartition}\n   *\n   * @typedef {Object} OffsetsByTopicPartition\n   * @property {TopicOffsets[]} topics\n   *\n   * @typedef {Object} TopicOffsets\n   * @property {PartitionOffset[]} partitions\n   *\n   * @typedef {Object} PartitionOffset\n   * @property {string} partition\n   * @property {string} offset\n   */\n\n\n  uncommittedOffsets() {\n    const offsets = topic => keys(this.resolvedOffsets[topic]);\n\n    const emptyPartitions = ({\n      partitions\n    }) => partitions.length > 0;\n\n    const toPartitions = topic => partition => ({\n      partition,\n      offset: this.resolvedOffsets[topic][partition]\n    });\n\n    const changedOffsets = topic => ({\n      partition,\n      offset\n    }) => {\n      return offset !== this.committedOffsets()[topic][partition] && Long.fromValue(offset).greaterThanOrEqual(0);\n    }; // Select and format updated partitions\n\n\n    const topicsWithPartitionsToCommit = this.topics.map(topic => ({\n      topic,\n      partitions: offsets(topic).map(toPartitions(topic)).filter(changedOffsets(topic))\n    })).filter(emptyPartitions);\n    return {\n      topics: topicsWithPartitionsToCommit\n    };\n  }\n\n  async commitOffsets(offsets = {}) {\n    const {\n      groupId,\n      generationId,\n      memberId\n    } = this;\n    const {\n      topics = this.uncommittedOffsets().topics\n    } = offsets;\n\n    if (topics.length === 0) {\n      this.lastCommit = Date.now();\n      return;\n    }\n\n    const payload = {\n      groupId,\n      memberId,\n      groupGenerationId: generationId,\n      topics\n    };\n\n    try {\n      const coordinator = await this.getCoordinator();\n      await coordinator.offsetCommit(payload);\n      this.instrumentationEmitter.emit(COMMIT_OFFSETS, payload); // Update local reference of committed offsets\n\n      topics.forEach(({\n        topic,\n        partitions\n      }) => {\n        const updatedOffsets = partitions.reduce((obj, {\n          partition,\n          offset\n        }) => assign(obj, {\n          [partition]: offset\n        }), {});\n        assign(this.committedOffsets()[topic], updatedOffsets);\n      });\n      this.lastCommit = Date.now();\n    } catch (e) {\n      // metadata is stale, the coordinator has changed due to a restart or\n      // broker reassignment\n      if (e.type === 'NOT_COORDINATOR_FOR_GROUP') {\n        await this.cluster.refreshMetadata();\n      }\n\n      throw e;\n    }\n  }\n\n  async resolveOffsets() {\n    const {\n      groupId\n    } = this;\n\n    const invalidOffset = topic => partition => {\n      return isInvalidOffset(this.committedOffsets()[topic][partition]);\n    };\n\n    const pendingPartitions = this.topics.map(topic => ({\n      topic,\n      partitions: this.memberAssignment[topic].filter(invalidOffset(topic)).map(partition => ({\n        partition\n      }))\n    })).filter(t => t.partitions.length > 0);\n\n    if (pendingPartitions.length === 0) {\n      return;\n    }\n\n    const coordinator = await this.getCoordinator();\n    const {\n      responses: consumerOffsets\n    } = await coordinator.offsetFetch({\n      groupId,\n      topics: pendingPartitions\n    });\n    const unresolvedPartitions = consumerOffsets.map(({\n      topic,\n      partitions\n    }) => assign({\n      topic,\n      partitions: partitions.filter(({\n        offset\n      }) => isInvalidOffset(offset)).map(({\n        partition\n      }) => assign({\n        partition\n      }))\n    }, this.topicConfigurations[topic]));\n\n    const indexPartitions = (obj, {\n      partition,\n      offset\n    }) => {\n      return assign(obj, {\n        [partition]: offset\n      });\n    };\n\n    const hasUnresolvedPartitions = () => unresolvedPartitions.filter(t => t.partitions.length > 0).length > 0;\n\n    let offsets = consumerOffsets;\n\n    if (hasUnresolvedPartitions()) {\n      const topicOffsets = await this.cluster.fetchTopicsOffset(unresolvedPartitions);\n      offsets = initializeConsumerOffsets(consumerOffsets, topicOffsets);\n    }\n\n    offsets.forEach(({\n      topic,\n      partitions\n    }) => {\n      this.committedOffsets()[topic] = partitions.reduce(indexPartitions, { ...this.committedOffsets()[topic]\n      });\n    });\n  }\n  /**\n   * @private\n   * @param {string} topic\n   * @param {number} partition\n   */\n\n\n  clearOffsets({\n    topic,\n    partition\n  }) {\n    delete this.committedOffsets()[topic][partition];\n    delete this.resolvedOffsets[topic][partition];\n  }\n  /**\n   * @private\n   */\n\n\n  clearAllOffsets() {\n    const committedOffsets = this.committedOffsets();\n\n    for (const topic in committedOffsets) {\n      delete committedOffsets[topic];\n    }\n\n    for (const topic of this.topics) {\n      committedOffsets[topic] = {};\n    }\n\n    this.resolvedOffsets = indexTopics(this.topics);\n  }\n\n  committedOffsets() {\n    if (!this[PRIVATE.COMMITTED_OFFSETS]) {\n      this[PRIVATE.COMMITTED_OFFSETS] = this.groupId ? this.cluster.committedOffsets({\n        groupId: this.groupId\n      }) : {};\n    }\n\n    return this[PRIVATE.COMMITTED_OFFSETS];\n  }\n\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/consumer/offsetManager/index.js"],"names":["Long","require","flatten","isInvalidOffset","initializeConsumerOffsets","events","COMMIT_OFFSETS","keys","assign","Object","indexTopics","topics","reduce","obj","topic","PRIVATE","COMMITTED_OFFSETS","Symbol","module","exports","OffsetManager","constructor","cluster","coordinator","memberAssignment","autoCommitInterval","autoCommitThreshold","topicConfigurations","instrumentationEmitter","groupId","generationId","memberId","lastCommit","Date","now","clearAllOffsets","nextOffset","partition","resolvedOffsets","committedOffsets","offset","fromValue","getCoordinator","isConnected","findBroker","resetOffset","resolveOffset","add","toString","countResolvedOffsets","subtractOffsets","resolvedOffset","committedOffset","resolvedOffsetLong","subtract","subtractPartitionOffsets","resolvedTopicOffsets","committedTopicOffsets","map","subtractTopicOffsets","offsetsDiff","sum","setDefaultOffset","defaultOffset","offsetCommit","groupGenerationId","partitions","clearOffsets","seek","includes","commitOffsetsIfNecessary","timeoutReached","thresholdReached","gte","commitOffsets","uncommittedOffsets","offsets","emptyPartitions","length","toPartitions","changedOffsets","greaterThanOrEqual","topicsWithPartitionsToCommit","filter","payload","emit","forEach","updatedOffsets","e","type","refreshMetadata","resolveOffsets","invalidOffset","pendingPartitions","t","responses","consumerOffsets","offsetFetch","unresolvedPartitions","indexPartitions","hasUnresolvedPartitions","topicOffsets","fetchTopicsOffset"],"mappings":"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","sourcesContent":["const Long = require('../../utils/long')\nconst flatten = require('../../utils/flatten')\nconst isInvalidOffset = require('./isInvalidOffset')\nconst initializeConsumerOffsets = require('./initializeConsumerOffsets')\nconst {\n  events: { COMMIT_OFFSETS },\n} = require('../instrumentationEvents')\n\nconst { keys, assign } = Object\nconst indexTopics = topics => topics.reduce((obj, topic) => assign(obj, { [topic]: {} }), {})\n\nconst PRIVATE = {\n  COMMITTED_OFFSETS: Symbol('private:OffsetManager:committedOffsets'),\n}\nmodule.exports = class OffsetManager {\n  constructor({\n    cluster,\n    coordinator,\n    memberAssignment,\n    autoCommitInterval,\n    autoCommitThreshold,\n    topicConfigurations,\n    instrumentationEmitter,\n    groupId,\n    generationId,\n    memberId,\n  }) {\n    this.cluster = cluster\n    this.coordinator = coordinator\n\n    // memberAssignment format:\n    // {\n    //   'topic1': [0, 1, 2, 3],\n    //   'topic2': [0, 1, 2, 3, 4, 5],\n    // }\n    this.memberAssignment = memberAssignment\n\n    this.topicConfigurations = topicConfigurations\n    this.instrumentationEmitter = instrumentationEmitter\n    this.groupId = groupId\n    this.generationId = generationId\n    this.memberId = memberId\n\n    this.autoCommitInterval = autoCommitInterval\n    this.autoCommitThreshold = autoCommitThreshold\n    this.lastCommit = Date.now()\n\n    this.topics = keys(memberAssignment)\n    this.clearAllOffsets()\n  }\n\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   * @returns {Long}\n   */\n  nextOffset(topic, partition) {\n    if (!this.resolvedOffsets[topic][partition]) {\n      this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition]\n    }\n\n    let offset = this.resolvedOffsets[topic][partition]\n    if (isInvalidOffset(offset)) {\n      offset = '0'\n    }\n\n    return Long.fromValue(offset)\n  }\n\n  /**\n   * @returns {Broker}\n   */\n  async getCoordinator() {\n    if (!this.coordinator.isConnected()) {\n      this.coordinator = await this.cluster.findBroker(this.coordinator)\n    }\n\n    return this.coordinator\n  }\n\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   */\n  resetOffset({ topic, partition }) {\n    this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition]\n  }\n\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   * @param {string} offset\n   */\n  resolveOffset({ topic, partition, offset }) {\n    this.resolvedOffsets[topic][partition] = Long.fromValue(offset)\n      .add(1)\n      .toString()\n  }\n\n  /**\n   * @returns {Long}\n   */\n  countResolvedOffsets() {\n    const committedOffsets = this.committedOffsets()\n\n    const subtractOffsets = (resolvedOffset, committedOffset) => {\n      const resolvedOffsetLong = Long.fromValue(resolvedOffset)\n      return isInvalidOffset(committedOffset)\n        ? resolvedOffsetLong\n        : resolvedOffsetLong.subtract(Long.fromValue(committedOffset))\n    }\n\n    const subtractPartitionOffsets = (resolvedTopicOffsets, committedTopicOffsets) =>\n      keys(resolvedTopicOffsets).map(partition =>\n        subtractOffsets(resolvedTopicOffsets[partition], committedTopicOffsets[partition])\n      )\n\n    const subtractTopicOffsets = topic =>\n      subtractPartitionOffsets(this.resolvedOffsets[topic], committedOffsets[topic])\n\n    const offsetsDiff = this.topics.map(subtractTopicOffsets)\n    return flatten(offsetsDiff).reduce((sum, offset) => sum.add(offset), Long.fromValue(0))\n  }\n\n  /**\n   * @param {string} topic\n   * @param {number} partition\n   */\n  async setDefaultOffset({ topic, partition }) {\n    const { groupId, generationId, memberId } = this\n    const defaultOffset = this.cluster.defaultOffset(this.topicConfigurations[topic])\n    const coordinator = await this.getCoordinator()\n\n    await coordinator.offsetCommit({\n      groupId,\n      memberId,\n      groupGenerationId: generationId,\n      topics: [\n        {\n          topic,\n          partitions: [{ partition, offset: defaultOffset }],\n        },\n      ],\n    })\n\n    this.clearOffsets({ topic, partition })\n  }\n\n  /**\n   * Commit the given offset to the topic/partition. If the consumer isn't assigned to the given\n   * topic/partition this method will be a NO-OP.\n   *\n   * @param {string} topic\n   * @param {number} partition\n   * @param {string} offset\n   */\n  async seek({ topic, partition, offset }) {\n    if (!this.memberAssignment[topic] || !this.memberAssignment[topic].includes(partition)) {\n      return\n    }\n\n    const { groupId, generationId, memberId } = this\n    const coordinator = await this.getCoordinator()\n\n    await coordinator.offsetCommit({\n      groupId,\n      memberId,\n      groupGenerationId: generationId,\n      topics: [\n        {\n          topic,\n          partitions: [{ partition, offset }],\n        },\n      ],\n    })\n\n    this.clearOffsets({ topic, partition })\n  }\n\n  async commitOffsetsIfNecessary() {\n    const now = Date.now()\n\n    const timeoutReached =\n      this.autoCommitInterval != null && now >= this.lastCommit + this.autoCommitInterval\n\n    const thresholdReached =\n      this.autoCommitThreshold != null &&\n      this.countResolvedOffsets().gte(Long.fromValue(this.autoCommitThreshold))\n\n    if (timeoutReached || thresholdReached) {\n      return this.commitOffsets()\n    }\n  }\n\n  /**\n   * Return all locally resolved offsets which are not marked as committed, by topic-partition.\n   * @returns {OffsetsByTopicPartition}\n   *\n   * @typedef {Object} OffsetsByTopicPartition\n   * @property {TopicOffsets[]} topics\n   *\n   * @typedef {Object} TopicOffsets\n   * @property {PartitionOffset[]} partitions\n   *\n   * @typedef {Object} PartitionOffset\n   * @property {string} partition\n   * @property {string} offset\n   */\n  uncommittedOffsets() {\n    const offsets = topic => keys(this.resolvedOffsets[topic])\n    const emptyPartitions = ({ partitions }) => partitions.length > 0\n    const toPartitions = topic => partition => ({\n      partition,\n      offset: this.resolvedOffsets[topic][partition],\n    })\n    const changedOffsets = topic => ({ partition, offset }) => {\n      return (\n        offset !== this.committedOffsets()[topic][partition] &&\n        Long.fromValue(offset).greaterThanOrEqual(0)\n      )\n    }\n\n    // Select and format updated partitions\n    const topicsWithPartitionsToCommit = this.topics\n      .map(topic => ({\n        topic,\n        partitions: offsets(topic)\n          .map(toPartitions(topic))\n          .filter(changedOffsets(topic)),\n      }))\n      .filter(emptyPartitions)\n\n    return { topics: topicsWithPartitionsToCommit }\n  }\n\n  async commitOffsets(offsets = {}) {\n    const { groupId, generationId, memberId } = this\n    const { topics = this.uncommittedOffsets().topics } = offsets\n\n    if (topics.length === 0) {\n      this.lastCommit = Date.now()\n      return\n    }\n\n    const payload = {\n      groupId,\n      memberId,\n      groupGenerationId: generationId,\n      topics,\n    }\n\n    try {\n      const coordinator = await this.getCoordinator()\n      await coordinator.offsetCommit(payload)\n      this.instrumentationEmitter.emit(COMMIT_OFFSETS, payload)\n\n      // Update local reference of committed offsets\n      topics.forEach(({ topic, partitions }) => {\n        const updatedOffsets = partitions.reduce(\n          (obj, { partition, offset }) => assign(obj, { [partition]: offset }),\n          {}\n        )\n        assign(this.committedOffsets()[topic], updatedOffsets)\n      })\n\n      this.lastCommit = Date.now()\n    } catch (e) {\n      // metadata is stale, the coordinator has changed due to a restart or\n      // broker reassignment\n      if (e.type === 'NOT_COORDINATOR_FOR_GROUP') {\n        await this.cluster.refreshMetadata()\n      }\n\n      throw e\n    }\n  }\n\n  async resolveOffsets() {\n    const { groupId } = this\n    const invalidOffset = topic => partition => {\n      return isInvalidOffset(this.committedOffsets()[topic][partition])\n    }\n\n    const pendingPartitions = this.topics\n      .map(topic => ({\n        topic,\n        partitions: this.memberAssignment[topic]\n          .filter(invalidOffset(topic))\n          .map(partition => ({ partition })),\n      }))\n      .filter(t => t.partitions.length > 0)\n\n    if (pendingPartitions.length === 0) {\n      return\n    }\n\n    const coordinator = await this.getCoordinator()\n    const { responses: consumerOffsets } = await coordinator.offsetFetch({\n      groupId,\n      topics: pendingPartitions,\n    })\n\n    const unresolvedPartitions = consumerOffsets.map(({ topic, partitions }) =>\n      assign(\n        {\n          topic,\n          partitions: partitions\n            .filter(({ offset }) => isInvalidOffset(offset))\n            .map(({ partition }) => assign({ partition })),\n        },\n        this.topicConfigurations[topic]\n      )\n    )\n\n    const indexPartitions = (obj, { partition, offset }) => {\n      return assign(obj, { [partition]: offset })\n    }\n\n    const hasUnresolvedPartitions = () =>\n      unresolvedPartitions.filter(t => t.partitions.length > 0).length > 0\n\n    let offsets = consumerOffsets\n    if (hasUnresolvedPartitions()) {\n      const topicOffsets = await this.cluster.fetchTopicsOffset(unresolvedPartitions)\n      offsets = initializeConsumerOffsets(consumerOffsets, topicOffsets)\n    }\n\n    offsets.forEach(({ topic, partitions }) => {\n      this.committedOffsets()[topic] = partitions.reduce(indexPartitions, {\n        ...this.committedOffsets()[topic],\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {string} topic\n   * @param {number} partition\n   */\n  clearOffsets({ topic, partition }) {\n    delete this.committedOffsets()[topic][partition]\n    delete this.resolvedOffsets[topic][partition]\n  }\n\n  /**\n   * @private\n   */\n  clearAllOffsets() {\n    const committedOffsets = this.committedOffsets()\n\n    for (const topic in committedOffsets) {\n      delete committedOffsets[topic]\n    }\n\n    for (const topic of this.topics) {\n      committedOffsets[topic] = {}\n    }\n\n    this.resolvedOffsets = indexTopics(this.topics)\n  }\n\n  committedOffsets() {\n    if (!this[PRIVATE.COMMITTED_OFFSETS]) {\n      this[PRIVATE.COMMITTED_OFFSETS] = this.groupId\n        ? this.cluster.committedOffsets({ groupId: this.groupId })\n        : {}\n    }\n\n    return this[PRIVATE.COMMITTED_OFFSETS]\n  }\n}\n"]},"metadata":{},"sourceType":"script"}