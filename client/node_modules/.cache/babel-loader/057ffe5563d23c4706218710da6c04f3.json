{"ast":null,"code":"const {\n  KafkaJSNonRetriableError\n} = require('../../../errors');\n\nconst toNodeCompatible = crypto => ({\n  randomBytes: size => crypto.getRandomValues(Buffer.allocUnsafe(size))\n});\n\nlet cryptoImplementation = null;\n\nif (global && global.crypto) {\n  cryptoImplementation = global.crypto.randomBytes === undefined ? toNodeCompatible(global.crypto) : global.crypto;\n} else if (global && global.msCrypto) {\n  cryptoImplementation = toNodeCompatible(global.msCrypto);\n} else if (global && !global.crypto) {\n  cryptoImplementation = require('crypto');\n}\n\nconst MAX_BYTES = 65536;\n\nmodule.exports = size => {\n  if (size > MAX_BYTES) {\n    throw new KafkaJSNonRetriableError(`Byte length (${size}) exceeds the max number of bytes of entropy available (${MAX_BYTES})`);\n  }\n\n  if (!cryptoImplementation) {\n    throw new KafkaJSNonRetriableError('No available crypto implementation');\n  }\n\n  return cryptoImplementation.randomBytes(size);\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/producer/partitioners/default/randomBytes.js"],"names":["KafkaJSNonRetriableError","require","toNodeCompatible","crypto","randomBytes","size","getRandomValues","Buffer","allocUnsafe","cryptoImplementation","global","undefined","msCrypto","MAX_BYTES","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAA+BC,OAAO,CAAC,iBAAD,CAA5C;;AAEA,MAAMC,gBAAgB,GAAGC,MAAM,KAAK;AAClCC,EAAAA,WAAW,EAAEC,IAAI,IAAIF,MAAM,CAACG,eAAP,CAAuBC,MAAM,CAACC,WAAP,CAAmBH,IAAnB,CAAvB;AADa,CAAL,CAA/B;;AAIA,IAAII,oBAAoB,GAAG,IAA3B;;AACA,IAAIC,MAAM,IAAIA,MAAM,CAACP,MAArB,EAA6B;AAC3BM,EAAAA,oBAAoB,GAClBC,MAAM,CAACP,MAAP,CAAcC,WAAd,KAA8BO,SAA9B,GAA0CT,gBAAgB,CAACQ,MAAM,CAACP,MAAR,CAA1D,GAA4EO,MAAM,CAACP,MADrF;AAED,CAHD,MAGO,IAAIO,MAAM,IAAIA,MAAM,CAACE,QAArB,EAA+B;AACpCH,EAAAA,oBAAoB,GAAGP,gBAAgB,CAACQ,MAAM,CAACE,QAAR,CAAvC;AACD,CAFM,MAEA,IAAIF,MAAM,IAAI,CAACA,MAAM,CAACP,MAAtB,EAA8B;AACnCM,EAAAA,oBAAoB,GAAGR,OAAO,CAAC,QAAD,CAA9B;AACD;;AAED,MAAMY,SAAS,GAAG,KAAlB;;AAEAC,MAAM,CAACC,OAAP,GAAiBV,IAAI,IAAI;AACvB,MAAIA,IAAI,GAAGQ,SAAX,EAAsB;AACpB,UAAM,IAAIb,wBAAJ,CACH,gBAAeK,IAAK,2DAA0DQ,SAAU,GADrF,CAAN;AAGD;;AAED,MAAI,CAACJ,oBAAL,EAA2B;AACzB,UAAM,IAAIT,wBAAJ,CAA6B,oCAA7B,CAAN;AACD;;AAED,SAAOS,oBAAoB,CAACL,WAArB,CAAiCC,IAAjC,CAAP;AACD,CAZD","sourcesContent":["const { KafkaJSNonRetriableError } = require('../../../errors')\n\nconst toNodeCompatible = crypto => ({\n  randomBytes: size => crypto.getRandomValues(Buffer.allocUnsafe(size)),\n})\n\nlet cryptoImplementation = null\nif (global && global.crypto) {\n  cryptoImplementation =\n    global.crypto.randomBytes === undefined ? toNodeCompatible(global.crypto) : global.crypto\n} else if (global && global.msCrypto) {\n  cryptoImplementation = toNodeCompatible(global.msCrypto)\n} else if (global && !global.crypto) {\n  cryptoImplementation = require('crypto')\n}\n\nconst MAX_BYTES = 65536\n\nmodule.exports = size => {\n  if (size > MAX_BYTES) {\n    throw new KafkaJSNonRetriableError(\n      `Byte length (${size}) exceeds the max number of bytes of entropy available (${MAX_BYTES})`\n    )\n  }\n\n  if (!cryptoImplementation) {\n    throw new KafkaJSNonRetriableError('No available crypto implementation')\n  }\n\n  return cryptoImplementation.randomBytes(size)\n}\n"]},"metadata":{},"sourceType":"script"}