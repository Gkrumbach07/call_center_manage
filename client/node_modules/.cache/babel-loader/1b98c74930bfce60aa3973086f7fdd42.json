{"ast":null,"code":"const Long = require('../../../../utils/long');\n\nconst HeaderDecoder = require('../../header/v0/decoder');\n\nconst TimestampTypes = require('../../../timestampTypes');\n/**\n * v0\n * Record =>\n *   Length => Varint\n *   Attributes => Int8\n *   TimestampDelta => Varlong\n *   OffsetDelta => Varint\n *   Key => varInt|Bytes\n *   Value => varInt|Bytes\n *   Headers => [HeaderKey HeaderValue]\n *     HeaderKey => VarInt|String\n *     HeaderValue => VarInt|Bytes\n */\n\n\nmodule.exports = (decoder, batchContext = {}) => {\n  const {\n    firstOffset,\n    firstTimestamp,\n    magicByte,\n    isControlBatch = false,\n    timestampType,\n    maxTimestamp\n  } = batchContext;\n  const attributes = decoder.readInt8();\n  const timestampDelta = decoder.readVarLong();\n  const timestamp = timestampType === TimestampTypes.LOG_APPEND_TIME && maxTimestamp ? maxTimestamp : Long.fromValue(firstTimestamp).add(timestampDelta).toString();\n  const offsetDelta = decoder.readVarInt();\n  const offset = Long.fromValue(firstOffset).add(offsetDelta).toString();\n  const key = decoder.readVarIntBytes();\n  const value = decoder.readVarIntBytes();\n  const headers = decoder.readVarIntArray(HeaderDecoder).reduce((obj, {\n    key,\n    value\n  }) => ({ ...obj,\n    [key]: value\n  }), {});\n  return {\n    magicByte,\n    attributes,\n    // Record level attributes are presently unused\n    timestamp,\n    offset,\n    key,\n    value,\n    headers,\n    isControlRecord: isControlBatch,\n    batchContext\n  };\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/recordBatch/record/v0/decoder.js"],"names":["Long","require","HeaderDecoder","TimestampTypes","module","exports","decoder","batchContext","firstOffset","firstTimestamp","magicByte","isControlBatch","timestampType","maxTimestamp","attributes","readInt8","timestampDelta","readVarLong","timestamp","LOG_APPEND_TIME","fromValue","add","toString","offsetDelta","readVarInt","offset","key","readVarIntBytes","value","headers","readVarIntArray","reduce","obj","isControlRecord"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,wBAAD,CAApB;;AACA,MAAMC,aAAa,GAAGD,OAAO,CAAC,yBAAD,CAA7B;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,yBAAD,CAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAG,MAAM,CAACC,OAAP,GAAiB,CAACC,OAAD,EAAUC,YAAY,GAAG,EAAzB,KAAgC;AAC/C,QAAM;AACJC,IAAAA,WADI;AAEJC,IAAAA,cAFI;AAGJC,IAAAA,SAHI;AAIJC,IAAAA,cAAc,GAAG,KAJb;AAKJC,IAAAA,aALI;AAMJC,IAAAA;AANI,MAOFN,YAPJ;AAQA,QAAMO,UAAU,GAAGR,OAAO,CAACS,QAAR,EAAnB;AAEA,QAAMC,cAAc,GAAGV,OAAO,CAACW,WAAR,EAAvB;AACA,QAAMC,SAAS,GACbN,aAAa,KAAKT,cAAc,CAACgB,eAAjC,IAAoDN,YAApD,GACIA,YADJ,GAEIb,IAAI,CAACoB,SAAL,CAAeX,cAAf,EACGY,GADH,CACOL,cADP,EAEGM,QAFH,EAHN;AAOA,QAAMC,WAAW,GAAGjB,OAAO,CAACkB,UAAR,EAApB;AACA,QAAMC,MAAM,GAAGzB,IAAI,CAACoB,SAAL,CAAeZ,WAAf,EACZa,GADY,CACRE,WADQ,EAEZD,QAFY,EAAf;AAIA,QAAMI,GAAG,GAAGpB,OAAO,CAACqB,eAAR,EAAZ;AACA,QAAMC,KAAK,GAAGtB,OAAO,CAACqB,eAAR,EAAd;AACA,QAAME,OAAO,GAAGvB,OAAO,CACpBwB,eADa,CACG5B,aADH,EAEb6B,MAFa,CAEN,CAACC,GAAD,EAAM;AAAEN,IAAAA,GAAF;AAAOE,IAAAA;AAAP,GAAN,MAA0B,EAAE,GAAGI,GAAL;AAAU,KAACN,GAAD,GAAOE;AAAjB,GAA1B,CAFM,EAE+C,EAF/C,CAAhB;AAIA,SAAO;AACLlB,IAAAA,SADK;AAELI,IAAAA,UAFK;AAEO;AACZI,IAAAA,SAHK;AAILO,IAAAA,MAJK;AAKLC,IAAAA,GALK;AAMLE,IAAAA,KANK;AAOLC,IAAAA,OAPK;AAQLI,IAAAA,eAAe,EAAEtB,cARZ;AASLJ,IAAAA;AATK,GAAP;AAWD,CAzCD","sourcesContent":["const Long = require('../../../../utils/long')\nconst HeaderDecoder = require('../../header/v0/decoder')\nconst TimestampTypes = require('../../../timestampTypes')\n\n/**\n * v0\n * Record =>\n *   Length => Varint\n *   Attributes => Int8\n *   TimestampDelta => Varlong\n *   OffsetDelta => Varint\n *   Key => varInt|Bytes\n *   Value => varInt|Bytes\n *   Headers => [HeaderKey HeaderValue]\n *     HeaderKey => VarInt|String\n *     HeaderValue => VarInt|Bytes\n */\n\nmodule.exports = (decoder, batchContext = {}) => {\n  const {\n    firstOffset,\n    firstTimestamp,\n    magicByte,\n    isControlBatch = false,\n    timestampType,\n    maxTimestamp,\n  } = batchContext\n  const attributes = decoder.readInt8()\n\n  const timestampDelta = decoder.readVarLong()\n  const timestamp =\n    timestampType === TimestampTypes.LOG_APPEND_TIME && maxTimestamp\n      ? maxTimestamp\n      : Long.fromValue(firstTimestamp)\n          .add(timestampDelta)\n          .toString()\n\n  const offsetDelta = decoder.readVarInt()\n  const offset = Long.fromValue(firstOffset)\n    .add(offsetDelta)\n    .toString()\n\n  const key = decoder.readVarIntBytes()\n  const value = decoder.readVarIntBytes()\n  const headers = decoder\n    .readVarIntArray(HeaderDecoder)\n    .reduce((obj, { key, value }) => ({ ...obj, [key]: value }), {})\n\n  return {\n    magicByte,\n    attributes, // Record level attributes are presently unused\n    timestamp,\n    offset,\n    key,\n    value,\n    headers,\n    isControlRecord: isControlBatch,\n    batchContext,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}