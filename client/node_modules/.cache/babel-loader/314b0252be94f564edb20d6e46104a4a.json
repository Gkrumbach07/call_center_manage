{"ast":null,"code":"const Long = require('../../../../utils/long');\n\nconst Encoder = require('../../../encoder');\n\nconst {\n  Produce: apiKey\n} = require('../../apiKeys');\n\nconst {\n  Types\n} = require('../../../message/compression');\n\nconst Record = require('../../../recordBatch/record/v0');\n\nconst {\n  RecordBatch\n} = require('../../../recordBatch/v0');\n/**\n * Produce Request (Version: 3) => transactional_id acks timeout [topic_data]\n *   transactional_id => NULLABLE_STRING\n *   acks => INT16\n *   timeout => INT32\n *   topic_data => topic [data]\n *     topic => STRING\n *     data => partition record_set\n *       partition => INT32\n *       record_set => RECORDS\n */\n\n/**\n * @param [transactionalId=null] {String} The transactional id or null if the producer is not transactional\n * @param acks {Integer} See producer request v0\n * @param timeout {Integer} See producer request v0\n * @param [compression=CompressionTypes.None] {CompressionTypes}\n * @param topicData {Array}\n */\n\n\nmodule.exports = ({\n  acks,\n  timeout,\n  transactionalId = null,\n  producerId = Long.fromInt(-1),\n  producerEpoch = 0,\n  compression = Types.None,\n  topicData\n}) => ({\n  apiKey,\n  apiVersion: 3,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: async () => {\n    const encodeTopic = topicEncoder(compression);\n    const encodedTopicData = [];\n\n    for (const data of topicData) {\n      encodedTopicData.push(await encodeTopic({ ...data,\n        transactionalId,\n        producerId,\n        producerEpoch\n      }));\n    }\n\n    return new Encoder().writeString(transactionalId).writeInt16(acks).writeInt32(timeout).writeArray(encodedTopicData);\n  }\n});\n\nconst topicEncoder = compression => async ({\n  topic,\n  partitions,\n  transactionalId,\n  producerId,\n  producerEpoch\n}) => {\n  const encodePartitions = partitionsEncoder(compression);\n  const encodedPartitions = [];\n\n  for (const data of partitions) {\n    encodedPartitions.push(await encodePartitions({ ...data,\n      transactionalId,\n      producerId,\n      producerEpoch\n    }));\n  }\n\n  return new Encoder().writeString(topic).writeArray(encodedPartitions);\n};\n\nconst partitionsEncoder = compression => async ({\n  partition,\n  messages,\n  transactionalId,\n  firstSequence,\n  producerId,\n  producerEpoch\n}) => {\n  const dateNow = Date.now();\n  const messageTimestamps = messages.map(m => m.timestamp).filter(timestamp => timestamp != null).sort();\n  const timestamps = messageTimestamps.length === 0 ? [dateNow] : messageTimestamps;\n  const firstTimestamp = timestamps[0];\n  const maxTimestamp = timestamps[timestamps.length - 1];\n  const records = messages.map((message, i) => Record({ ...message,\n    offsetDelta: i,\n    timestampDelta: (message.timestamp || dateNow) - firstTimestamp\n  }));\n  const recordBatch = await RecordBatch({\n    compression,\n    records,\n    firstTimestamp,\n    maxTimestamp,\n    producerId,\n    producerEpoch,\n    firstSequence,\n    transactional: !!transactionalId,\n    lastOffsetDelta: records.length - 1\n  });\n  return new Encoder().writeInt32(partition).writeInt32(recordBatch.size()).writeEncoder(recordBatch);\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/requests/produce/v3/request.js"],"names":["Long","require","Encoder","Produce","apiKey","Types","Record","RecordBatch","module","exports","acks","timeout","transactionalId","producerId","fromInt","producerEpoch","compression","None","topicData","apiVersion","apiName","expectResponse","encode","encodeTopic","topicEncoder","encodedTopicData","data","push","writeString","writeInt16","writeInt32","writeArray","topic","partitions","encodePartitions","partitionsEncoder","encodedPartitions","partition","messages","firstSequence","dateNow","Date","now","messageTimestamps","map","m","timestamp","filter","sort","timestamps","length","firstTimestamp","maxTimestamp","records","message","i","offsetDelta","timestampDelta","recordBatch","transactional","lastOffsetDelta","size","writeEncoder"],"mappings":"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","sourcesContent":["const Long = require('../../../../utils/long')\nconst Encoder = require('../../../encoder')\nconst { Produce: apiKey } = require('../../apiKeys')\nconst { Types } = require('../../../message/compression')\nconst Record = require('../../../recordBatch/record/v0')\nconst { RecordBatch } = require('../../../recordBatch/v0')\n\n/**\n * Produce Request (Version: 3) => transactional_id acks timeout [topic_data]\n *   transactional_id => NULLABLE_STRING\n *   acks => INT16\n *   timeout => INT32\n *   topic_data => topic [data]\n *     topic => STRING\n *     data => partition record_set\n *       partition => INT32\n *       record_set => RECORDS\n */\n\n/**\n * @param [transactionalId=null] {String} The transactional id or null if the producer is not transactional\n * @param acks {Integer} See producer request v0\n * @param timeout {Integer} See producer request v0\n * @param [compression=CompressionTypes.None] {CompressionTypes}\n * @param topicData {Array}\n */\nmodule.exports = ({\n  acks,\n  timeout,\n  transactionalId = null,\n  producerId = Long.fromInt(-1),\n  producerEpoch = 0,\n  compression = Types.None,\n  topicData,\n}) => ({\n  apiKey,\n  apiVersion: 3,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: async () => {\n    const encodeTopic = topicEncoder(compression)\n    const encodedTopicData = []\n\n    for (const data of topicData) {\n      encodedTopicData.push(\n        await encodeTopic({ ...data, transactionalId, producerId, producerEpoch })\n      )\n    }\n\n    return new Encoder()\n      .writeString(transactionalId)\n      .writeInt16(acks)\n      .writeInt32(timeout)\n      .writeArray(encodedTopicData)\n  },\n})\n\nconst topicEncoder = compression => async ({\n  topic,\n  partitions,\n  transactionalId,\n  producerId,\n  producerEpoch,\n}) => {\n  const encodePartitions = partitionsEncoder(compression)\n  const encodedPartitions = []\n\n  for (const data of partitions) {\n    encodedPartitions.push(\n      await encodePartitions({ ...data, transactionalId, producerId, producerEpoch })\n    )\n  }\n\n  return new Encoder().writeString(topic).writeArray(encodedPartitions)\n}\n\nconst partitionsEncoder = compression => async ({\n  partition,\n  messages,\n  transactionalId,\n  firstSequence,\n  producerId,\n  producerEpoch,\n}) => {\n  const dateNow = Date.now()\n  const messageTimestamps = messages\n    .map(m => m.timestamp)\n    .filter(timestamp => timestamp != null)\n    .sort()\n\n  const timestamps = messageTimestamps.length === 0 ? [dateNow] : messageTimestamps\n  const firstTimestamp = timestamps[0]\n  const maxTimestamp = timestamps[timestamps.length - 1]\n\n  const records = messages.map((message, i) =>\n    Record({\n      ...message,\n      offsetDelta: i,\n      timestampDelta: (message.timestamp || dateNow) - firstTimestamp,\n    })\n  )\n\n  const recordBatch = await RecordBatch({\n    compression,\n    records,\n    firstTimestamp,\n    maxTimestamp,\n    producerId,\n    producerEpoch,\n    firstSequence,\n    transactional: !!transactionalId,\n    lastOffsetDelta: records.length - 1,\n  })\n\n  return new Encoder()\n    .writeInt32(partition)\n    .writeInt32(recordBatch.size())\n    .writeEncoder(recordBatch)\n}\n"]},"metadata":{},"sourceType":"script"}