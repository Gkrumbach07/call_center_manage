{"ast":null,"code":"const Decoder = require('../../../decoder');\n\nconst {\n  KafkaJSOffsetOutOfRange\n} = require('../../../../errors');\n\nconst {\n  failure,\n  createErrorFromCode,\n  errorCodes\n} = require('../../../error');\n\nconst flatten = require('../../../../utils/flatten');\n\nconst MessageSetDecoder = require('../../../messageSet/decoder');\n/**\n * Fetch Response (Version: 0) => [responses]\n *   responses => topic [partition_responses]\n *     topic => STRING\n *     partition_responses => partition_header record_set\n *       partition_header => partition error_code high_watermark\n *         partition => INT32\n *         error_code => INT16\n *         high_watermark => INT64\n *       record_set => RECORDS\n */\n\n\nconst decodePartition = async decoder => ({\n  partition: decoder.readInt32(),\n  errorCode: decoder.readInt16(),\n  highWatermark: decoder.readInt64().toString(),\n  messages: await MessageSetDecoder(decoder)\n});\n\nconst decodeResponse = async decoder => ({\n  topicName: decoder.readString(),\n  partitions: await decoder.readArrayAsync(decodePartition)\n});\n\nconst decode = async rawData => {\n  const decoder = new Decoder(rawData);\n  const responses = await decoder.readArrayAsync(decodeResponse);\n  return {\n    responses\n  };\n};\n\nconst {\n  code: OFFSET_OUT_OF_RANGE_ERROR_CODE\n} = errorCodes.find(e => e.type === 'OFFSET_OUT_OF_RANGE');\n\nconst parse = async data => {\n  const partitionsWithError = data.responses.map(({\n    topicName,\n    partitions\n  }) => {\n    return partitions.filter(partition => failure(partition.errorCode)).map(partition => Object.assign({}, partition, {\n      topic: topicName\n    }));\n  });\n  const errors = flatten(partitionsWithError);\n\n  if (errors.length > 0) {\n    const {\n      errorCode,\n      topic,\n      partition\n    } = errors[0];\n\n    if (errorCode === OFFSET_OUT_OF_RANGE_ERROR_CODE) {\n      throw new KafkaJSOffsetOutOfRange(createErrorFromCode(errorCode), {\n        topic,\n        partition\n      });\n    }\n\n    throw createErrorFromCode(errorCode);\n  }\n\n  return data;\n};\n\nmodule.exports = {\n  decode,\n  parse\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/requests/fetch/v0/response.js"],"names":["Decoder","require","KafkaJSOffsetOutOfRange","failure","createErrorFromCode","errorCodes","flatten","MessageSetDecoder","decodePartition","decoder","partition","readInt32","errorCode","readInt16","highWatermark","readInt64","toString","messages","decodeResponse","topicName","readString","partitions","readArrayAsync","decode","rawData","responses","code","OFFSET_OUT_OF_RANGE_ERROR_CODE","find","e","type","parse","data","partitionsWithError","map","filter","Object","assign","topic","errors","length","module","exports"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAA8BD,OAAO,CAAC,oBAAD,CAA3C;;AACA,MAAM;AAAEE,EAAAA,OAAF;AAAWC,EAAAA,mBAAX;AAAgCC,EAAAA;AAAhC,IAA+CJ,OAAO,CAAC,gBAAD,CAA5D;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,2BAAD,CAAvB;;AACA,MAAMM,iBAAiB,GAAGN,OAAO,CAAC,6BAAD,CAAjC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMO,eAAe,GAAG,MAAMC,OAAN,KAAkB;AACxCC,EAAAA,SAAS,EAAED,OAAO,CAACE,SAAR,EAD6B;AAExCC,EAAAA,SAAS,EAAEH,OAAO,CAACI,SAAR,EAF6B;AAGxCC,EAAAA,aAAa,EAAEL,OAAO,CAACM,SAAR,GAAoBC,QAApB,EAHyB;AAIxCC,EAAAA,QAAQ,EAAE,MAAMV,iBAAiB,CAACE,OAAD;AAJO,CAAlB,CAAxB;;AAOA,MAAMS,cAAc,GAAG,MAAMT,OAAN,KAAkB;AACvCU,EAAAA,SAAS,EAAEV,OAAO,CAACW,UAAR,EAD4B;AAEvCC,EAAAA,UAAU,EAAE,MAAMZ,OAAO,CAACa,cAAR,CAAuBd,eAAvB;AAFqB,CAAlB,CAAvB;;AAKA,MAAMe,MAAM,GAAG,MAAMC,OAAN,IAAiB;AAC9B,QAAMf,OAAO,GAAG,IAAIT,OAAJ,CAAYwB,OAAZ,CAAhB;AACA,QAAMC,SAAS,GAAG,MAAMhB,OAAO,CAACa,cAAR,CAAuBJ,cAAvB,CAAxB;AAEA,SAAO;AACLO,IAAAA;AADK,GAAP;AAGD,CAPD;;AASA,MAAM;AAAEC,EAAAA,IAAI,EAAEC;AAAR,IAA2CtB,UAAU,CAACuB,IAAX,CAC/CC,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAW,qBAD+B,CAAjD;;AAIA,MAAMC,KAAK,GAAG,MAAMC,IAAN,IAAc;AAC1B,QAAMC,mBAAmB,GAAGD,IAAI,CAACP,SAAL,CAAeS,GAAf,CAAmB,CAAC;AAAEf,IAAAA,SAAF;AAAaE,IAAAA;AAAb,GAAD,KAA+B;AAC5E,WAAOA,UAAU,CACdc,MADI,CACGzB,SAAS,IAAIP,OAAO,CAACO,SAAS,CAACE,SAAX,CADvB,EAEJsB,GAFI,CAEAxB,SAAS,IAAI0B,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB3B,SAAlB,EAA6B;AAAE4B,MAAAA,KAAK,EAAEnB;AAAT,KAA7B,CAFb,CAAP;AAGD,GAJ2B,CAA5B;AAMA,QAAMoB,MAAM,GAAGjC,OAAO,CAAC2B,mBAAD,CAAtB;;AACA,MAAIM,MAAM,CAACC,MAAP,GAAgB,CAApB,EAAuB;AACrB,UAAM;AAAE5B,MAAAA,SAAF;AAAa0B,MAAAA,KAAb;AAAoB5B,MAAAA;AAApB,QAAkC6B,MAAM,CAAC,CAAD,CAA9C;;AACA,QAAI3B,SAAS,KAAKe,8BAAlB,EAAkD;AAChD,YAAM,IAAIzB,uBAAJ,CAA4BE,mBAAmB,CAACQ,SAAD,CAA/C,EAA4D;AAAE0B,QAAAA,KAAF;AAAS5B,QAAAA;AAAT,OAA5D,CAAN;AACD;;AAED,UAAMN,mBAAmB,CAACQ,SAAD,CAAzB;AACD;;AAED,SAAOoB,IAAP;AACD,CAlBD;;AAoBAS,MAAM,CAACC,OAAP,GAAiB;AACfnB,EAAAA,MADe;AAEfQ,EAAAA;AAFe,CAAjB","sourcesContent":["const Decoder = require('../../../decoder')\nconst { KafkaJSOffsetOutOfRange } = require('../../../../errors')\nconst { failure, createErrorFromCode, errorCodes } = require('../../../error')\nconst flatten = require('../../../../utils/flatten')\nconst MessageSetDecoder = require('../../../messageSet/decoder')\n\n/**\n * Fetch Response (Version: 0) => [responses]\n *   responses => topic [partition_responses]\n *     topic => STRING\n *     partition_responses => partition_header record_set\n *       partition_header => partition error_code high_watermark\n *         partition => INT32\n *         error_code => INT16\n *         high_watermark => INT64\n *       record_set => RECORDS\n */\n\nconst decodePartition = async decoder => ({\n  partition: decoder.readInt32(),\n  errorCode: decoder.readInt16(),\n  highWatermark: decoder.readInt64().toString(),\n  messages: await MessageSetDecoder(decoder),\n})\n\nconst decodeResponse = async decoder => ({\n  topicName: decoder.readString(),\n  partitions: await decoder.readArrayAsync(decodePartition),\n})\n\nconst decode = async rawData => {\n  const decoder = new Decoder(rawData)\n  const responses = await decoder.readArrayAsync(decodeResponse)\n\n  return {\n    responses,\n  }\n}\n\nconst { code: OFFSET_OUT_OF_RANGE_ERROR_CODE } = errorCodes.find(\n  e => e.type === 'OFFSET_OUT_OF_RANGE'\n)\n\nconst parse = async data => {\n  const partitionsWithError = data.responses.map(({ topicName, partitions }) => {\n    return partitions\n      .filter(partition => failure(partition.errorCode))\n      .map(partition => Object.assign({}, partition, { topic: topicName }))\n  })\n\n  const errors = flatten(partitionsWithError)\n  if (errors.length > 0) {\n    const { errorCode, topic, partition } = errors[0]\n    if (errorCode === OFFSET_OUT_OF_RANGE_ERROR_CODE) {\n      throw new KafkaJSOffsetOutOfRange(createErrorFromCode(errorCode), { topic, partition })\n    }\n\n    throw createErrorFromCode(errorCode)\n  }\n\n  return data\n}\n\nmodule.exports = {\n  decode,\n  parse,\n}\n"]},"metadata":{},"sourceType":"script"}