{"ast":null,"code":"const Encoder = require('../encoder');\n\nconst MessageProtocol = require('../message');\n\nconst {\n  Types\n} = require('../message/compression');\n/**\n * MessageSet => [Offset MessageSize Message]\n *  Offset => int64\n *  MessageSize => int32\n *  Message => Bytes\n */\n\n/**\n * [\n *   { key: \"<value>\", value: \"<value>\" },\n *   { key: \"<value>\", value: \"<value>\" },\n * ]\n */\n\n\nmodule.exports = ({\n  messageVersion = 0,\n  compression,\n  entries\n}) => {\n  const isCompressed = compression !== Types.None;\n  const Message = MessageProtocol({\n    version: messageVersion\n  });\n  const encoder = new Encoder(); // Messages in a message set are __not__ encoded as an array.\n  // They are written in sequence.\n  // https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets\n\n  entries.forEach((entry, i) => {\n    const message = Message(entry); // This is the offset used in kafka as the log sequence number.\n    // When the producer is sending non compressed messages, it can set the offsets to anything\n    // When the producer is sending compressed messages, to avoid server side recompression, each compressed message\n    // should have offset starting from 0 and increasing by one for each inner message in the compressed message\n\n    encoder.writeInt64(isCompressed ? i : -1);\n    encoder.writeInt32(message.size());\n    encoder.writeEncoder(message);\n  });\n  return encoder;\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/messageSet/index.js"],"names":["Encoder","require","MessageProtocol","Types","module","exports","messageVersion","compression","entries","isCompressed","None","Message","version","encoder","forEach","entry","i","message","writeInt64","writeInt32","size","writeEncoder"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMC,eAAe,GAAGD,OAAO,CAAC,YAAD,CAA/B;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAYF,OAAO,CAAC,wBAAD,CAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAG,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,cAAc,GAAG,CAAnB;AAAsBC,EAAAA,WAAtB;AAAmCC,EAAAA;AAAnC,CAAD,KAAkD;AACjE,QAAMC,YAAY,GAAGF,WAAW,KAAKJ,KAAK,CAACO,IAA3C;AACA,QAAMC,OAAO,GAAGT,eAAe,CAAC;AAAEU,IAAAA,OAAO,EAAEN;AAAX,GAAD,CAA/B;AACA,QAAMO,OAAO,GAAG,IAAIb,OAAJ,EAAhB,CAHiE,CAKjE;AACA;AACA;;AAEAQ,EAAAA,OAAO,CAACM,OAAR,CAAgB,CAACC,KAAD,EAAQC,CAAR,KAAc;AAC5B,UAAMC,OAAO,GAAGN,OAAO,CAACI,KAAD,CAAvB,CAD4B,CAG5B;AACA;AACA;AACA;;AACAF,IAAAA,OAAO,CAACK,UAAR,CAAmBT,YAAY,GAAGO,CAAH,GAAO,CAAC,CAAvC;AACAH,IAAAA,OAAO,CAACM,UAAR,CAAmBF,OAAO,CAACG,IAAR,EAAnB;AAEAP,IAAAA,OAAO,CAACQ,YAAR,CAAqBJ,OAArB;AACD,GAXD;AAaA,SAAOJ,OAAP;AACD,CAvBD","sourcesContent":["const Encoder = require('../encoder')\nconst MessageProtocol = require('../message')\nconst { Types } = require('../message/compression')\n\n/**\n * MessageSet => [Offset MessageSize Message]\n *  Offset => int64\n *  MessageSize => int32\n *  Message => Bytes\n */\n\n/**\n * [\n *   { key: \"<value>\", value: \"<value>\" },\n *   { key: \"<value>\", value: \"<value>\" },\n * ]\n */\nmodule.exports = ({ messageVersion = 0, compression, entries }) => {\n  const isCompressed = compression !== Types.None\n  const Message = MessageProtocol({ version: messageVersion })\n  const encoder = new Encoder()\n\n  // Messages in a message set are __not__ encoded as an array.\n  // They are written in sequence.\n  // https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets\n\n  entries.forEach((entry, i) => {\n    const message = Message(entry)\n\n    // This is the offset used in kafka as the log sequence number.\n    // When the producer is sending non compressed messages, it can set the offsets to anything\n    // When the producer is sending compressed messages, to avoid server side recompression, each compressed message\n    // should have offset starting from 0 and increasing by one for each inner message in the compressed message\n    encoder.writeInt64(isCompressed ? i : -1)\n    encoder.writeInt32(message.size())\n\n    encoder.writeEncoder(message)\n  })\n\n  return encoder\n}\n"]},"metadata":{},"sourceType":"script"}