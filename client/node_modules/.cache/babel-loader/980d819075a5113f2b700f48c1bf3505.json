{"ast":null,"code":"const Encoder = require('../../../encoder');\n\nconst {\n  Produce: apiKey\n} = require('../../apiKeys');\n\nconst MessageSet = require('../../../messageSet');\n\nconst {\n  Types,\n  lookupCodec\n} = require('../../../message/compression'); // Produce Request on or after v2 indicates the client can parse the timestamp field\n// in the produce Response.\n\n\nmodule.exports = ({\n  acks,\n  timeout,\n  compression = Types.None,\n  topicData\n}) => ({\n  apiKey,\n  apiVersion: 2,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: async () => {\n    const encodeTopic = topicEncoder(compression);\n    const encodedTopicData = [];\n\n    for (const data of topicData) {\n      encodedTopicData.push(await encodeTopic(data));\n    }\n\n    return new Encoder().writeInt16(acks).writeInt32(timeout).writeArray(encodedTopicData);\n  }\n});\n\nconst topicEncoder = compression => {\n  const encodePartitions = partitionsEncoder(compression);\n  return async ({\n    topic,\n    partitions\n  }) => {\n    const encodedPartitions = [];\n\n    for (const data of partitions) {\n      encodedPartitions.push(await encodePartitions(data));\n    }\n\n    return new Encoder().writeString(topic).writeArray(encodedPartitions);\n  };\n};\n\nconst partitionsEncoder = compression => async ({\n  partition,\n  messages\n}) => {\n  const messageSet = MessageSet({\n    messageVersion: 1,\n    compression,\n    entries: messages\n  });\n\n  if (compression === Types.None) {\n    return new Encoder().writeInt32(partition).writeInt32(messageSet.size()).writeEncoder(messageSet);\n  }\n\n  const timestamp = messages[0].timestamp || Date.now();\n  const codec = lookupCodec(compression);\n  const compressedValue = await codec.compress(messageSet);\n  const compressedMessageSet = MessageSet({\n    messageVersion: 1,\n    entries: [{\n      compression,\n      timestamp,\n      value: compressedValue\n    }]\n  });\n  return new Encoder().writeInt32(partition).writeInt32(compressedMessageSet.size()).writeEncoder(compressedMessageSet);\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/requests/produce/v2/request.js"],"names":["Encoder","require","Produce","apiKey","MessageSet","Types","lookupCodec","module","exports","acks","timeout","compression","None","topicData","apiVersion","apiName","expectResponse","encode","encodeTopic","topicEncoder","encodedTopicData","data","push","writeInt16","writeInt32","writeArray","encodePartitions","partitionsEncoder","topic","partitions","encodedPartitions","writeString","partition","messages","messageSet","messageVersion","entries","size","writeEncoder","timestamp","Date","now","codec","compressedValue","compress","compressedMessageSet","value"],"mappings":"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","sourcesContent":["const Encoder = require('../../../encoder')\nconst { Produce: apiKey } = require('../../apiKeys')\nconst MessageSet = require('../../../messageSet')\nconst { Types, lookupCodec } = require('../../../message/compression')\n\n// Produce Request on or after v2 indicates the client can parse the timestamp field\n// in the produce Response.\n\nmodule.exports = ({ acks, timeout, compression = Types.None, topicData }) => ({\n  apiKey,\n  apiVersion: 2,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: async () => {\n    const encodeTopic = topicEncoder(compression)\n    const encodedTopicData = []\n\n    for (const data of topicData) {\n      encodedTopicData.push(await encodeTopic(data))\n    }\n\n    return new Encoder()\n      .writeInt16(acks)\n      .writeInt32(timeout)\n      .writeArray(encodedTopicData)\n  },\n})\n\nconst topicEncoder = compression => {\n  const encodePartitions = partitionsEncoder(compression)\n\n  return async ({ topic, partitions }) => {\n    const encodedPartitions = []\n\n    for (const data of partitions) {\n      encodedPartitions.push(await encodePartitions(data))\n    }\n\n    return new Encoder().writeString(topic).writeArray(encodedPartitions)\n  }\n}\n\nconst partitionsEncoder = compression => async ({ partition, messages }) => {\n  const messageSet = MessageSet({ messageVersion: 1, compression, entries: messages })\n\n  if (compression === Types.None) {\n    return new Encoder()\n      .writeInt32(partition)\n      .writeInt32(messageSet.size())\n      .writeEncoder(messageSet)\n  }\n\n  const timestamp = messages[0].timestamp || Date.now()\n\n  const codec = lookupCodec(compression)\n  const compressedValue = await codec.compress(messageSet)\n  const compressedMessageSet = MessageSet({\n    messageVersion: 1,\n    entries: [{ compression, timestamp, value: compressedValue }],\n  })\n\n  return new Encoder()\n    .writeInt32(partition)\n    .writeInt32(compressedMessageSet.size())\n    .writeEncoder(compressedMessageSet)\n}\n"]},"metadata":{},"sourceType":"script"}