{"ast":null,"code":"const Long = require('../utils/long');\n\nconst ABORTED_MESSAGE_KEY = Buffer.from([0, 0, 0, 0]);\n\nconst isAbortMarker = ({\n  key\n}) => {\n  // Handle null/undefined keys.\n  if (!key) return false; // Cast key to buffer defensively\n\n  return Buffer.from(key).equals(ABORTED_MESSAGE_KEY);\n};\n/**\n * Remove messages marked as aborted according to the aborted transactions list.\n *\n * Start of an aborted transaction is determined by message offset.\n * End of an aborted transaction is determined by control messages.\n * @param {Message[]} messages\n * @param {Transaction[]} [abortedTransactions]\n * @returns {Message[]} Messages which did not participate in an aborted transaction\n *\n * @typedef {object} Message\n * @param {Buffer} key\n * @param {lastOffset} key  Int64\n * @param {RecordBatch}  batchContext\n *\n * @typedef {object} Transaction\n * @param {string} firstOffset  Int64\n * @param {string} producerId  Int64\n *\n * @typedef {object} RecordBatch\n * @param {string}  producerId  Int64\n * @param {boolean}  inTransaction\n */\n\n\nmodule.exports = ({\n  messages,\n  abortedTransactions\n}) => {\n  const currentAbortedTransactions = new Map();\n\n  if (!abortedTransactions || !abortedTransactions.length) {\n    return messages;\n  }\n\n  const remainingAbortedTransactions = [...abortedTransactions];\n  return messages.filter(message => {\n    // If the message offset is GTE the first offset of the next aborted transaction\n    // then we have stepped into an aborted transaction.\n    if (remainingAbortedTransactions.length && Long.fromValue(message.offset).gte(remainingAbortedTransactions[0].firstOffset)) {\n      const {\n        producerId\n      } = remainingAbortedTransactions.shift();\n      currentAbortedTransactions.set(producerId, true);\n    }\n\n    const {\n      producerId,\n      inTransaction\n    } = message.batchContext;\n\n    if (isAbortMarker(message)) {\n      // Transaction is over, we no longer need to ignore messages from this producer\n      currentAbortedTransactions.delete(producerId);\n    } else if (currentAbortedTransactions.has(producerId) && inTransaction) {\n      return false;\n    }\n\n    return true;\n  });\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/consumer/filterAbortedMessages.js"],"names":["Long","require","ABORTED_MESSAGE_KEY","Buffer","from","isAbortMarker","key","equals","module","exports","messages","abortedTransactions","currentAbortedTransactions","Map","length","remainingAbortedTransactions","filter","message","fromValue","offset","gte","firstOffset","producerId","shift","set","inTransaction","batchContext","delete","has"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,eAAD,CAApB;;AACA,MAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAP,CAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAZ,CAA5B;;AAEA,MAAMC,aAAa,GAAG,CAAC;AAAEC,EAAAA;AAAF,CAAD,KAAa;AACjC;AACA,MAAI,CAACA,GAAL,EAAU,OAAO,KAAP,CAFuB,CAGjC;;AACA,SAAOH,MAAM,CAACC,IAAP,CAAYE,GAAZ,EAAiBC,MAAjB,CAAwBL,mBAAxB,CAAP;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAM,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,CAAD,KAAuC;AACtD,QAAMC,0BAA0B,GAAG,IAAIC,GAAJ,EAAnC;;AAEA,MAAI,CAACF,mBAAD,IAAwB,CAACA,mBAAmB,CAACG,MAAjD,EAAyD;AACvD,WAAOJ,QAAP;AACD;;AAED,QAAMK,4BAA4B,GAAG,CAAC,GAAGJ,mBAAJ,CAArC;AAEA,SAAOD,QAAQ,CAACM,MAAT,CAAgBC,OAAO,IAAI;AAChC;AACA;AACA,QACEF,4BAA4B,CAACD,MAA7B,IACAd,IAAI,CAACkB,SAAL,CAAeD,OAAO,CAACE,MAAvB,EAA+BC,GAA/B,CAAmCL,4BAA4B,CAAC,CAAD,CAA5B,CAAgCM,WAAnE,CAFF,EAGE;AACA,YAAM;AAAEC,QAAAA;AAAF,UAAiBP,4BAA4B,CAACQ,KAA7B,EAAvB;AACAX,MAAAA,0BAA0B,CAACY,GAA3B,CAA+BF,UAA/B,EAA2C,IAA3C;AACD;;AAED,UAAM;AAAEA,MAAAA,UAAF;AAAcG,MAAAA;AAAd,QAAgCR,OAAO,CAACS,YAA9C;;AAEA,QAAIrB,aAAa,CAACY,OAAD,CAAjB,EAA4B;AAC1B;AACAL,MAAAA,0BAA0B,CAACe,MAA3B,CAAkCL,UAAlC;AACD,KAHD,MAGO,IAAIV,0BAA0B,CAACgB,GAA3B,CAA+BN,UAA/B,KAA8CG,aAAlD,EAAiE;AACtE,aAAO,KAAP;AACD;;AAED,WAAO,IAAP;AACD,GArBM,CAAP;AAsBD,CA/BD","sourcesContent":["const Long = require('../utils/long')\nconst ABORTED_MESSAGE_KEY = Buffer.from([0, 0, 0, 0])\n\nconst isAbortMarker = ({ key }) => {\n  // Handle null/undefined keys.\n  if (!key) return false\n  // Cast key to buffer defensively\n  return Buffer.from(key).equals(ABORTED_MESSAGE_KEY)\n}\n\n/**\n * Remove messages marked as aborted according to the aborted transactions list.\n *\n * Start of an aborted transaction is determined by message offset.\n * End of an aborted transaction is determined by control messages.\n * @param {Message[]} messages\n * @param {Transaction[]} [abortedTransactions]\n * @returns {Message[]} Messages which did not participate in an aborted transaction\n *\n * @typedef {object} Message\n * @param {Buffer} key\n * @param {lastOffset} key  Int64\n * @param {RecordBatch}  batchContext\n *\n * @typedef {object} Transaction\n * @param {string} firstOffset  Int64\n * @param {string} producerId  Int64\n *\n * @typedef {object} RecordBatch\n * @param {string}  producerId  Int64\n * @param {boolean}  inTransaction\n */\nmodule.exports = ({ messages, abortedTransactions }) => {\n  const currentAbortedTransactions = new Map()\n\n  if (!abortedTransactions || !abortedTransactions.length) {\n    return messages\n  }\n\n  const remainingAbortedTransactions = [...abortedTransactions]\n\n  return messages.filter(message => {\n    // If the message offset is GTE the first offset of the next aborted transaction\n    // then we have stepped into an aborted transaction.\n    if (\n      remainingAbortedTransactions.length &&\n      Long.fromValue(message.offset).gte(remainingAbortedTransactions[0].firstOffset)\n    ) {\n      const { producerId } = remainingAbortedTransactions.shift()\n      currentAbortedTransactions.set(producerId, true)\n    }\n\n    const { producerId, inTransaction } = message.batchContext\n\n    if (isAbortMarker(message)) {\n      // Transaction is over, we no longer need to ignore messages from this producer\n      currentAbortedTransactions.delete(producerId)\n    } else if (currentAbortedTransactions.has(producerId) && inTransaction) {\n      return false\n    }\n\n    return true\n  })\n}\n"]},"metadata":{},"sourceType":"script"}