{"ast":null,"code":"const randomBytes = require('./randomBytes'); // Based on the java client 0.10.2\n// https://github.com/apache/kafka/blob/0.10.2/clients/src/main/java/org/apache/kafka/clients/producer/internals/DefaultPartitioner.java\n\n/**\n * A cheap way to deterministically convert a number to a positive value. When the input is\n * positive, the original value is returned. When the input number is negative, the returned\n * positive value is the original value bit AND against 0x7fffffff which is not its absolutely\n * value.\n */\n\n\nconst toPositive = x => x & 0x7fffffff;\n/**\n * The default partitioning strategy:\n *  - If a partition is specified in the message, use it\n *  - If no partition is specified but a key is present choose a partition based on a hash of the key\n *  - If no partition or key is present choose a partition in a round-robin fashion\n */\n\n\nmodule.exports = murmur2 => () => {\n  let counter = randomBytes(32).readUInt32BE(0);\n  return ({\n    topic,\n    partitionMetadata,\n    message\n  }) => {\n    const numPartitions = partitionMetadata.length;\n    const availablePartitions = partitionMetadata.filter(p => p.leader >= 0);\n    const numAvailablePartitions = availablePartitions.length;\n\n    if (message.partition !== null && message.partition !== undefined) {\n      return message.partition;\n    }\n\n    if (message.key !== null && message.key !== undefined) {\n      return toPositive(murmur2(message.key)) % numPartitions;\n    }\n\n    if (numAvailablePartitions > 0) {\n      const i = toPositive(++counter) % numAvailablePartitions;\n      return availablePartitions[i].partitionId;\n    } // no partitions are available, give a non-available partition\n\n\n    return toPositive(++counter) % numPartitions;\n  };\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/producer/partitioners/default/partitioner.js"],"names":["randomBytes","require","toPositive","x","module","exports","murmur2","counter","readUInt32BE","topic","partitionMetadata","message","numPartitions","length","availablePartitions","filter","p","leader","numAvailablePartitions","partition","undefined","key","i","partitionId"],"mappings":"AAAA,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAA3B,C,CAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,UAAU,GAAGC,CAAC,IAAIA,CAAC,GAAG,UAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiBC,OAAO,IAAI,MAAM;AAChC,MAAIC,OAAO,GAAGP,WAAW,CAAC,EAAD,CAAX,CAAgBQ,YAAhB,CAA6B,CAA7B,CAAd;AAEA,SAAO,CAAC;AAAEC,IAAAA,KAAF;AAASC,IAAAA,iBAAT;AAA4BC,IAAAA;AAA5B,GAAD,KAA2C;AAChD,UAAMC,aAAa,GAAGF,iBAAiB,CAACG,MAAxC;AACA,UAAMC,mBAAmB,GAAGJ,iBAAiB,CAACK,MAAlB,CAAyBC,CAAC,IAAIA,CAAC,CAACC,MAAF,IAAY,CAA1C,CAA5B;AACA,UAAMC,sBAAsB,GAAGJ,mBAAmB,CAACD,MAAnD;;AAEA,QAAIF,OAAO,CAACQ,SAAR,KAAsB,IAAtB,IAA8BR,OAAO,CAACQ,SAAR,KAAsBC,SAAxD,EAAmE;AACjE,aAAOT,OAAO,CAACQ,SAAf;AACD;;AAED,QAAIR,OAAO,CAACU,GAAR,KAAgB,IAAhB,IAAwBV,OAAO,CAACU,GAAR,KAAgBD,SAA5C,EAAuD;AACrD,aAAOlB,UAAU,CAACI,OAAO,CAACK,OAAO,CAACU,GAAT,CAAR,CAAV,GAAmCT,aAA1C;AACD;;AAED,QAAIM,sBAAsB,GAAG,CAA7B,EAAgC;AAC9B,YAAMI,CAAC,GAAGpB,UAAU,CAAC,EAAEK,OAAH,CAAV,GAAwBW,sBAAlC;AACA,aAAOJ,mBAAmB,CAACQ,CAAD,CAAnB,CAAuBC,WAA9B;AACD,KAhB+C,CAkBhD;;;AACA,WAAOrB,UAAU,CAAC,EAAEK,OAAH,CAAV,GAAwBK,aAA/B;AACD,GApBD;AAqBD,CAxBD","sourcesContent":["const randomBytes = require('./randomBytes')\n\n// Based on the java client 0.10.2\n// https://github.com/apache/kafka/blob/0.10.2/clients/src/main/java/org/apache/kafka/clients/producer/internals/DefaultPartitioner.java\n\n/**\n * A cheap way to deterministically convert a number to a positive value. When the input is\n * positive, the original value is returned. When the input number is negative, the returned\n * positive value is the original value bit AND against 0x7fffffff which is not its absolutely\n * value.\n */\nconst toPositive = x => x & 0x7fffffff\n\n/**\n * The default partitioning strategy:\n *  - If a partition is specified in the message, use it\n *  - If no partition is specified but a key is present choose a partition based on a hash of the key\n *  - If no partition or key is present choose a partition in a round-robin fashion\n */\nmodule.exports = murmur2 => () => {\n  let counter = randomBytes(32).readUInt32BE(0)\n\n  return ({ topic, partitionMetadata, message }) => {\n    const numPartitions = partitionMetadata.length\n    const availablePartitions = partitionMetadata.filter(p => p.leader >= 0)\n    const numAvailablePartitions = availablePartitions.length\n\n    if (message.partition !== null && message.partition !== undefined) {\n      return message.partition\n    }\n\n    if (message.key !== null && message.key !== undefined) {\n      return toPositive(murmur2(message.key)) % numPartitions\n    }\n\n    if (numAvailablePartitions > 0) {\n      const i = toPositive(++counter) % numAvailablePartitions\n      return availablePartitions[i].partitionId\n    }\n\n    // no partitions are available, give a non-available partition\n    return toPositive(++counter) % numPartitions\n  }\n}\n"]},"metadata":{},"sourceType":"script"}