{"ast":null,"code":"const Encoder = require('../../../encoder');\n\nconst {\n  Produce: apiKey\n} = require('../../apiKeys');\n\nconst MessageSet = require('../../../messageSet');\n/**\n * Produce Request (Version: 0) => acks timeout [topic_data]\n *   acks => INT16\n *   timeout => INT32\n *   topic_data => topic [data]\n *     topic => STRING\n *     data => partition record_set record_set_size\n *       partition => INT32\n *       record_set_size => INT32\n *       record_set => RECORDS\n */\n\n/**\n * MessageV0:\n * {\n *   key: bytes,\n *   value: bytes\n * }\n *\n * MessageSet:\n * [\n *   { key: \"<value>\", value: \"<value>\" },\n *   { key: \"<value>\", value: \"<value>\" },\n * ]\n *\n * TopicData:\n * [\n *   {\n *     topic: 'name1',\n *     partitions: [\n *       {\n *         partition: 0,\n *         messages: [<MessageSet>]\n *       }\n *     ]\n *   }\n * ]\n */\n\n/**\n * @param acks {Integer} This field indicates how many acknowledgements the servers should receive before\n *                       responding to the request. If it is 0 the server will not send any response\n *                       (this is the only case where the server will not reply to a request). If it is 1,\n *                       the server will wait the data is written to the local log before sending a response.\n *                       If it is -1 the server will block until the message is committed by all in sync replicas\n *                       before sending a response.\n *\n * @param timeout {Integer} This provides a maximum time in milliseconds the server can await the receipt of the number\n *                          of acknowledgements in RequiredAcks. The timeout is not an exact limit on the request time\n *                          for a few reasons:\n *                          (1) it does not include network latency,\n *                          (2) the timer begins at the beginning of the processing of this request so if many requests are\n *                              queued due to server overload that wait time will not be included,\n *                          (3) we will not terminate a local write so if the local write time exceeds this timeout it will not\n *                              be respected. To get a hard timeout of this type the client should use the socket timeout.\n *\n * @param topicData {Array}\n */\n\n\nmodule.exports = ({\n  acks,\n  timeout,\n  topicData\n}) => ({\n  apiKey,\n  apiVersion: 0,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: async () => {\n    return new Encoder().writeInt16(acks).writeInt32(timeout).writeArray(topicData.map(encodeTopic));\n  }\n});\n\nconst encodeTopic = ({\n  topic,\n  partitions\n}) => {\n  return new Encoder().writeString(topic).writeArray(partitions.map(encodePartitions));\n};\n\nconst encodePartitions = ({\n  partition,\n  messages\n}) => {\n  const messageSet = MessageSet({\n    messageVersion: 0,\n    entries: messages\n  });\n  return new Encoder().writeInt32(partition).writeInt32(messageSet.size()).writeEncoder(messageSet);\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/requests/produce/v0/request.js"],"names":["Encoder","require","Produce","apiKey","MessageSet","module","exports","acks","timeout","topicData","apiVersion","apiName","expectResponse","encode","writeInt16","writeInt32","writeArray","map","encodeTopic","topic","partitions","writeString","encodePartitions","partition","messages","messageSet","messageVersion","entries","size","writeEncoder"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA,OAAO,EAAEC;AAAX,IAAsBF,OAAO,CAAC,eAAD,CAAnC;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,qBAAD,CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA,OAAR;AAAiBC,EAAAA;AAAjB,CAAD,MAAmC;AAClDN,EAAAA,MADkD;AAElDO,EAAAA,UAAU,EAAE,CAFsC;AAGlDC,EAAAA,OAAO,EAAE,SAHyC;AAIlDC,EAAAA,cAAc,EAAE,MAAML,IAAI,KAAK,CAJmB;AAKlDM,EAAAA,MAAM,EAAE,YAAY;AAClB,WAAO,IAAIb,OAAJ,GACJc,UADI,CACOP,IADP,EAEJQ,UAFI,CAEOP,OAFP,EAGJQ,UAHI,CAGOP,SAAS,CAACQ,GAAV,CAAcC,WAAd,CAHP,CAAP;AAID;AAViD,CAAnC,CAAjB;;AAaA,MAAMA,WAAW,GAAG,CAAC;AAAEC,EAAAA,KAAF;AAASC,EAAAA;AAAT,CAAD,KAA2B;AAC7C,SAAO,IAAIpB,OAAJ,GAAcqB,WAAd,CAA0BF,KAA1B,EAAiCH,UAAjC,CAA4CI,UAAU,CAACH,GAAX,CAAeK,gBAAf,CAA5C,CAAP;AACD,CAFD;;AAIA,MAAMA,gBAAgB,GAAG,CAAC;AAAEC,EAAAA,SAAF;AAAaC,EAAAA;AAAb,CAAD,KAA6B;AACpD,QAAMC,UAAU,GAAGrB,UAAU,CAAC;AAAEsB,IAAAA,cAAc,EAAE,CAAlB;AAAqBC,IAAAA,OAAO,EAAEH;AAA9B,GAAD,CAA7B;AACA,SAAO,IAAIxB,OAAJ,GACJe,UADI,CACOQ,SADP,EAEJR,UAFI,CAEOU,UAAU,CAACG,IAAX,EAFP,EAGJC,YAHI,CAGSJ,UAHT,CAAP;AAID,CAND","sourcesContent":["const Encoder = require('../../../encoder')\nconst { Produce: apiKey } = require('../../apiKeys')\nconst MessageSet = require('../../../messageSet')\n\n/**\n * Produce Request (Version: 0) => acks timeout [topic_data]\n *   acks => INT16\n *   timeout => INT32\n *   topic_data => topic [data]\n *     topic => STRING\n *     data => partition record_set record_set_size\n *       partition => INT32\n *       record_set_size => INT32\n *       record_set => RECORDS\n */\n\n/**\n * MessageV0:\n * {\n *   key: bytes,\n *   value: bytes\n * }\n *\n * MessageSet:\n * [\n *   { key: \"<value>\", value: \"<value>\" },\n *   { key: \"<value>\", value: \"<value>\" },\n * ]\n *\n * TopicData:\n * [\n *   {\n *     topic: 'name1',\n *     partitions: [\n *       {\n *         partition: 0,\n *         messages: [<MessageSet>]\n *       }\n *     ]\n *   }\n * ]\n */\n\n/**\n * @param acks {Integer} This field indicates how many acknowledgements the servers should receive before\n *                       responding to the request. If it is 0 the server will not send any response\n *                       (this is the only case where the server will not reply to a request). If it is 1,\n *                       the server will wait the data is written to the local log before sending a response.\n *                       If it is -1 the server will block until the message is committed by all in sync replicas\n *                       before sending a response.\n *\n * @param timeout {Integer} This provides a maximum time in milliseconds the server can await the receipt of the number\n *                          of acknowledgements in RequiredAcks. The timeout is not an exact limit on the request time\n *                          for a few reasons:\n *                          (1) it does not include network latency,\n *                          (2) the timer begins at the beginning of the processing of this request so if many requests are\n *                              queued due to server overload that wait time will not be included,\n *                          (3) we will not terminate a local write so if the local write time exceeds this timeout it will not\n *                              be respected. To get a hard timeout of this type the client should use the socket timeout.\n *\n * @param topicData {Array}\n */\nmodule.exports = ({ acks, timeout, topicData }) => ({\n  apiKey,\n  apiVersion: 0,\n  apiName: 'Produce',\n  expectResponse: () => acks !== 0,\n  encode: async () => {\n    return new Encoder()\n      .writeInt16(acks)\n      .writeInt32(timeout)\n      .writeArray(topicData.map(encodeTopic))\n  },\n})\n\nconst encodeTopic = ({ topic, partitions }) => {\n  return new Encoder().writeString(topic).writeArray(partitions.map(encodePartitions))\n}\n\nconst encodePartitions = ({ partition, messages }) => {\n  const messageSet = MessageSet({ messageVersion: 0, entries: messages })\n  return new Encoder()\n    .writeInt32(partition)\n    .writeInt32(messageSet.size())\n    .writeEncoder(messageSet)\n}\n"]},"metadata":{},"sourceType":"script"}