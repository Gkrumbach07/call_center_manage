{"ast":null,"code":"const Decoder = require('../../../decoder');\n\nconst {\n  parse: parseV1\n} = require('../v1/response');\n\nconst decodeMessages = require('../v4/decodeMessages');\n/**\n * Fetch Response (Version: 8) => throttle_time_ms error_code session_id [responses]\n *   throttle_time_ms => INT32\n *   error_code => INT16\n *   session_id => INT32\n *   responses => topic [partition_responses]\n *     topic => STRING\n *     partition_responses => partition_header record_set\n *       partition_header => partition error_code high_watermark last_stable_offset log_start_offset [aborted_transactions]\n *         partition => INT32\n *         error_code => INT16\n *         high_watermark => INT64\n *         last_stable_offset => INT64\n *         log_start_offset => INT64\n *         aborted_transactions => producer_id first_offset\n *           producer_id => INT64\n *           first_offset => INT64\n *       record_set => RECORDS\n */\n\n\nconst decodeAbortedTransactions = decoder => ({\n  producerId: decoder.readInt64().toString(),\n  firstOffset: decoder.readInt64().toString()\n});\n\nconst decodePartition = async decoder => ({\n  partition: decoder.readInt32(),\n  errorCode: decoder.readInt16(),\n  highWatermark: decoder.readInt64().toString(),\n  lastStableOffset: decoder.readInt64().toString(),\n  lastStartOffset: decoder.readInt64().toString(),\n  abortedTransactions: decoder.readArray(decodeAbortedTransactions),\n  messages: await decodeMessages(decoder)\n});\n\nconst decodeResponse = async decoder => ({\n  topicName: decoder.readString(),\n  partitions: await decoder.readArrayAsync(decodePartition)\n});\n\nconst decode = async rawData => {\n  const decoder = new Decoder(rawData);\n  const clientSideThrottleTime = decoder.readInt32();\n  const errorCode = decoder.readInt16();\n  const sessionId = decoder.readInt32();\n  const responses = await decoder.readArrayAsync(decodeResponse); // Report a `throttleTime` of 0: The broker will not have throttled\n  // this request, but if the `clientSideThrottleTime` is >0 then it\n  // expects us to do that -- and it will ignore requests.\n\n  return {\n    throttleTime: 0,\n    clientSideThrottleTime,\n    errorCode,\n    sessionId,\n    responses\n  };\n};\n\nmodule.exports = {\n  decode,\n  parse: parseV1\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/requests/fetch/v8/response.js"],"names":["Decoder","require","parse","parseV1","decodeMessages","decodeAbortedTransactions","decoder","producerId","readInt64","toString","firstOffset","decodePartition","partition","readInt32","errorCode","readInt16","highWatermark","lastStableOffset","lastStartOffset","abortedTransactions","readArray","messages","decodeResponse","topicName","readString","partitions","readArrayAsync","decode","rawData","clientSideThrottleTime","sessionId","responses","throttleTime","module","exports"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA,KAAK,EAAEC;AAAT,IAAqBF,OAAO,CAAC,gBAAD,CAAlC;;AACA,MAAMG,cAAc,GAAGH,OAAO,CAAC,sBAAD,CAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMI,yBAAyB,GAAGC,OAAO,KAAK;AAC5CC,EAAAA,UAAU,EAAED,OAAO,CAACE,SAAR,GAAoBC,QAApB,EADgC;AAE5CC,EAAAA,WAAW,EAAEJ,OAAO,CAACE,SAAR,GAAoBC,QAApB;AAF+B,CAAL,CAAzC;;AAKA,MAAME,eAAe,GAAG,MAAML,OAAN,KAAkB;AACxCM,EAAAA,SAAS,EAAEN,OAAO,CAACO,SAAR,EAD6B;AAExCC,EAAAA,SAAS,EAAER,OAAO,CAACS,SAAR,EAF6B;AAGxCC,EAAAA,aAAa,EAAEV,OAAO,CAACE,SAAR,GAAoBC,QAApB,EAHyB;AAIxCQ,EAAAA,gBAAgB,EAAEX,OAAO,CAACE,SAAR,GAAoBC,QAApB,EAJsB;AAKxCS,EAAAA,eAAe,EAAEZ,OAAO,CAACE,SAAR,GAAoBC,QAApB,EALuB;AAMxCU,EAAAA,mBAAmB,EAAEb,OAAO,CAACc,SAAR,CAAkBf,yBAAlB,CANmB;AAOxCgB,EAAAA,QAAQ,EAAE,MAAMjB,cAAc,CAACE,OAAD;AAPU,CAAlB,CAAxB;;AAUA,MAAMgB,cAAc,GAAG,MAAMhB,OAAN,KAAkB;AACvCiB,EAAAA,SAAS,EAAEjB,OAAO,CAACkB,UAAR,EAD4B;AAEvCC,EAAAA,UAAU,EAAE,MAAMnB,OAAO,CAACoB,cAAR,CAAuBf,eAAvB;AAFqB,CAAlB,CAAvB;;AAKA,MAAMgB,MAAM,GAAG,MAAMC,OAAN,IAAiB;AAC9B,QAAMtB,OAAO,GAAG,IAAIN,OAAJ,CAAY4B,OAAZ,CAAhB;AACA,QAAMC,sBAAsB,GAAGvB,OAAO,CAACO,SAAR,EAA/B;AACA,QAAMC,SAAS,GAAGR,OAAO,CAACS,SAAR,EAAlB;AACA,QAAMe,SAAS,GAAGxB,OAAO,CAACO,SAAR,EAAlB;AACA,QAAMkB,SAAS,GAAG,MAAMzB,OAAO,CAACoB,cAAR,CAAuBJ,cAAvB,CAAxB,CAL8B,CAO9B;AACA;AACA;;AACA,SAAO;AACLU,IAAAA,YAAY,EAAE,CADT;AAELH,IAAAA,sBAFK;AAGLf,IAAAA,SAHK;AAILgB,IAAAA,SAJK;AAKLC,IAAAA;AALK,GAAP;AAOD,CAjBD;;AAmBAE,MAAM,CAACC,OAAP,GAAiB;AACfP,EAAAA,MADe;AAEfzB,EAAAA,KAAK,EAAEC;AAFQ,CAAjB","sourcesContent":["const Decoder = require('../../../decoder')\nconst { parse: parseV1 } = require('../v1/response')\nconst decodeMessages = require('../v4/decodeMessages')\n\n/**\n * Fetch Response (Version: 8) => throttle_time_ms error_code session_id [responses]\n *   throttle_time_ms => INT32\n *   error_code => INT16\n *   session_id => INT32\n *   responses => topic [partition_responses]\n *     topic => STRING\n *     partition_responses => partition_header record_set\n *       partition_header => partition error_code high_watermark last_stable_offset log_start_offset [aborted_transactions]\n *         partition => INT32\n *         error_code => INT16\n *         high_watermark => INT64\n *         last_stable_offset => INT64\n *         log_start_offset => INT64\n *         aborted_transactions => producer_id first_offset\n *           producer_id => INT64\n *           first_offset => INT64\n *       record_set => RECORDS\n */\n\nconst decodeAbortedTransactions = decoder => ({\n  producerId: decoder.readInt64().toString(),\n  firstOffset: decoder.readInt64().toString(),\n})\n\nconst decodePartition = async decoder => ({\n  partition: decoder.readInt32(),\n  errorCode: decoder.readInt16(),\n  highWatermark: decoder.readInt64().toString(),\n  lastStableOffset: decoder.readInt64().toString(),\n  lastStartOffset: decoder.readInt64().toString(),\n  abortedTransactions: decoder.readArray(decodeAbortedTransactions),\n  messages: await decodeMessages(decoder),\n})\n\nconst decodeResponse = async decoder => ({\n  topicName: decoder.readString(),\n  partitions: await decoder.readArrayAsync(decodePartition),\n})\n\nconst decode = async rawData => {\n  const decoder = new Decoder(rawData)\n  const clientSideThrottleTime = decoder.readInt32()\n  const errorCode = decoder.readInt16()\n  const sessionId = decoder.readInt32()\n  const responses = await decoder.readArrayAsync(decodeResponse)\n\n  // Report a `throttleTime` of 0: The broker will not have throttled\n  // this request, but if the `clientSideThrottleTime` is >0 then it\n  // expects us to do that -- and it will ignore requests.\n  return {\n    throttleTime: 0,\n    clientSideThrottleTime,\n    errorCode,\n    sessionId,\n    responses,\n  }\n}\n\nmodule.exports = {\n  decode,\n  parse: parseV1,\n}\n"]},"metadata":{},"sourceType":"script"}