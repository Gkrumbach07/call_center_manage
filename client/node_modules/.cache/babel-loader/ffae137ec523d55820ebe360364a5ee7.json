{"ast":null,"code":"const Long = require('../utils/long');\n\nconst filterAbortedMessages = require('./filterAbortedMessages');\n/**\n * A batch collects messages returned from a single fetch call.\n *\n * A batch could contain _multiple_ Kafka RecordBatches.\n */\n\n\nmodule.exports = class Batch {\n  constructor(topic, fetchedOffset, partitionData) {\n    this.fetchedOffset = fetchedOffset;\n    const longFetchedOffset = Long.fromValue(this.fetchedOffset);\n    const {\n      abortedTransactions,\n      messages\n    } = partitionData;\n    this.topic = topic;\n    this.partition = partitionData.partition;\n    this.highWatermark = partitionData.highWatermark;\n    this.rawMessages = messages; // Apparently fetch can return different offsets than the target offset provided to the fetch API.\n    // Discard messages that are not in the requested offset\n    // https://github.com/apache/kafka/blob/bf237fa7c576bd141d78fdea9f17f65ea269c290/clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java#L912\n\n    this.messagesWithinOffset = this.rawMessages.filter(message => Long.fromValue(message.offset).gte(longFetchedOffset)); // 1. Don't expose aborted messages\n    // 2. Don't expose control records\n    // @see https://kafka.apache.org/documentation/#controlbatch\n\n    this.messages = filterAbortedMessages({\n      messages: this.messagesWithinOffset,\n      abortedTransactions\n    }).filter(message => !message.isControlRecord);\n  }\n\n  isEmpty() {\n    return this.messages.length === 0;\n  }\n\n  isEmptyIncludingFiltered() {\n    return this.messagesWithinOffset.length === 0;\n  }\n\n  isEmptyControlRecord() {\n    return this.isEmpty() && this.messagesWithinOffset.some(({\n      isControlRecord\n    }) => isControlRecord);\n  }\n  /**\n   * With compressed messages, it's possible for the returned messages to have offsets smaller than the starting offset.\n   * These messages will be filtered out (i.e. they are not even included in this.messagesWithinOffset)\n   * If these are the only messages, the batch will appear as an empty batch.\n   *\n   * isEmpty() and isEmptyIncludingFiltered() will always return true if the batch is empty,\n   * but this method will only return true if the batch is empty due to log compacted messages.\n   *\n   * @returns boolean True if the batch is empty, because of log compacted messages in the partition.\n   */\n\n\n  isEmptyDueToLogCompactedMessages() {\n    const hasMessages = this.rawMessages.length > 0;\n    return hasMessages && this.isEmptyIncludingFiltered();\n  }\n\n  firstOffset() {\n    return this.isEmptyIncludingFiltered() ? null : this.messagesWithinOffset[0].offset;\n  }\n\n  lastOffset() {\n    if (this.isEmptyDueToLogCompactedMessages()) {\n      return this.fetchedOffset;\n    }\n\n    if (this.isEmptyIncludingFiltered()) {\n      return Long.fromValue(this.highWatermark).add(-1).toString();\n    }\n\n    return this.messagesWithinOffset[this.messagesWithinOffset.length - 1].offset;\n  }\n  /**\n   * Returns the lag based on the last offset in the batch (also known as \"high\")\n   */\n\n\n  offsetLag() {\n    const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1);\n    const lastConsumedOffset = Long.fromValue(this.lastOffset());\n    return lastOffsetOfPartition.add(lastConsumedOffset.multiply(-1)).toString();\n  }\n  /**\n   * Returns the lag based on the first offset in the batch\n   */\n\n\n  offsetLagLow() {\n    if (this.isEmptyIncludingFiltered()) {\n      return '0';\n    }\n\n    const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1);\n    const firstConsumedOffset = Long.fromValue(this.firstOffset());\n    return lastOffsetOfPartition.add(firstConsumedOffset.multiply(-1)).toString();\n  }\n\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/consumer/batch.js"],"names":["Long","require","filterAbortedMessages","module","exports","Batch","constructor","topic","fetchedOffset","partitionData","longFetchedOffset","fromValue","abortedTransactions","messages","partition","highWatermark","rawMessages","messagesWithinOffset","filter","message","offset","gte","isControlRecord","isEmpty","length","isEmptyIncludingFiltered","isEmptyControlRecord","some","isEmptyDueToLogCompactedMessages","hasMessages","firstOffset","lastOffset","add","toString","offsetLag","lastOffsetOfPartition","lastConsumedOffset","multiply","offsetLagLow","firstConsumedOffset"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,eAAD,CAApB;;AACA,MAAMC,qBAAqB,GAAGD,OAAO,CAAC,yBAAD,CAArC;AAEA;AACA;AACA;AACA;AACA;;;AACAE,MAAM,CAACC,OAAP,GAAiB,MAAMC,KAAN,CAAY;AAC3BC,EAAAA,WAAW,CAACC,KAAD,EAAQC,aAAR,EAAuBC,aAAvB,EAAsC;AAC/C,SAAKD,aAAL,GAAqBA,aAArB;AACA,UAAME,iBAAiB,GAAGV,IAAI,CAACW,SAAL,CAAe,KAAKH,aAApB,CAA1B;AACA,UAAM;AAAEI,MAAAA,mBAAF;AAAuBC,MAAAA;AAAvB,QAAoCJ,aAA1C;AAEA,SAAKF,KAAL,GAAaA,KAAb;AACA,SAAKO,SAAL,GAAiBL,aAAa,CAACK,SAA/B;AACA,SAAKC,aAAL,GAAqBN,aAAa,CAACM,aAAnC;AAEA,SAAKC,WAAL,GAAmBH,QAAnB,CAT+C,CAU/C;AACA;AACA;;AACA,SAAKI,oBAAL,GAA4B,KAAKD,WAAL,CAAiBE,MAAjB,CAAwBC,OAAO,IACzDnB,IAAI,CAACW,SAAL,CAAeQ,OAAO,CAACC,MAAvB,EAA+BC,GAA/B,CAAmCX,iBAAnC,CAD0B,CAA5B,CAb+C,CAiB/C;AACA;AACA;;AACA,SAAKG,QAAL,GAAgBX,qBAAqB,CAAC;AACpCW,MAAAA,QAAQ,EAAE,KAAKI,oBADqB;AAEpCL,MAAAA;AAFoC,KAAD,CAArB,CAGbM,MAHa,CAGNC,OAAO,IAAI,CAACA,OAAO,CAACG,eAHd,CAAhB;AAID;;AAEDC,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKV,QAAL,CAAcW,MAAd,KAAyB,CAAhC;AACD;;AAEDC,EAAAA,wBAAwB,GAAG;AACzB,WAAO,KAAKR,oBAAL,CAA0BO,MAA1B,KAAqC,CAA5C;AACD;;AAEDE,EAAAA,oBAAoB,GAAG;AACrB,WACE,KAAKH,OAAL,MAAkB,KAAKN,oBAAL,CAA0BU,IAA1B,CAA+B,CAAC;AAAEL,MAAAA;AAAF,KAAD,KAAyBA,eAAxD,CADpB;AAGD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEM,EAAAA,gCAAgC,GAAG;AACjC,UAAMC,WAAW,GAAG,KAAKb,WAAL,CAAiBQ,MAAjB,GAA0B,CAA9C;AACA,WAAOK,WAAW,IAAI,KAAKJ,wBAAL,EAAtB;AACD;;AAEDK,EAAAA,WAAW,GAAG;AACZ,WAAO,KAAKL,wBAAL,KAAkC,IAAlC,GAAyC,KAAKR,oBAAL,CAA0B,CAA1B,EAA6BG,MAA7E;AACD;;AAEDW,EAAAA,UAAU,GAAG;AACX,QAAI,KAAKH,gCAAL,EAAJ,EAA6C;AAC3C,aAAO,KAAKpB,aAAZ;AACD;;AAED,QAAI,KAAKiB,wBAAL,EAAJ,EAAqC;AACnC,aAAOzB,IAAI,CAACW,SAAL,CAAe,KAAKI,aAApB,EACJiB,GADI,CACA,CAAC,CADD,EAEJC,QAFI,EAAP;AAGD;;AAED,WAAO,KAAKhB,oBAAL,CAA0B,KAAKA,oBAAL,CAA0BO,MAA1B,GAAmC,CAA7D,EAAgEJ,MAAvE;AACD;AAED;AACF;AACA;;;AACEc,EAAAA,SAAS,GAAG;AACV,UAAMC,qBAAqB,GAAGnC,IAAI,CAACW,SAAL,CAAe,KAAKI,aAApB,EAAmCiB,GAAnC,CAAuC,CAAC,CAAxC,CAA9B;AACA,UAAMI,kBAAkB,GAAGpC,IAAI,CAACW,SAAL,CAAe,KAAKoB,UAAL,EAAf,CAA3B;AACA,WAAOI,qBAAqB,CAACH,GAAtB,CAA0BI,kBAAkB,CAACC,QAAnB,CAA4B,CAAC,CAA7B,CAA1B,EAA2DJ,QAA3D,EAAP;AACD;AAED;AACF;AACA;;;AACEK,EAAAA,YAAY,GAAG;AACb,QAAI,KAAKb,wBAAL,EAAJ,EAAqC;AACnC,aAAO,GAAP;AACD;;AAED,UAAMU,qBAAqB,GAAGnC,IAAI,CAACW,SAAL,CAAe,KAAKI,aAApB,EAAmCiB,GAAnC,CAAuC,CAAC,CAAxC,CAA9B;AACA,UAAMO,mBAAmB,GAAGvC,IAAI,CAACW,SAAL,CAAe,KAAKmB,WAAL,EAAf,CAA5B;AACA,WAAOK,qBAAqB,CAACH,GAAtB,CAA0BO,mBAAmB,CAACF,QAApB,CAA6B,CAAC,CAA9B,CAA1B,EAA4DJ,QAA5D,EAAP;AACD;;AA9F0B,CAA7B","sourcesContent":["const Long = require('../utils/long')\nconst filterAbortedMessages = require('./filterAbortedMessages')\n\n/**\n * A batch collects messages returned from a single fetch call.\n *\n * A batch could contain _multiple_ Kafka RecordBatches.\n */\nmodule.exports = class Batch {\n  constructor(topic, fetchedOffset, partitionData) {\n    this.fetchedOffset = fetchedOffset\n    const longFetchedOffset = Long.fromValue(this.fetchedOffset)\n    const { abortedTransactions, messages } = partitionData\n\n    this.topic = topic\n    this.partition = partitionData.partition\n    this.highWatermark = partitionData.highWatermark\n\n    this.rawMessages = messages\n    // Apparently fetch can return different offsets than the target offset provided to the fetch API.\n    // Discard messages that are not in the requested offset\n    // https://github.com/apache/kafka/blob/bf237fa7c576bd141d78fdea9f17f65ea269c290/clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java#L912\n    this.messagesWithinOffset = this.rawMessages.filter(message =>\n      Long.fromValue(message.offset).gte(longFetchedOffset)\n    )\n\n    // 1. Don't expose aborted messages\n    // 2. Don't expose control records\n    // @see https://kafka.apache.org/documentation/#controlbatch\n    this.messages = filterAbortedMessages({\n      messages: this.messagesWithinOffset,\n      abortedTransactions,\n    }).filter(message => !message.isControlRecord)\n  }\n\n  isEmpty() {\n    return this.messages.length === 0\n  }\n\n  isEmptyIncludingFiltered() {\n    return this.messagesWithinOffset.length === 0\n  }\n\n  isEmptyControlRecord() {\n    return (\n      this.isEmpty() && this.messagesWithinOffset.some(({ isControlRecord }) => isControlRecord)\n    )\n  }\n\n  /**\n   * With compressed messages, it's possible for the returned messages to have offsets smaller than the starting offset.\n   * These messages will be filtered out (i.e. they are not even included in this.messagesWithinOffset)\n   * If these are the only messages, the batch will appear as an empty batch.\n   *\n   * isEmpty() and isEmptyIncludingFiltered() will always return true if the batch is empty,\n   * but this method will only return true if the batch is empty due to log compacted messages.\n   *\n   * @returns boolean True if the batch is empty, because of log compacted messages in the partition.\n   */\n  isEmptyDueToLogCompactedMessages() {\n    const hasMessages = this.rawMessages.length > 0\n    return hasMessages && this.isEmptyIncludingFiltered()\n  }\n\n  firstOffset() {\n    return this.isEmptyIncludingFiltered() ? null : this.messagesWithinOffset[0].offset\n  }\n\n  lastOffset() {\n    if (this.isEmptyDueToLogCompactedMessages()) {\n      return this.fetchedOffset\n    }\n\n    if (this.isEmptyIncludingFiltered()) {\n      return Long.fromValue(this.highWatermark)\n        .add(-1)\n        .toString()\n    }\n\n    return this.messagesWithinOffset[this.messagesWithinOffset.length - 1].offset\n  }\n\n  /**\n   * Returns the lag based on the last offset in the batch (also known as \"high\")\n   */\n  offsetLag() {\n    const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1)\n    const lastConsumedOffset = Long.fromValue(this.lastOffset())\n    return lastOffsetOfPartition.add(lastConsumedOffset.multiply(-1)).toString()\n  }\n\n  /**\n   * Returns the lag based on the first offset in the batch\n   */\n  offsetLagLow() {\n    if (this.isEmptyIncludingFiltered()) {\n      return '0'\n    }\n\n    const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1)\n    const firstConsumedOffset = Long.fromValue(this.firstOffset())\n    return lastOffsetOfPartition.add(firstConsumedOffset.multiply(-1)).toString()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}