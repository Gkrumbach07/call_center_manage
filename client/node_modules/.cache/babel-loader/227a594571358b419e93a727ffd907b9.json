{"ast":null,"code":"const BrokerPool = require('./brokerPool');\n\nconst Lock = require('../utils/lock');\n\nconst createRetry = require('../retry');\n\nconst connectionBuilder = require('./connectionBuilder');\n\nconst flatten = require('../utils/flatten');\n\nconst {\n  EARLIEST_OFFSET,\n  LATEST_OFFSET\n} = require('../constants');\n\nconst {\n  KafkaJSError,\n  KafkaJSBrokerNotFound,\n  KafkaJSMetadataNotLoaded,\n  KafkaJSTopicMetadataNotLoaded,\n  KafkaJSGroupCoordinatorNotFound\n} = require('../errors');\n\nconst COORDINATOR_TYPES = require('../protocol/coordinatorTypes');\n\nconst {\n  keys\n} = Object;\n\nconst mergeTopics = (obj, {\n  topic,\n  partitions\n}) => ({ ...obj,\n  [topic]: [...(obj[topic] || []), ...partitions]\n});\n\nmodule.exports = class Cluster {\n  /**\n   * @param {Object} options\n   * @param {Array<string>} options.brokers example: ['127.0.0.1:9092', '127.0.0.1:9094']\n   * @param {Object} options.ssl\n   * @param {Object} options.sasl\n   * @param {string} options.clientId\n   * @param {number} options.connectionTimeout - in milliseconds\n   * @param {number} options.authenticationTimeout - in milliseconds\n   * @param {number} options.reauthenticationThreshold - in milliseconds\n   * @param {number} [options.requestTimeout=30000] - in milliseconds\n   * @param {number} options.metadataMaxAge - in milliseconds\n   * @param {boolean} options.allowAutoTopicCreation\n   * @param {number} options.maxInFlightRequests\n   * @param {number} options.isolationLevel\n   * @param {Object} options.retry\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {Map} options.offsets\n   * @param {import(\"../instrumentation/emitter\")} [options.instrumentationEmitter=null]\n   */\n  constructor({\n    logger: rootLogger,\n    socketFactory,\n    brokers,\n    ssl,\n    sasl,\n    clientId,\n    connectionTimeout,\n    authenticationTimeout,\n    reauthenticationThreshold,\n    requestTimeout = 30000,\n    enforceRequestTimeout,\n    metadataMaxAge,\n    retry,\n    allowAutoTopicCreation,\n    maxInFlightRequests,\n    isolationLevel,\n    instrumentationEmitter = null,\n    offsets = new Map()\n  }) {\n    this.rootLogger = rootLogger;\n    this.logger = rootLogger.namespace('Cluster');\n    this.retry = { ...retry\n    };\n    this.retrier = createRetry(this.retry);\n    this.connectionBuilder = connectionBuilder({\n      logger: rootLogger,\n      instrumentationEmitter,\n      socketFactory,\n      brokers,\n      ssl,\n      sasl,\n      clientId,\n      connectionTimeout,\n      requestTimeout,\n      enforceRequestTimeout,\n      maxInFlightRequests,\n      retry\n    });\n    this.targetTopics = new Set();\n    this.mutatingTargetTopics = new Lock({\n      description: `updating target topics`,\n      timeout: requestTimeout\n    });\n    this.isolationLevel = isolationLevel;\n    this.brokerPool = new BrokerPool({\n      connectionBuilder: this.connectionBuilder,\n      logger: this.rootLogger,\n      retry,\n      allowAutoTopicCreation,\n      authenticationTimeout,\n      reauthenticationThreshold,\n      metadataMaxAge\n    });\n    this.committedOffsetsByGroup = offsets;\n  }\n\n  isConnected() {\n    return this.brokerPool.hasConnectedBrokers();\n  }\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n\n\n  async connect() {\n    await this.brokerPool.connect();\n  }\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n\n\n  async disconnect() {\n    await this.brokerPool.disconnect();\n  }\n  /**\n   * @public\n   * @param {String} host\n   * @param {Number} port\n   */\n\n\n  removeBroker({\n    host,\n    port\n  }) {\n    this.brokerPool.removeBroker({\n      host,\n      port\n    });\n  }\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n\n\n  async refreshMetadata() {\n    await this.brokerPool.refreshMetadata(Array.from(this.targetTopics));\n  }\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n\n\n  async refreshMetadataIfNecessary() {\n    await this.brokerPool.refreshMetadataIfNecessary(Array.from(this.targetTopics));\n  }\n  /**\n   * @public\n   * @returns {Promise<Metadata>}\n   */\n\n\n  async metadata({\n    topics = []\n  } = {}) {\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await this.brokerPool.refreshMetadataIfNecessary(topics);\n        return this.brokerPool.withBroker(async ({\n          broker\n        }) => broker.metadata(topics));\n      } catch (e) {\n        if (e.type === 'LEADER_NOT_AVAILABLE') {\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  }\n  /**\n   * @public\n   * @param {string} topic\n   * @return {Promise}\n   */\n\n\n  async addTargetTopic(topic) {\n    return this.addMultipleTargetTopics([topic]);\n  }\n  /**\n   * @public\n   * @param {string[]} topics\n   * @return {Promise}\n   */\n\n\n  async addMultipleTargetTopics(topics) {\n    await this.mutatingTargetTopics.acquire();\n\n    try {\n      const previousSize = this.targetTopics.size;\n      const previousTopics = new Set(this.targetTopics);\n\n      for (const topic of topics) {\n        this.targetTopics.add(topic);\n      }\n\n      const hasChanged = previousSize !== this.targetTopics.size || !this.brokerPool.metadata;\n\n      if (hasChanged) {\n        try {\n          await this.refreshMetadata();\n        } catch (e) {\n          if (e.type === 'INVALID_TOPIC_EXCEPTION' || e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n            this.targetTopics = previousTopics;\n          }\n\n          throw e;\n        }\n      }\n    } finally {\n      await this.mutatingTargetTopics.release();\n    }\n  }\n  /**\n   * @public\n   * @param {string} nodeId\n   * @returns {Promise<Broker>}\n   */\n\n\n  async findBroker({\n    nodeId\n  }) {\n    try {\n      return await this.brokerPool.findBroker({\n        nodeId\n      });\n    } catch (e) {\n      // The client probably has stale metadata\n      if (e.name === 'KafkaJSBrokerNotFound' || e.name === 'KafkaJSLockTimeout' || e.name === 'KafkaJSConnectionError') {\n        await this.refreshMetadata();\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * @public\n   * @returns {Promise<Broker>}\n   */\n\n\n  async findControllerBroker() {\n    const {\n      metadata\n    } = this.brokerPool;\n\n    if (!metadata || metadata.controllerId == null) {\n      throw new KafkaJSMetadataNotLoaded('Topic metadata not loaded');\n    }\n\n    const broker = await this.findBroker({\n      nodeId: metadata.controllerId\n    });\n\n    if (!broker) {\n      throw new KafkaJSBrokerNotFound(`Controller broker with id ${metadata.controllerId} not found in the cached metadata`);\n    }\n\n    return broker;\n  }\n  /**\n   * @public\n   * @param {string} topic\n   * @returns {import(\"../../types\").PartitionMetadata[]} Example:\n   *                   [{\n   *                     isr: [2],\n   *                     leader: 2,\n   *                     partitionErrorCode: 0,\n   *                     partitionId: 0,\n   *                     replicas: [2],\n   *                   }]\n   */\n\n\n  findTopicPartitionMetadata(topic) {\n    const {\n      metadata\n    } = this.brokerPool;\n\n    if (!metadata || !metadata.topicMetadata) {\n      throw new KafkaJSTopicMetadataNotLoaded('Topic metadata not loaded', {\n        topic\n      });\n    }\n\n    const topicMetadata = metadata.topicMetadata.find(t => t.topic === topic);\n    return topicMetadata ? topicMetadata.partitionMetadata : [];\n  }\n  /**\n   * @public\n   * @param {string} topic\n   * @param {Array<number>} partitions\n   * @returns {Object} Object with leader and partitions. For partitions 0 and 5\n   *                   the result could be:\n   *                     { '0': [0], '2': [5] }\n   *\n   *                   where the key is the nodeId.\n   */\n\n\n  findLeaderForPartitions(topic, partitions) {\n    const partitionMetadata = this.findTopicPartitionMetadata(topic);\n    return partitions.reduce((result, id) => {\n      const partitionId = parseInt(id, 10);\n      const metadata = partitionMetadata.find(p => p.partitionId === partitionId);\n\n      if (!metadata) {\n        return result;\n      }\n\n      if (metadata.leader === null || metadata.leader === undefined) {\n        throw new KafkaJSError('Invalid partition metadata', {\n          topic,\n          partitionId,\n          metadata\n        });\n      }\n\n      const {\n        leader\n      } = metadata;\n      const current = result[leader] || [];\n      return { ...result,\n        [leader]: [...current, partitionId]\n      };\n    }, {});\n  }\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {number} [coordinatorType=0]\n   * @returns {Promise<Broker>}\n   */\n\n\n  async findGroupCoordinator({\n    groupId,\n    coordinatorType = COORDINATOR_TYPES.GROUP\n  }) {\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        const {\n          coordinator\n        } = await this.findGroupCoordinatorMetadata({\n          groupId,\n          coordinatorType\n        });\n        return await this.findBroker({\n          nodeId: coordinator.nodeId\n        });\n      } catch (e) {\n        // A new broker can join the cluster before we have the chance\n        // to refresh metadata\n        if (e.name === 'KafkaJSBrokerNotFound' || e.type === 'GROUP_COORDINATOR_NOT_AVAILABLE') {\n          this.logger.debug(`${e.message}, refreshing metadata and trying again...`, {\n            groupId,\n            retryCount,\n            retryTime\n          });\n          await this.refreshMetadata();\n          throw e;\n        }\n\n        if (e.code === 'ECONNREFUSED') {\n          // During maintenance the current coordinator can go down; findBroker will\n          // refresh metadata and re-throw the error. findGroupCoordinator has to re-throw\n          // the error to go through the retry cycle.\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  }\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {number} [coordinatorType=0]\n   * @returns {Promise<Object>}\n   */\n\n\n  async findGroupCoordinatorMetadata({\n    groupId,\n    coordinatorType\n  }) {\n    const brokerMetadata = await this.brokerPool.withBroker(async ({\n      nodeId,\n      broker\n    }) => {\n      return await this.retrier(async (bail, retryCount, retryTime) => {\n        try {\n          const brokerMetadata = await broker.findGroupCoordinator({\n            groupId,\n            coordinatorType\n          });\n          this.logger.debug('Found group coordinator', {\n            broker: brokerMetadata.host,\n            nodeId: brokerMetadata.coordinator.nodeId\n          });\n          return brokerMetadata;\n        } catch (e) {\n          this.logger.debug('Tried to find group coordinator', {\n            nodeId,\n            error: e\n          });\n\n          if (e.type === 'GROUP_COORDINATOR_NOT_AVAILABLE') {\n            this.logger.debug('Group coordinator not available, retrying...', {\n              nodeId,\n              retryCount,\n              retryTime\n            });\n            throw e;\n          }\n\n          bail(e);\n        }\n      });\n    });\n\n    if (brokerMetadata) {\n      return brokerMetadata;\n    }\n\n    throw new KafkaJSGroupCoordinatorNotFound('Failed to find group coordinator');\n  }\n  /**\n   * @param {object} topicConfiguration\n   * @returns {number}\n   */\n\n\n  defaultOffset({\n    fromBeginning\n  }) {\n    return fromBeginning ? EARLIEST_OFFSET : LATEST_OFFSET;\n  }\n  /**\n   * @public\n   * @param {Array<Object>} topics\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [{ partition: 0 }],\n   *                              fromBeginning: false\n   *                            }\n   *                          ]\n   * @returns {Promise<Array>} example:\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [\n   *                                { partition: 0, offset: '1' },\n   *                                { partition: 1, offset: '2' },\n   *                                { partition: 2, offset: '1' },\n   *                              ],\n   *                            },\n   *                          ]\n   */\n\n\n  async fetchTopicsOffset(topics) {\n    const partitionsPerBroker = {};\n    const topicConfigurations = {};\n\n    const addDefaultOffset = topic => partition => {\n      const {\n        timestamp\n      } = topicConfigurations[topic];\n      return { ...partition,\n        timestamp\n      };\n    }; // Index all topics and partitions per leader (nodeId)\n\n\n    for (const topicData of topics) {\n      const {\n        topic,\n        partitions,\n        fromBeginning,\n        fromTimestamp\n      } = topicData;\n      const partitionsPerLeader = this.findLeaderForPartitions(topic, partitions.map(p => p.partition));\n      const timestamp = fromTimestamp != null ? fromTimestamp : this.defaultOffset({\n        fromBeginning\n      });\n      topicConfigurations[topic] = {\n        timestamp\n      };\n      keys(partitionsPerLeader).map(nodeId => {\n        partitionsPerBroker[nodeId] = partitionsPerBroker[nodeId] || {};\n        partitionsPerBroker[nodeId][topic] = partitions.filter(p => partitionsPerLeader[nodeId].includes(p.partition));\n      });\n    } // Create a list of requests to fetch the offset of all partitions\n\n\n    const requests = keys(partitionsPerBroker).map(async nodeId => {\n      const broker = await this.findBroker({\n        nodeId\n      });\n      const partitions = partitionsPerBroker[nodeId];\n      const {\n        responses: topicOffsets\n      } = await broker.listOffsets({\n        isolationLevel: this.isolationLevel,\n        topics: keys(partitions).map(topic => ({\n          topic,\n          partitions: partitions[topic].map(addDefaultOffset(topic))\n        }))\n      });\n      return topicOffsets;\n    }); // Execute all requests, merge and normalize the responses\n\n    const responses = await Promise.all(requests);\n    const partitionsPerTopic = flatten(responses).reduce(mergeTopics, {});\n    return keys(partitionsPerTopic).map(topic => ({\n      topic,\n      partitions: partitionsPerTopic[topic].map(({\n        partition,\n        offset\n      }) => ({\n        partition,\n        offset\n      }))\n    }));\n  }\n  /**\n   * Retrieve the object mapping for committed offsets for a single consumer group\n   * @param {string} groupId\n   * @returns {Object}\n   */\n\n\n  committedOffsets({\n    groupId\n  }) {\n    if (!this.committedOffsetsByGroup.has(groupId)) {\n      this.committedOffsetsByGroup.set(groupId, {});\n    }\n\n    return this.committedOffsetsByGroup.get(groupId);\n  }\n  /**\n   * Mark offset as committed for a single consumer group's topic-partition\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {string|number} partition\n   * @param {string} offset\n   * @returns {undefined}\n   */\n\n\n  markOffsetAsCommitted({\n    groupId,\n    topic,\n    partition,\n    offset\n  }) {\n    const committedOffsets = this.committedOffsets({\n      groupId\n    });\n    committedOffsets[topic] = committedOffsets[topic] || {};\n    committedOffsets[topic][partition] = offset;\n  }\n\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/cluster/index.js"],"names":["BrokerPool","require","Lock","createRetry","connectionBuilder","flatten","EARLIEST_OFFSET","LATEST_OFFSET","KafkaJSError","KafkaJSBrokerNotFound","KafkaJSMetadataNotLoaded","KafkaJSTopicMetadataNotLoaded","KafkaJSGroupCoordinatorNotFound","COORDINATOR_TYPES","keys","Object","mergeTopics","obj","topic","partitions","module","exports","Cluster","constructor","logger","rootLogger","socketFactory","brokers","ssl","sasl","clientId","connectionTimeout","authenticationTimeout","reauthenticationThreshold","requestTimeout","enforceRequestTimeout","metadataMaxAge","retry","allowAutoTopicCreation","maxInFlightRequests","isolationLevel","instrumentationEmitter","offsets","Map","namespace","retrier","targetTopics","Set","mutatingTargetTopics","description","timeout","brokerPool","committedOffsetsByGroup","isConnected","hasConnectedBrokers","connect","disconnect","removeBroker","host","port","refreshMetadata","Array","from","refreshMetadataIfNecessary","metadata","topics","bail","retryCount","retryTime","withBroker","broker","e","type","addTargetTopic","addMultipleTargetTopics","acquire","previousSize","size","previousTopics","add","hasChanged","release","findBroker","nodeId","name","findControllerBroker","controllerId","findTopicPartitionMetadata","topicMetadata","find","t","partitionMetadata","findLeaderForPartitions","reduce","result","id","partitionId","parseInt","p","leader","undefined","current","findGroupCoordinator","groupId","coordinatorType","GROUP","coordinator","findGroupCoordinatorMetadata","debug","message","code","brokerMetadata","error","defaultOffset","fromBeginning","fetchTopicsOffset","partitionsPerBroker","topicConfigurations","addDefaultOffset","partition","timestamp","topicData","fromTimestamp","partitionsPerLeader","map","filter","includes","requests","responses","topicOffsets","listOffsets","Promise","all","partitionsPerTopic","offset","committedOffsets","has","set","get","markOffsetAsCommitted"],"mappings":"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","sourcesContent":["const BrokerPool = require('./brokerPool')\nconst Lock = require('../utils/lock')\nconst createRetry = require('../retry')\nconst connectionBuilder = require('./connectionBuilder')\nconst flatten = require('../utils/flatten')\nconst { EARLIEST_OFFSET, LATEST_OFFSET } = require('../constants')\nconst {\n  KafkaJSError,\n  KafkaJSBrokerNotFound,\n  KafkaJSMetadataNotLoaded,\n  KafkaJSTopicMetadataNotLoaded,\n  KafkaJSGroupCoordinatorNotFound,\n} = require('../errors')\nconst COORDINATOR_TYPES = require('../protocol/coordinatorTypes')\n\nconst { keys } = Object\n\nconst mergeTopics = (obj, { topic, partitions }) => ({\n  ...obj,\n  [topic]: [...(obj[topic] || []), ...partitions],\n})\n\nmodule.exports = class Cluster {\n  /**\n   * @param {Object} options\n   * @param {Array<string>} options.brokers example: ['127.0.0.1:9092', '127.0.0.1:9094']\n   * @param {Object} options.ssl\n   * @param {Object} options.sasl\n   * @param {string} options.clientId\n   * @param {number} options.connectionTimeout - in milliseconds\n   * @param {number} options.authenticationTimeout - in milliseconds\n   * @param {number} options.reauthenticationThreshold - in milliseconds\n   * @param {number} [options.requestTimeout=30000] - in milliseconds\n   * @param {number} options.metadataMaxAge - in milliseconds\n   * @param {boolean} options.allowAutoTopicCreation\n   * @param {number} options.maxInFlightRequests\n   * @param {number} options.isolationLevel\n   * @param {Object} options.retry\n   * @param {import(\"../../types\").Logger} options.logger\n   * @param {Map} options.offsets\n   * @param {import(\"../instrumentation/emitter\")} [options.instrumentationEmitter=null]\n   */\n  constructor({\n    logger: rootLogger,\n    socketFactory,\n    brokers,\n    ssl,\n    sasl,\n    clientId,\n    connectionTimeout,\n    authenticationTimeout,\n    reauthenticationThreshold,\n    requestTimeout = 30000,\n    enforceRequestTimeout,\n    metadataMaxAge,\n    retry,\n    allowAutoTopicCreation,\n    maxInFlightRequests,\n    isolationLevel,\n    instrumentationEmitter = null,\n    offsets = new Map(),\n  }) {\n    this.rootLogger = rootLogger\n    this.logger = rootLogger.namespace('Cluster')\n    this.retry = { ...retry }\n    this.retrier = createRetry(this.retry)\n    this.connectionBuilder = connectionBuilder({\n      logger: rootLogger,\n      instrumentationEmitter,\n      socketFactory,\n      brokers,\n      ssl,\n      sasl,\n      clientId,\n      connectionTimeout,\n      requestTimeout,\n      enforceRequestTimeout,\n      maxInFlightRequests,\n      retry,\n    })\n\n    this.targetTopics = new Set()\n    this.mutatingTargetTopics = new Lock({\n      description: `updating target topics`,\n      timeout: requestTimeout,\n    })\n    this.isolationLevel = isolationLevel\n    this.brokerPool = new BrokerPool({\n      connectionBuilder: this.connectionBuilder,\n      logger: this.rootLogger,\n      retry,\n      allowAutoTopicCreation,\n      authenticationTimeout,\n      reauthenticationThreshold,\n      metadataMaxAge,\n    })\n    this.committedOffsetsByGroup = offsets\n  }\n\n  isConnected() {\n    return this.brokerPool.hasConnectedBrokers()\n  }\n\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n  async connect() {\n    await this.brokerPool.connect()\n  }\n\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n  async disconnect() {\n    await this.brokerPool.disconnect()\n  }\n\n  /**\n   * @public\n   * @param {String} host\n   * @param {Number} port\n   */\n  removeBroker({ host, port }) {\n    this.brokerPool.removeBroker({ host, port })\n  }\n\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n  async refreshMetadata() {\n    await this.brokerPool.refreshMetadata(Array.from(this.targetTopics))\n  }\n\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n  async refreshMetadataIfNecessary() {\n    await this.brokerPool.refreshMetadataIfNecessary(Array.from(this.targetTopics))\n  }\n\n  /**\n   * @public\n   * @returns {Promise<Metadata>}\n   */\n  async metadata({ topics = [] } = {}) {\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await this.brokerPool.refreshMetadataIfNecessary(topics)\n        return this.brokerPool.withBroker(async ({ broker }) => broker.metadata(topics))\n      } catch (e) {\n        if (e.type === 'LEADER_NOT_AVAILABLE') {\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @param {string} topic\n   * @return {Promise}\n   */\n  async addTargetTopic(topic) {\n    return this.addMultipleTargetTopics([topic])\n  }\n\n  /**\n   * @public\n   * @param {string[]} topics\n   * @return {Promise}\n   */\n  async addMultipleTargetTopics(topics) {\n    await this.mutatingTargetTopics.acquire()\n\n    try {\n      const previousSize = this.targetTopics.size\n      const previousTopics = new Set(this.targetTopics)\n      for (const topic of topics) {\n        this.targetTopics.add(topic)\n      }\n\n      const hasChanged = previousSize !== this.targetTopics.size || !this.brokerPool.metadata\n\n      if (hasChanged) {\n        try {\n          await this.refreshMetadata()\n        } catch (e) {\n          if (e.type === 'INVALID_TOPIC_EXCEPTION' || e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n            this.targetTopics = previousTopics\n          }\n\n          throw e\n        }\n      }\n    } finally {\n      await this.mutatingTargetTopics.release()\n    }\n  }\n\n  /**\n   * @public\n   * @param {string} nodeId\n   * @returns {Promise<Broker>}\n   */\n  async findBroker({ nodeId }) {\n    try {\n      return await this.brokerPool.findBroker({ nodeId })\n    } catch (e) {\n      // The client probably has stale metadata\n      if (\n        e.name === 'KafkaJSBrokerNotFound' ||\n        e.name === 'KafkaJSLockTimeout' ||\n        e.name === 'KafkaJSConnectionError'\n      ) {\n        await this.refreshMetadata()\n      }\n\n      throw e\n    }\n  }\n\n  /**\n   * @public\n   * @returns {Promise<Broker>}\n   */\n  async findControllerBroker() {\n    const { metadata } = this.brokerPool\n\n    if (!metadata || metadata.controllerId == null) {\n      throw new KafkaJSMetadataNotLoaded('Topic metadata not loaded')\n    }\n\n    const broker = await this.findBroker({ nodeId: metadata.controllerId })\n\n    if (!broker) {\n      throw new KafkaJSBrokerNotFound(\n        `Controller broker with id ${metadata.controllerId} not found in the cached metadata`\n      )\n    }\n\n    return broker\n  }\n\n  /**\n   * @public\n   * @param {string} topic\n   * @returns {import(\"../../types\").PartitionMetadata[]} Example:\n   *                   [{\n   *                     isr: [2],\n   *                     leader: 2,\n   *                     partitionErrorCode: 0,\n   *                     partitionId: 0,\n   *                     replicas: [2],\n   *                   }]\n   */\n  findTopicPartitionMetadata(topic) {\n    const { metadata } = this.brokerPool\n    if (!metadata || !metadata.topicMetadata) {\n      throw new KafkaJSTopicMetadataNotLoaded('Topic metadata not loaded', { topic })\n    }\n\n    const topicMetadata = metadata.topicMetadata.find(t => t.topic === topic)\n    return topicMetadata ? topicMetadata.partitionMetadata : []\n  }\n\n  /**\n   * @public\n   * @param {string} topic\n   * @param {Array<number>} partitions\n   * @returns {Object} Object with leader and partitions. For partitions 0 and 5\n   *                   the result could be:\n   *                     { '0': [0], '2': [5] }\n   *\n   *                   where the key is the nodeId.\n   */\n  findLeaderForPartitions(topic, partitions) {\n    const partitionMetadata = this.findTopicPartitionMetadata(topic)\n    return partitions.reduce((result, id) => {\n      const partitionId = parseInt(id, 10)\n      const metadata = partitionMetadata.find(p => p.partitionId === partitionId)\n\n      if (!metadata) {\n        return result\n      }\n\n      if (metadata.leader === null || metadata.leader === undefined) {\n        throw new KafkaJSError('Invalid partition metadata', { topic, partitionId, metadata })\n      }\n\n      const { leader } = metadata\n      const current = result[leader] || []\n      return { ...result, [leader]: [...current, partitionId] }\n    }, {})\n  }\n\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {number} [coordinatorType=0]\n   * @returns {Promise<Broker>}\n   */\n  async findGroupCoordinator({ groupId, coordinatorType = COORDINATOR_TYPES.GROUP }) {\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        const { coordinator } = await this.findGroupCoordinatorMetadata({\n          groupId,\n          coordinatorType,\n        })\n        return await this.findBroker({ nodeId: coordinator.nodeId })\n      } catch (e) {\n        // A new broker can join the cluster before we have the chance\n        // to refresh metadata\n        if (e.name === 'KafkaJSBrokerNotFound' || e.type === 'GROUP_COORDINATOR_NOT_AVAILABLE') {\n          this.logger.debug(`${e.message}, refreshing metadata and trying again...`, {\n            groupId,\n            retryCount,\n            retryTime,\n          })\n\n          await this.refreshMetadata()\n          throw e\n        }\n\n        if (e.code === 'ECONNREFUSED') {\n          // During maintenance the current coordinator can go down; findBroker will\n          // refresh metadata and re-throw the error. findGroupCoordinator has to re-throw\n          // the error to go through the retry cycle.\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @param {string} groupId\n   * @param {number} [coordinatorType=0]\n   * @returns {Promise<Object>}\n   */\n  async findGroupCoordinatorMetadata({ groupId, coordinatorType }) {\n    const brokerMetadata = await this.brokerPool.withBroker(async ({ nodeId, broker }) => {\n      return await this.retrier(async (bail, retryCount, retryTime) => {\n        try {\n          const brokerMetadata = await broker.findGroupCoordinator({ groupId, coordinatorType })\n          this.logger.debug('Found group coordinator', {\n            broker: brokerMetadata.host,\n            nodeId: brokerMetadata.coordinator.nodeId,\n          })\n          return brokerMetadata\n        } catch (e) {\n          this.logger.debug('Tried to find group coordinator', {\n            nodeId,\n            error: e,\n          })\n\n          if (e.type === 'GROUP_COORDINATOR_NOT_AVAILABLE') {\n            this.logger.debug('Group coordinator not available, retrying...', {\n              nodeId,\n              retryCount,\n              retryTime,\n            })\n\n            throw e\n          }\n\n          bail(e)\n        }\n      })\n    })\n\n    if (brokerMetadata) {\n      return brokerMetadata\n    }\n\n    throw new KafkaJSGroupCoordinatorNotFound('Failed to find group coordinator')\n  }\n\n  /**\n   * @param {object} topicConfiguration\n   * @returns {number}\n   */\n  defaultOffset({ fromBeginning }) {\n    return fromBeginning ? EARLIEST_OFFSET : LATEST_OFFSET\n  }\n\n  /**\n   * @public\n   * @param {Array<Object>} topics\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [{ partition: 0 }],\n   *                              fromBeginning: false\n   *                            }\n   *                          ]\n   * @returns {Promise<Array>} example:\n   *                          [\n   *                            {\n   *                              topic: 'my-topic-name',\n   *                              partitions: [\n   *                                { partition: 0, offset: '1' },\n   *                                { partition: 1, offset: '2' },\n   *                                { partition: 2, offset: '1' },\n   *                              ],\n   *                            },\n   *                          ]\n   */\n  async fetchTopicsOffset(topics) {\n    const partitionsPerBroker = {}\n    const topicConfigurations = {}\n\n    const addDefaultOffset = topic => partition => {\n      const { timestamp } = topicConfigurations[topic]\n      return { ...partition, timestamp }\n    }\n\n    // Index all topics and partitions per leader (nodeId)\n    for (const topicData of topics) {\n      const { topic, partitions, fromBeginning, fromTimestamp } = topicData\n      const partitionsPerLeader = this.findLeaderForPartitions(\n        topic,\n        partitions.map(p => p.partition)\n      )\n      const timestamp =\n        fromTimestamp != null ? fromTimestamp : this.defaultOffset({ fromBeginning })\n\n      topicConfigurations[topic] = { timestamp }\n\n      keys(partitionsPerLeader).map(nodeId => {\n        partitionsPerBroker[nodeId] = partitionsPerBroker[nodeId] || {}\n        partitionsPerBroker[nodeId][topic] = partitions.filter(p =>\n          partitionsPerLeader[nodeId].includes(p.partition)\n        )\n      })\n    }\n\n    // Create a list of requests to fetch the offset of all partitions\n    const requests = keys(partitionsPerBroker).map(async nodeId => {\n      const broker = await this.findBroker({ nodeId })\n      const partitions = partitionsPerBroker[nodeId]\n\n      const { responses: topicOffsets } = await broker.listOffsets({\n        isolationLevel: this.isolationLevel,\n        topics: keys(partitions).map(topic => ({\n          topic,\n          partitions: partitions[topic].map(addDefaultOffset(topic)),\n        })),\n      })\n\n      return topicOffsets\n    })\n\n    // Execute all requests, merge and normalize the responses\n    const responses = await Promise.all(requests)\n    const partitionsPerTopic = flatten(responses).reduce(mergeTopics, {})\n\n    return keys(partitionsPerTopic).map(topic => ({\n      topic,\n      partitions: partitionsPerTopic[topic].map(({ partition, offset }) => ({\n        partition,\n        offset,\n      })),\n    }))\n  }\n\n  /**\n   * Retrieve the object mapping for committed offsets for a single consumer group\n   * @param {string} groupId\n   * @returns {Object}\n   */\n  committedOffsets({ groupId }) {\n    if (!this.committedOffsetsByGroup.has(groupId)) {\n      this.committedOffsetsByGroup.set(groupId, {})\n    }\n\n    return this.committedOffsetsByGroup.get(groupId)\n  }\n\n  /**\n   * Mark offset as committed for a single consumer group's topic-partition\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {string|number} partition\n   * @param {string} offset\n   * @returns {undefined}\n   */\n  markOffsetAsCommitted({ groupId, topic, partition, offset }) {\n    const committedOffsets = this.committedOffsets({ groupId })\n\n    committedOffsets[topic] = committedOffsets[topic] || {}\n    committedOffsets[topic][partition] = offset\n  }\n}\n"]},"metadata":{},"sourceType":"script"}