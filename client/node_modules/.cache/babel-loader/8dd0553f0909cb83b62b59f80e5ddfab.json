{"ast":null,"code":"/**\n * http://www.ietf.org/rfc/rfc5801.txt\n *\n * See org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse\n * for official Java client implementation.\n *\n * The mechanism consists of a message from the client to the server.\n * The client sends the \"n,\"\" GS header, followed by the authorizationIdentitty\n * prefixed by \"a=\" (if present), followed by \",\", followed by a US-ASCII SOH\n * character, followed by \"auth=Bearer \", followed by the token value, followed\n * by US-ASCII SOH character, followed by SASL extensions in OAuth \"friendly\"\n * format and then closed by two additionals US-ASCII SOH characters.\n *\n * SASL extensions are optional an must be expressed as key-value pairs in an\n * object. Each expression is converted as, the extension entry key, followed\n * by \"=\", followed by extension entry value. Each extension is separated by a\n * US-ASCII SOH character. If extensions are not present, their relative part\n * in the message, including the US-ASCII SOH character, is omitted.\n *\n * The client may leave the authorization identity empty to\n * indicate that it is the same as the authentication identity.\n *\n * The server will verify the authentication token and verify that the\n * authentication credentials permit the client to login as the authorization\n * identity. If both steps succeed, the user is logged in.\n */\nconst Encoder = require('../../encoder');\n\nconst SEPARATOR = '\\u0001'; // SOH - Start Of Header ASCII\n\nfunction formatExtensions(extensions) {\n  let msg = '';\n\n  if (extensions == null) {\n    return msg;\n  }\n\n  let prefix = '';\n\n  for (const k in extensions) {\n    msg += `${prefix}${k}=${extensions[k]}`;\n    prefix = SEPARATOR;\n  }\n\n  return msg;\n}\n\nmodule.exports = async ({\n  authorizationIdentity = null\n}, oauthBearerToken) => {\n  const authzid = authorizationIdentity == null ? '' : `\"a=${authorizationIdentity}`;\n  let ext = formatExtensions(oauthBearerToken.extensions);\n\n  if (ext.length > 0) {\n    ext = `${SEPARATOR}${ext}`;\n  }\n\n  const oauthMsg = `n,${authzid},${SEPARATOR}auth=Bearer ${oauthBearerToken.value}${ext}${SEPARATOR}${SEPARATOR}`;\n  return {\n    encode: async () => {\n      return new Encoder().writeBytes(Buffer.from(oauthMsg));\n    }\n  };\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/protocol/sasl/oauthBearer/request.js"],"names":["Encoder","require","SEPARATOR","formatExtensions","extensions","msg","prefix","k","module","exports","authorizationIdentity","oauthBearerToken","authzid","ext","length","oauthMsg","value","encode","writeBytes","Buffer","from"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,eAAD,CAAvB;;AAEA,MAAMC,SAAS,GAAG,QAAlB,C,CAA2B;;AAE3B,SAASC,gBAAT,CAA0BC,UAA1B,EAAsC;AACpC,MAAIC,GAAG,GAAG,EAAV;;AAEA,MAAID,UAAU,IAAI,IAAlB,EAAwB;AACtB,WAAOC,GAAP;AACD;;AAED,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,MAAMC,CAAX,IAAgBH,UAAhB,EAA4B;AAC1BC,IAAAA,GAAG,IAAK,GAAEC,MAAO,GAAEC,CAAE,IAAGH,UAAU,CAACG,CAAD,CAAI,EAAtC;AACAD,IAAAA,MAAM,GAAGJ,SAAT;AACD;;AAED,SAAOG,GAAP;AACD;;AAEDG,MAAM,CAACC,OAAP,GAAiB,OAAO;AAAEC,EAAAA,qBAAqB,GAAG;AAA1B,CAAP,EAAyCC,gBAAzC,KAA8D;AAC7E,QAAMC,OAAO,GAAGF,qBAAqB,IAAI,IAAzB,GAAgC,EAAhC,GAAsC,MAAKA,qBAAsB,EAAjF;AACA,MAAIG,GAAG,GAAGV,gBAAgB,CAACQ,gBAAgB,CAACP,UAAlB,CAA1B;;AACA,MAAIS,GAAG,CAACC,MAAJ,GAAa,CAAjB,EAAoB;AAClBD,IAAAA,GAAG,GAAI,GAAEX,SAAU,GAAEW,GAAI,EAAzB;AACD;;AAED,QAAME,QAAQ,GAAI,KAAIH,OAAQ,IAAGV,SAAU,eAAcS,gBAAgB,CAACK,KAAM,GAAEH,GAAI,GAAEX,SAAU,GAAEA,SAAU,EAA9G;AAEA,SAAO;AACLe,IAAAA,MAAM,EAAE,YAAY;AAClB,aAAO,IAAIjB,OAAJ,GAAckB,UAAd,CAAyBC,MAAM,CAACC,IAAP,CAAYL,QAAZ,CAAzB,CAAP;AACD;AAHI,GAAP;AAKD,CAdD","sourcesContent":["/**\n * http://www.ietf.org/rfc/rfc5801.txt\n *\n * See org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse\n * for official Java client implementation.\n *\n * The mechanism consists of a message from the client to the server.\n * The client sends the \"n,\"\" GS header, followed by the authorizationIdentitty\n * prefixed by \"a=\" (if present), followed by \",\", followed by a US-ASCII SOH\n * character, followed by \"auth=Bearer \", followed by the token value, followed\n * by US-ASCII SOH character, followed by SASL extensions in OAuth \"friendly\"\n * format and then closed by two additionals US-ASCII SOH characters.\n *\n * SASL extensions are optional an must be expressed as key-value pairs in an\n * object. Each expression is converted as, the extension entry key, followed\n * by \"=\", followed by extension entry value. Each extension is separated by a\n * US-ASCII SOH character. If extensions are not present, their relative part\n * in the message, including the US-ASCII SOH character, is omitted.\n *\n * The client may leave the authorization identity empty to\n * indicate that it is the same as the authentication identity.\n *\n * The server will verify the authentication token and verify that the\n * authentication credentials permit the client to login as the authorization\n * identity. If both steps succeed, the user is logged in.\n */\n\nconst Encoder = require('../../encoder')\n\nconst SEPARATOR = '\\u0001' // SOH - Start Of Header ASCII\n\nfunction formatExtensions(extensions) {\n  let msg = ''\n\n  if (extensions == null) {\n    return msg\n  }\n\n  let prefix = ''\n  for (const k in extensions) {\n    msg += `${prefix}${k}=${extensions[k]}`\n    prefix = SEPARATOR\n  }\n\n  return msg\n}\n\nmodule.exports = async ({ authorizationIdentity = null }, oauthBearerToken) => {\n  const authzid = authorizationIdentity == null ? '' : `\"a=${authorizationIdentity}`\n  let ext = formatExtensions(oauthBearerToken.extensions)\n  if (ext.length > 0) {\n    ext = `${SEPARATOR}${ext}`\n  }\n\n  const oauthMsg = `n,${authzid},${SEPARATOR}auth=Bearer ${oauthBearerToken.value}${ext}${SEPARATOR}${SEPARATOR}`\n\n  return {\n    encode: async () => {\n      return new Encoder().writeBytes(Buffer.from(oauthMsg))\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"script"}