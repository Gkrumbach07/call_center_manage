{"ast":null,"code":"const {\n  MemberMetadata,\n  MemberAssignment\n} = require('../../assignerProtocol');\n\nconst flatten = require('../../../utils/flatten');\n/**\n * RoundRobinAssigner\n * @param {Cluster} cluster\n * @returns {function}\n */\n\n\nmodule.exports = ({\n  cluster\n}) => ({\n  name: 'RoundRobinAssigner',\n  version: 1,\n\n  /**\n   * Assign the topics to the provided members.\n   *\n   * The members array contains information about each member, `memberMetadata` is the result of the\n   * `protocol` operation.\n   *\n   * @param {array} members array of members, e.g:\n                              [{ memberId: 'test-5f93f5a3', memberMetadata: Buffer }]\n   * @param {array} topics\n   * @returns {array} object partitions per topic per member, e.g:\n   *                   [\n   *                     {\n   *                       memberId: 'test-5f93f5a3',\n   *                       memberAssignment: {\n   *                         'topic-A': [0, 2, 4, 6],\n   *                         'topic-B': [1],\n   *                       },\n   *                     },\n   *                     {\n   *                       memberId: 'test-3d3d5341',\n   *                       memberAssignment: {\n   *                         'topic-A': [1, 3, 5],\n   *                         'topic-B': [0, 2],\n   *                       },\n   *                     }\n   *                   ]\n   */\n  async assign({\n    members,\n    topics\n  }) {\n    const membersCount = members.length;\n    const sortedMembers = members.map(({\n      memberId\n    }) => memberId).sort();\n    const assignment = {};\n    const topicsPartionArrays = topics.map(topic => {\n      const partitionMetadata = cluster.findTopicPartitionMetadata(topic);\n      return partitionMetadata.map(m => ({\n        topic: topic,\n        partitionId: m.partitionId\n      }));\n    });\n    const topicsPartitions = flatten(topicsPartionArrays);\n    topicsPartitions.forEach((topicPartition, i) => {\n      const assignee = sortedMembers[i % membersCount];\n\n      if (!assignment[assignee]) {\n        assignment[assignee] = [];\n      }\n\n      if (!assignment[assignee][topicPartition.topic]) {\n        assignment[assignee][topicPartition.topic] = [];\n      }\n\n      assignment[assignee][topicPartition.topic].push(topicPartition.partitionId);\n    });\n    return Object.keys(assignment).map(memberId => ({\n      memberId,\n      memberAssignment: MemberAssignment.encode({\n        version: this.version,\n        assignment: assignment[memberId]\n      })\n    }));\n  },\n\n  protocol({\n    topics\n  }) {\n    return {\n      name: this.name,\n      metadata: MemberMetadata.encode({\n        version: this.version,\n        topics\n      })\n    };\n  }\n\n});","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/consumer/assigners/roundRobinAssigner/index.js"],"names":["MemberMetadata","MemberAssignment","require","flatten","module","exports","cluster","name","version","assign","members","topics","membersCount","length","sortedMembers","map","memberId","sort","assignment","topicsPartionArrays","topic","partitionMetadata","findTopicPartitionMetadata","m","partitionId","topicsPartitions","forEach","topicPartition","i","assignee","push","Object","keys","memberAssignment","encode","protocol","metadata"],"mappings":"AAAA,MAAM;AAAEA,EAAAA,cAAF;AAAkBC,EAAAA;AAAlB,IAAuCC,OAAO,CAAC,wBAAD,CAApD;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,wBAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;;;AACAE,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA;AAAF,CAAD,MAAkB;AACjCC,EAAAA,IAAI,EAAE,oBAD2B;AAEjCC,EAAAA,OAAO,EAAE,CAFwB;;AAIjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,QAAMC,MAAN,CAAa;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,GAAb,EAAkC;AAChC,UAAMC,YAAY,GAAGF,OAAO,CAACG,MAA7B;AACA,UAAMC,aAAa,GAAGJ,OAAO,CAACK,GAAR,CAAY,CAAC;AAAEC,MAAAA;AAAF,KAAD,KAAkBA,QAA9B,EAAwCC,IAAxC,EAAtB;AACA,UAAMC,UAAU,GAAG,EAAnB;AAEA,UAAMC,mBAAmB,GAAGR,MAAM,CAACI,GAAP,CAAWK,KAAK,IAAI;AAC9C,YAAMC,iBAAiB,GAAGf,OAAO,CAACgB,0BAAR,CAAmCF,KAAnC,CAA1B;AACA,aAAOC,iBAAiB,CAACN,GAAlB,CAAsBQ,CAAC,KAAK;AAAEH,QAAAA,KAAK,EAAEA,KAAT;AAAgBI,QAAAA,WAAW,EAAED,CAAC,CAACC;AAA/B,OAAL,CAAvB,CAAP;AACD,KAH2B,CAA5B;AAIA,UAAMC,gBAAgB,GAAGtB,OAAO,CAACgB,mBAAD,CAAhC;AAEAM,IAAAA,gBAAgB,CAACC,OAAjB,CAAyB,CAACC,cAAD,EAAiBC,CAAjB,KAAuB;AAC9C,YAAMC,QAAQ,GAAGf,aAAa,CAACc,CAAC,GAAGhB,YAAL,CAA9B;;AAEA,UAAI,CAACM,UAAU,CAACW,QAAD,CAAf,EAA2B;AACzBX,QAAAA,UAAU,CAACW,QAAD,CAAV,GAAuB,EAAvB;AACD;;AAED,UAAI,CAACX,UAAU,CAACW,QAAD,CAAV,CAAqBF,cAAc,CAACP,KAApC,CAAL,EAAiD;AAC/CF,QAAAA,UAAU,CAACW,QAAD,CAAV,CAAqBF,cAAc,CAACP,KAApC,IAA6C,EAA7C;AACD;;AAEDF,MAAAA,UAAU,CAACW,QAAD,CAAV,CAAqBF,cAAc,CAACP,KAApC,EAA2CU,IAA3C,CAAgDH,cAAc,CAACH,WAA/D;AACD,KAZD;AAcA,WAAOO,MAAM,CAACC,IAAP,CAAYd,UAAZ,EAAwBH,GAAxB,CAA4BC,QAAQ,KAAK;AAC9CA,MAAAA,QAD8C;AAE9CiB,MAAAA,gBAAgB,EAAEhC,gBAAgB,CAACiC,MAAjB,CAAwB;AACxC1B,QAAAA,OAAO,EAAE,KAAKA,OAD0B;AAExCU,QAAAA,UAAU,EAAEA,UAAU,CAACF,QAAD;AAFkB,OAAxB;AAF4B,KAAL,CAApC,CAAP;AAOD,GA/DgC;;AAiEjCmB,EAAAA,QAAQ,CAAC;AAAExB,IAAAA;AAAF,GAAD,EAAa;AACnB,WAAO;AACLJ,MAAAA,IAAI,EAAE,KAAKA,IADN;AAEL6B,MAAAA,QAAQ,EAAEpC,cAAc,CAACkC,MAAf,CAAsB;AAC9B1B,QAAAA,OAAO,EAAE,KAAKA,OADgB;AAE9BG,QAAAA;AAF8B,OAAtB;AAFL,KAAP;AAOD;;AAzEgC,CAAlB,CAAjB","sourcesContent":["const { MemberMetadata, MemberAssignment } = require('../../assignerProtocol')\nconst flatten = require('../../../utils/flatten')\n\n/**\n * RoundRobinAssigner\n * @param {Cluster} cluster\n * @returns {function}\n */\nmodule.exports = ({ cluster }) => ({\n  name: 'RoundRobinAssigner',\n  version: 1,\n\n  /**\n   * Assign the topics to the provided members.\n   *\n   * The members array contains information about each member, `memberMetadata` is the result of the\n   * `protocol` operation.\n   *\n   * @param {array} members array of members, e.g:\n                              [{ memberId: 'test-5f93f5a3', memberMetadata: Buffer }]\n   * @param {array} topics\n   * @returns {array} object partitions per topic per member, e.g:\n   *                   [\n   *                     {\n   *                       memberId: 'test-5f93f5a3',\n   *                       memberAssignment: {\n   *                         'topic-A': [0, 2, 4, 6],\n   *                         'topic-B': [1],\n   *                       },\n   *                     },\n   *                     {\n   *                       memberId: 'test-3d3d5341',\n   *                       memberAssignment: {\n   *                         'topic-A': [1, 3, 5],\n   *                         'topic-B': [0, 2],\n   *                       },\n   *                     }\n   *                   ]\n   */\n  async assign({ members, topics }) {\n    const membersCount = members.length\n    const sortedMembers = members.map(({ memberId }) => memberId).sort()\n    const assignment = {}\n\n    const topicsPartionArrays = topics.map(topic => {\n      const partitionMetadata = cluster.findTopicPartitionMetadata(topic)\n      return partitionMetadata.map(m => ({ topic: topic, partitionId: m.partitionId }))\n    })\n    const topicsPartitions = flatten(topicsPartionArrays)\n\n    topicsPartitions.forEach((topicPartition, i) => {\n      const assignee = sortedMembers[i % membersCount]\n\n      if (!assignment[assignee]) {\n        assignment[assignee] = []\n      }\n\n      if (!assignment[assignee][topicPartition.topic]) {\n        assignment[assignee][topicPartition.topic] = []\n      }\n\n      assignment[assignee][topicPartition.topic].push(topicPartition.partitionId)\n    })\n\n    return Object.keys(assignment).map(memberId => ({\n      memberId,\n      memberAssignment: MemberAssignment.encode({\n        version: this.version,\n        assignment: assignment[memberId],\n      }),\n    }))\n  },\n\n  protocol({ topics }) {\n    return {\n      name: this.name,\n      metadata: MemberMetadata.encode({\n        version: this.version,\n        topics,\n      }),\n    }\n  },\n})\n"]},"metadata":{},"sourceType":"script"}