{"ast":null,"code":"const crypto = require('crypto');\n\nconst scram = require('../../protocol/sasl/scram');\n\nconst {\n  KafkaJSSASLAuthenticationError,\n  KafkaJSNonRetriableError\n} = require('../../errors');\n\nconst GS2_HEADER = 'n,,';\nconst EQUAL_SIGN_REGEX = /=/g;\nconst COMMA_SIGN_REGEX = /,/g;\nconst URLSAFE_BASE64_PLUS_REGEX = /\\+/g;\nconst URLSAFE_BASE64_SLASH_REGEX = /\\//g;\nconst URLSAFE_BASE64_TRAILING_EQUAL_REGEX = /=+$/;\nconst HMAC_CLIENT_KEY = 'Client Key';\nconst HMAC_SERVER_KEY = 'Server Key';\nconst DIGESTS = {\n  SHA256: {\n    length: 32,\n    type: 'sha256',\n    minIterations: 4096\n  },\n  SHA512: {\n    length: 64,\n    type: 'sha512',\n    minIterations: 4096\n  }\n};\n\nconst encode64 = str => Buffer.from(str).toString('base64');\n\nclass SCRAM {\n  /**\n   * From https://tools.ietf.org/html/rfc5802#section-5.1\n   *\n   * The characters ',' or '=' in usernames are sent as '=2C' and\n   * '=3D' respectively.  If the server receives a username that\n   * contains '=' not followed by either '2C' or '3D', then the\n   * server MUST fail the authentication.\n   *\n   * @returns {String}\n   */\n  static sanitizeString(str) {\n    return str.replace(EQUAL_SIGN_REGEX, '=3D').replace(COMMA_SIGN_REGEX, '=2C');\n  }\n  /**\n   * In cryptography, a nonce is an arbitrary number that can be used just once.\n   * It is similar in spirit to a nonce * word, hence the name. It is often a random or pseudo-random\n   * number issued in an authentication protocol to * ensure that old communications cannot be reused\n   * in replay attacks.\n   *\n   * @returns {String}\n   */\n\n\n  static nonce() {\n    return crypto.randomBytes(16).toString('base64').replace(URLSAFE_BASE64_PLUS_REGEX, '-') // make it url safe\n    .replace(URLSAFE_BASE64_SLASH_REGEX, '_').replace(URLSAFE_BASE64_TRAILING_EQUAL_REGEX, '').toString('ascii');\n  }\n  /**\n   * Hi() is, essentially, PBKDF2 [RFC2898] with HMAC() as the\n   * pseudorandom function (PRF) and with dkLen == output length of\n   * HMAC() == output length of H()\n   *\n   * @returns {Promise<Buffer>}\n   */\n\n\n  static hi(password, salt, iterations, digestDefinition) {\n    return new Promise((resolve, reject) => {\n      crypto.pbkdf2(password, salt, iterations, digestDefinition.length, digestDefinition.type, (err, derivedKey) => err ? reject(err) : resolve(derivedKey));\n    });\n  }\n  /**\n   * Apply the exclusive-or operation to combine the octet string\n   * on the left of this operator with the octet string on the right of\n   * this operator.  The length of the output and each of the two\n   * inputs will be the same for this use\n   *\n   * @returns {Buffer}\n   */\n\n\n  static xor(left, right) {\n    const bufferA = Buffer.from(left);\n    const bufferB = Buffer.from(right);\n    const length = Buffer.byteLength(bufferA);\n\n    if (length !== Buffer.byteLength(bufferB)) {\n      throw new KafkaJSNonRetriableError('Buffers must be of the same length');\n    }\n\n    const result = [];\n\n    for (let i = 0; i < length; i++) {\n      result.push(bufferA[i] ^ bufferB[i]);\n    }\n\n    return Buffer.from(result);\n  }\n  /**\n   * @param {Connection} connection\n   * @param {Logger} logger\n   * @param {Function} saslAuthenticate\n   * @param {DigestDefinition} digestDefinition\n   */\n\n\n  constructor(connection, logger, saslAuthenticate, digestDefinition) {\n    this.connection = connection;\n    this.logger = logger;\n    this.saslAuthenticate = saslAuthenticate;\n    this.digestDefinition = digestDefinition;\n    const digestType = digestDefinition.type.toUpperCase();\n    this.PREFIX = `SASL SCRAM ${digestType} authentication`;\n    this.currentNonce = SCRAM.nonce();\n  }\n\n  async authenticate() {\n    const {\n      PREFIX\n    } = this;\n    const {\n      host,\n      port,\n      sasl\n    } = this.connection;\n    const broker = `${host}:${port}`;\n\n    if (sasl.username == null || sasl.password == null) {\n      throw new KafkaJSSASLAuthenticationError(`${this.PREFIX}: Invalid username or password`);\n    }\n\n    try {\n      this.logger.debug('Exchanging first client message', {\n        broker\n      });\n      const clientMessageResponse = await this.sendClientFirstMessage();\n      this.logger.debug('Sending final message', {\n        broker\n      });\n      const finalResponse = await this.sendClientFinalMessage(clientMessageResponse);\n\n      if (finalResponse.e) {\n        throw new Error(finalResponse.e);\n      }\n\n      const serverKey = await this.serverKey(clientMessageResponse);\n      const serverSignature = this.serverSignature(serverKey, clientMessageResponse);\n\n      if (finalResponse.v !== serverSignature) {\n        throw new Error('Invalid server signature in server final message');\n      }\n\n      this.logger.debug(`${PREFIX} successful`, {\n        broker\n      });\n    } catch (e) {\n      const error = new KafkaJSSASLAuthenticationError(`${PREFIX} failed: ${e.message}`);\n      this.logger.error(error.message, {\n        broker\n      });\n      throw error;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  async sendClientFirstMessage() {\n    const clientFirstMessage = `${GS2_HEADER}${this.firstMessageBare()}`;\n    const request = scram.firstMessage.request({\n      clientFirstMessage\n    });\n    const response = scram.firstMessage.response;\n    return this.saslAuthenticate({\n      authExpectResponse: true,\n      request,\n      response\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  async sendClientFinalMessage(clientMessageResponse) {\n    const {\n      PREFIX\n    } = this;\n    const iterations = parseInt(clientMessageResponse.i, 10);\n    const {\n      minIterations\n    } = this.digestDefinition;\n\n    if (!clientMessageResponse.r.startsWith(this.currentNonce)) {\n      throw new KafkaJSSASLAuthenticationError(`${PREFIX} failed: Invalid server nonce, it does not start with the client nonce`);\n    }\n\n    if (iterations < minIterations) {\n      throw new KafkaJSSASLAuthenticationError(`${PREFIX} failed: Requested iterations ${iterations} is less than the minimum ${minIterations}`);\n    }\n\n    const finalMessageWithoutProof = this.finalMessageWithoutProof(clientMessageResponse);\n    const clientProof = await this.clientProof(clientMessageResponse);\n    const finalMessage = `${finalMessageWithoutProof},p=${clientProof}`;\n    const request = scram.finalMessage.request({\n      finalMessage\n    });\n    const response = scram.finalMessage.response;\n    return this.saslAuthenticate({\n      authExpectResponse: true,\n      request,\n      response\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  async clientProof(clientMessageResponse) {\n    const clientKey = await this.clientKey(clientMessageResponse);\n    const storedKey = this.H(clientKey);\n    const clientSignature = this.clientSignature(storedKey, clientMessageResponse);\n    return encode64(SCRAM.xor(clientKey, clientSignature));\n  }\n  /**\n   * @private\n   */\n\n\n  async clientKey(clientMessageResponse) {\n    const saltedPassword = await this.saltPassword(clientMessageResponse);\n    return this.HMAC(saltedPassword, HMAC_CLIENT_KEY);\n  }\n  /**\n   * @private\n   */\n\n\n  async serverKey(clientMessageResponse) {\n    const saltedPassword = await this.saltPassword(clientMessageResponse);\n    return this.HMAC(saltedPassword, HMAC_SERVER_KEY);\n  }\n  /**\n   * @private\n   */\n\n\n  clientSignature(storedKey, clientMessageResponse) {\n    return this.HMAC(storedKey, this.authMessage(clientMessageResponse));\n  }\n  /**\n   * @private\n   */\n\n\n  serverSignature(serverKey, clientMessageResponse) {\n    return encode64(this.HMAC(serverKey, this.authMessage(clientMessageResponse)));\n  }\n  /**\n   * @private\n   */\n\n\n  authMessage(clientMessageResponse) {\n    return [this.firstMessageBare(), clientMessageResponse.original, this.finalMessageWithoutProof(clientMessageResponse)].join(',');\n  }\n  /**\n   * @private\n   */\n\n\n  async saltPassword(clientMessageResponse) {\n    const salt = Buffer.from(clientMessageResponse.s, 'base64');\n    const iterations = parseInt(clientMessageResponse.i, 10);\n    return SCRAM.hi(this.encodedPassword(), salt, iterations, this.digestDefinition);\n  }\n  /**\n   * @private\n   */\n\n\n  firstMessageBare() {\n    return `n=${this.encodedUsername()},r=${this.currentNonce}`;\n  }\n  /**\n   * @private\n   */\n\n\n  finalMessageWithoutProof(clientMessageResponse) {\n    const rnonce = clientMessageResponse.r;\n    return `c=${encode64(GS2_HEADER)},r=${rnonce}`;\n  }\n  /**\n   * @private\n   */\n\n\n  encodedUsername() {\n    const {\n      username\n    } = this.connection.sasl;\n    return SCRAM.sanitizeString(username).toString('utf-8');\n  }\n  /**\n   * @private\n   */\n\n\n  encodedPassword() {\n    const {\n      password\n    } = this.connection.sasl;\n    return password.toString('utf-8');\n  }\n  /**\n   * @private\n   */\n\n\n  H(data) {\n    return crypto.createHash(this.digestDefinition.type).update(data).digest();\n  }\n  /**\n   * @private\n   */\n\n\n  HMAC(key, data) {\n    return crypto.createHmac(this.digestDefinition.type, key).update(data).digest();\n  }\n\n}\n\nmodule.exports = {\n  DIGESTS,\n  SCRAM\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/broker/saslAuthenticator/scram.js"],"names":["crypto","require","scram","KafkaJSSASLAuthenticationError","KafkaJSNonRetriableError","GS2_HEADER","EQUAL_SIGN_REGEX","COMMA_SIGN_REGEX","URLSAFE_BASE64_PLUS_REGEX","URLSAFE_BASE64_SLASH_REGEX","URLSAFE_BASE64_TRAILING_EQUAL_REGEX","HMAC_CLIENT_KEY","HMAC_SERVER_KEY","DIGESTS","SHA256","length","type","minIterations","SHA512","encode64","str","Buffer","from","toString","SCRAM","sanitizeString","replace","nonce","randomBytes","hi","password","salt","iterations","digestDefinition","Promise","resolve","reject","pbkdf2","err","derivedKey","xor","left","right","bufferA","bufferB","byteLength","result","i","push","constructor","connection","logger","saslAuthenticate","digestType","toUpperCase","PREFIX","currentNonce","authenticate","host","port","sasl","broker","username","debug","clientMessageResponse","sendClientFirstMessage","finalResponse","sendClientFinalMessage","e","Error","serverKey","serverSignature","v","error","message","clientFirstMessage","firstMessageBare","request","firstMessage","response","authExpectResponse","parseInt","r","startsWith","finalMessageWithoutProof","clientProof","finalMessage","clientKey","storedKey","H","clientSignature","saltedPassword","saltPassword","HMAC","authMessage","original","join","s","encodedPassword","encodedUsername","rnonce","data","createHash","update","digest","key","createHmac","module","exports"],"mappings":"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","sourcesContent":["const crypto = require('crypto')\nconst scram = require('../../protocol/sasl/scram')\nconst { KafkaJSSASLAuthenticationError, KafkaJSNonRetriableError } = require('../../errors')\n\nconst GS2_HEADER = 'n,,'\n\nconst EQUAL_SIGN_REGEX = /=/g\nconst COMMA_SIGN_REGEX = /,/g\n\nconst URLSAFE_BASE64_PLUS_REGEX = /\\+/g\nconst URLSAFE_BASE64_SLASH_REGEX = /\\//g\nconst URLSAFE_BASE64_TRAILING_EQUAL_REGEX = /=+$/\n\nconst HMAC_CLIENT_KEY = 'Client Key'\nconst HMAC_SERVER_KEY = 'Server Key'\n\nconst DIGESTS = {\n  SHA256: {\n    length: 32,\n    type: 'sha256',\n    minIterations: 4096,\n  },\n  SHA512: {\n    length: 64,\n    type: 'sha512',\n    minIterations: 4096,\n  },\n}\n\nconst encode64 = str => Buffer.from(str).toString('base64')\n\nclass SCRAM {\n  /**\n   * From https://tools.ietf.org/html/rfc5802#section-5.1\n   *\n   * The characters ',' or '=' in usernames are sent as '=2C' and\n   * '=3D' respectively.  If the server receives a username that\n   * contains '=' not followed by either '2C' or '3D', then the\n   * server MUST fail the authentication.\n   *\n   * @returns {String}\n   */\n  static sanitizeString(str) {\n    return str.replace(EQUAL_SIGN_REGEX, '=3D').replace(COMMA_SIGN_REGEX, '=2C')\n  }\n\n  /**\n   * In cryptography, a nonce is an arbitrary number that can be used just once.\n   * It is similar in spirit to a nonce * word, hence the name. It is often a random or pseudo-random\n   * number issued in an authentication protocol to * ensure that old communications cannot be reused\n   * in replay attacks.\n   *\n   * @returns {String}\n   */\n  static nonce() {\n    return crypto\n      .randomBytes(16)\n      .toString('base64')\n      .replace(URLSAFE_BASE64_PLUS_REGEX, '-') // make it url safe\n      .replace(URLSAFE_BASE64_SLASH_REGEX, '_')\n      .replace(URLSAFE_BASE64_TRAILING_EQUAL_REGEX, '')\n      .toString('ascii')\n  }\n\n  /**\n   * Hi() is, essentially, PBKDF2 [RFC2898] with HMAC() as the\n   * pseudorandom function (PRF) and with dkLen == output length of\n   * HMAC() == output length of H()\n   *\n   * @returns {Promise<Buffer>}\n   */\n  static hi(password, salt, iterations, digestDefinition) {\n    return new Promise((resolve, reject) => {\n      crypto.pbkdf2(\n        password,\n        salt,\n        iterations,\n        digestDefinition.length,\n        digestDefinition.type,\n        (err, derivedKey) => (err ? reject(err) : resolve(derivedKey))\n      )\n    })\n  }\n\n  /**\n   * Apply the exclusive-or operation to combine the octet string\n   * on the left of this operator with the octet string on the right of\n   * this operator.  The length of the output and each of the two\n   * inputs will be the same for this use\n   *\n   * @returns {Buffer}\n   */\n  static xor(left, right) {\n    const bufferA = Buffer.from(left)\n    const bufferB = Buffer.from(right)\n    const length = Buffer.byteLength(bufferA)\n\n    if (length !== Buffer.byteLength(bufferB)) {\n      throw new KafkaJSNonRetriableError('Buffers must be of the same length')\n    }\n\n    const result = []\n    for (let i = 0; i < length; i++) {\n      result.push(bufferA[i] ^ bufferB[i])\n    }\n\n    return Buffer.from(result)\n  }\n\n  /**\n   * @param {Connection} connection\n   * @param {Logger} logger\n   * @param {Function} saslAuthenticate\n   * @param {DigestDefinition} digestDefinition\n   */\n  constructor(connection, logger, saslAuthenticate, digestDefinition) {\n    this.connection = connection\n    this.logger = logger\n    this.saslAuthenticate = saslAuthenticate\n    this.digestDefinition = digestDefinition\n\n    const digestType = digestDefinition.type.toUpperCase()\n    this.PREFIX = `SASL SCRAM ${digestType} authentication`\n\n    this.currentNonce = SCRAM.nonce()\n  }\n\n  async authenticate() {\n    const { PREFIX } = this\n    const { host, port, sasl } = this.connection\n    const broker = `${host}:${port}`\n\n    if (sasl.username == null || sasl.password == null) {\n      throw new KafkaJSSASLAuthenticationError(`${this.PREFIX}: Invalid username or password`)\n    }\n\n    try {\n      this.logger.debug('Exchanging first client message', { broker })\n      const clientMessageResponse = await this.sendClientFirstMessage()\n\n      this.logger.debug('Sending final message', { broker })\n      const finalResponse = await this.sendClientFinalMessage(clientMessageResponse)\n\n      if (finalResponse.e) {\n        throw new Error(finalResponse.e)\n      }\n\n      const serverKey = await this.serverKey(clientMessageResponse)\n      const serverSignature = this.serverSignature(serverKey, clientMessageResponse)\n\n      if (finalResponse.v !== serverSignature) {\n        throw new Error('Invalid server signature in server final message')\n      }\n\n      this.logger.debug(`${PREFIX} successful`, { broker })\n    } catch (e) {\n      const error = new KafkaJSSASLAuthenticationError(`${PREFIX} failed: ${e.message}`)\n      this.logger.error(error.message, { broker })\n      throw error\n    }\n  }\n\n  /**\n   * @private\n   */\n  async sendClientFirstMessage() {\n    const clientFirstMessage = `${GS2_HEADER}${this.firstMessageBare()}`\n    const request = scram.firstMessage.request({ clientFirstMessage })\n    const response = scram.firstMessage.response\n\n    return this.saslAuthenticate({\n      authExpectResponse: true,\n      request,\n      response,\n    })\n  }\n\n  /**\n   * @private\n   */\n  async sendClientFinalMessage(clientMessageResponse) {\n    const { PREFIX } = this\n    const iterations = parseInt(clientMessageResponse.i, 10)\n    const { minIterations } = this.digestDefinition\n\n    if (!clientMessageResponse.r.startsWith(this.currentNonce)) {\n      throw new KafkaJSSASLAuthenticationError(\n        `${PREFIX} failed: Invalid server nonce, it does not start with the client nonce`\n      )\n    }\n\n    if (iterations < minIterations) {\n      throw new KafkaJSSASLAuthenticationError(\n        `${PREFIX} failed: Requested iterations ${iterations} is less than the minimum ${minIterations}`\n      )\n    }\n\n    const finalMessageWithoutProof = this.finalMessageWithoutProof(clientMessageResponse)\n    const clientProof = await this.clientProof(clientMessageResponse)\n    const finalMessage = `${finalMessageWithoutProof},p=${clientProof}`\n    const request = scram.finalMessage.request({ finalMessage })\n    const response = scram.finalMessage.response\n\n    return this.saslAuthenticate({\n      authExpectResponse: true,\n      request,\n      response,\n    })\n  }\n\n  /**\n   * @private\n   */\n  async clientProof(clientMessageResponse) {\n    const clientKey = await this.clientKey(clientMessageResponse)\n    const storedKey = this.H(clientKey)\n    const clientSignature = this.clientSignature(storedKey, clientMessageResponse)\n    return encode64(SCRAM.xor(clientKey, clientSignature))\n  }\n\n  /**\n   * @private\n   */\n  async clientKey(clientMessageResponse) {\n    const saltedPassword = await this.saltPassword(clientMessageResponse)\n    return this.HMAC(saltedPassword, HMAC_CLIENT_KEY)\n  }\n\n  /**\n   * @private\n   */\n  async serverKey(clientMessageResponse) {\n    const saltedPassword = await this.saltPassword(clientMessageResponse)\n    return this.HMAC(saltedPassword, HMAC_SERVER_KEY)\n  }\n\n  /**\n   * @private\n   */\n  clientSignature(storedKey, clientMessageResponse) {\n    return this.HMAC(storedKey, this.authMessage(clientMessageResponse))\n  }\n\n  /**\n   * @private\n   */\n  serverSignature(serverKey, clientMessageResponse) {\n    return encode64(this.HMAC(serverKey, this.authMessage(clientMessageResponse)))\n  }\n\n  /**\n   * @private\n   */\n  authMessage(clientMessageResponse) {\n    return [\n      this.firstMessageBare(),\n      clientMessageResponse.original,\n      this.finalMessageWithoutProof(clientMessageResponse),\n    ].join(',')\n  }\n\n  /**\n   * @private\n   */\n  async saltPassword(clientMessageResponse) {\n    const salt = Buffer.from(clientMessageResponse.s, 'base64')\n    const iterations = parseInt(clientMessageResponse.i, 10)\n    return SCRAM.hi(this.encodedPassword(), salt, iterations, this.digestDefinition)\n  }\n\n  /**\n   * @private\n   */\n  firstMessageBare() {\n    return `n=${this.encodedUsername()},r=${this.currentNonce}`\n  }\n\n  /**\n   * @private\n   */\n  finalMessageWithoutProof(clientMessageResponse) {\n    const rnonce = clientMessageResponse.r\n    return `c=${encode64(GS2_HEADER)},r=${rnonce}`\n  }\n\n  /**\n   * @private\n   */\n  encodedUsername() {\n    const { username } = this.connection.sasl\n    return SCRAM.sanitizeString(username).toString('utf-8')\n  }\n\n  /**\n   * @private\n   */\n  encodedPassword() {\n    const { password } = this.connection.sasl\n    return password.toString('utf-8')\n  }\n\n  /**\n   * @private\n   */\n  H(data) {\n    return crypto\n      .createHash(this.digestDefinition.type)\n      .update(data)\n      .digest()\n  }\n\n  /**\n   * @private\n   */\n  HMAC(key, data) {\n    return crypto\n      .createHmac(this.digestDefinition.type, key)\n      .update(data)\n      .digest()\n  }\n}\n\nmodule.exports = {\n  DIGESTS,\n  SCRAM,\n}\n"]},"metadata":{},"sourceType":"script"}