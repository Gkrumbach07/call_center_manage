{"ast":null,"code":"const createRetry = require('../retry');\n\nconst flatten = require('../utils/flatten');\n\nconst waitFor = require('../utils/waitFor');\n\nconst groupBy = require('../utils/groupBy');\n\nconst createConsumer = require('../consumer');\n\nconst InstrumentationEventEmitter = require('../instrumentation/emitter');\n\nconst {\n  events,\n  wrap: wrapEvent,\n  unwrap: unwrapEvent\n} = require('./instrumentationEvents');\n\nconst {\n  LEVELS\n} = require('../loggers');\n\nconst {\n  KafkaJSNonRetriableError,\n  KafkaJSDeleteGroupsError,\n  KafkaJSBrokerNotFound,\n  KafkaJSDeleteTopicRecordsError\n} = require('../errors');\n\nconst {\n  staleMetadata\n} = require('../protocol/error');\n\nconst CONFIG_RESOURCE_TYPES = require('../protocol/configResourceTypes');\n\nconst ACL_RESOURCE_TYPES = require('../protocol/aclResourceTypes');\n\nconst ACL_OPERATION_TYPES = require('../protocol/aclOperationTypes');\n\nconst ACL_PERMISSION_TYPES = require('../protocol/aclPermissionTypes');\n\nconst RESOURCE_PATTERN_TYPES = require('../protocol/resourcePatternTypes');\n\nconst {\n  EARLIEST_OFFSET,\n  LATEST_OFFSET\n} = require('../constants');\n\nconst {\n  CONNECT,\n  DISCONNECT\n} = events;\nconst NO_CONTROLLER_ID = -1;\nconst {\n  values,\n  keys,\n  entries\n} = Object;\nconst eventNames = values(events);\nconst eventKeys = keys(events).map(key => `admin.events.${key}`).join(', ');\n\nconst retryOnLeaderNotAvailable = (fn, opts = {}) => {\n  const callback = async () => {\n    try {\n      return await fn();\n    } catch (e) {\n      if (e.type !== 'LEADER_NOT_AVAILABLE') {\n        throw e;\n      }\n\n      return false;\n    }\n  };\n\n  return waitFor(callback, opts);\n};\n\nconst isConsumerGroupRunning = description => ['Empty', 'Dead'].includes(description.state);\n\nconst findTopicPartitions = async (cluster, topic) => {\n  await cluster.addTargetTopic(topic);\n  await cluster.refreshMetadataIfNecessary();\n  return cluster.findTopicPartitionMetadata(topic).map(({\n    partitionId\n  }) => partitionId).sort();\n};\n\nconst indexByPartition = array => array.reduce((obj, {\n  partition,\n  ...props\n}) => Object.assign(obj, {\n  [partition]: { ...props\n  }\n}), {});\n/**\n *\n * @param {Object} params\n * @param {import(\"../../types\").Logger} params.logger\n * @param {import('../instrumentation/emitter')} [params.instrumentationEmitter]\n * @param {import('../../types').RetryOptions} params.retry\n * @param {import(\"../../types\").Cluster} params.cluster\n *\n * @returns {import(\"../../types\").Admin}\n */\n\n\nmodule.exports = ({\n  logger: rootLogger,\n  instrumentationEmitter: rootInstrumentationEmitter,\n  retry,\n  cluster\n}) => {\n  const logger = rootLogger.namespace('Admin');\n  const instrumentationEmitter = rootInstrumentationEmitter || new InstrumentationEventEmitter();\n  /**\n   * @returns {Promise}\n   */\n\n  const connect = async () => {\n    await cluster.connect();\n    instrumentationEmitter.emit(CONNECT);\n  };\n  /**\n   * @return {Promise}\n   */\n\n\n  const disconnect = async () => {\n    await cluster.disconnect();\n    instrumentationEmitter.emit(DISCONNECT);\n  };\n  /**\n   * @return {Promise}\n   */\n\n\n  const listTopics = async () => {\n    const {\n      topicMetadata\n    } = await cluster.metadata();\n    const topics = topicMetadata.map(t => t.topic);\n    return topics;\n  };\n  /**\n   * @param {array} topics\n   * @param {boolean} [validateOnly=false]\n   * @param {number} [timeout=5000]\n   * @param {boolean} [waitForLeaders=true]\n   * @return {Promise}\n   */\n\n\n  const createTopics = async ({\n    topics,\n    validateOnly,\n    timeout,\n    waitForLeaders = true\n  }) => {\n    if (!topics || !Array.isArray(topics)) {\n      throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);\n    }\n\n    if (topics.filter(({\n      topic\n    }) => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError('Invalid topics array, the topic names have to be a valid string');\n    }\n\n    const topicNames = new Set(topics.map(({\n      topic\n    }) => topic));\n\n    if (topicNames.size < topics.length) {\n      throw new KafkaJSNonRetriableError('Invalid topics array, it cannot have multiple entries for the same topic');\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata();\n        const broker = await cluster.findControllerBroker();\n        await broker.createTopics({\n          topics,\n          validateOnly,\n          timeout\n        });\n\n        if (waitForLeaders) {\n          const topicNamesArray = Array.from(topicNames.values());\n          await retryOnLeaderNotAvailable(async () => await broker.metadata(topicNamesArray), {\n            delay: 100,\n            maxWait: timeout,\n            timeoutMessage: 'Timed out while waiting for topic leaders'\n          });\n        }\n\n        return true;\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not create topics', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n          throw e;\n        }\n\n        if (e.type === 'TOPIC_ALREADY_EXISTS') {\n          return false;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @param {array} topicPartitions\n   * @param {boolean} [validateOnly=false]\n   * @param {number} [timeout=5000]\n   * @return {Promise<void>}\n   */\n\n\n  const createPartitions = async ({\n    topicPartitions,\n    validateOnly,\n    timeout\n  }) => {\n    if (!topicPartitions || !Array.isArray(topicPartitions)) {\n      throw new KafkaJSNonRetriableError(`Invalid topic partitions array ${topicPartitions}`);\n    }\n\n    if (topicPartitions.length === 0) {\n      throw new KafkaJSNonRetriableError(`Empty topic partitions array`);\n    }\n\n    if (topicPartitions.filter(({\n      topic\n    }) => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError('Invalid topic partitions array, the topic names have to be a valid string');\n    }\n\n    const topicNames = new Set(topicPartitions.map(({\n      topic\n    }) => topic));\n\n    if (topicNames.size < topicPartitions.length) {\n      throw new KafkaJSNonRetriableError('Invalid topic partitions array, it cannot have multiple entries for the same topic');\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata();\n        const broker = await cluster.findControllerBroker();\n        await broker.createPartitions({\n          topicPartitions,\n          validateOnly,\n          timeout\n        });\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not create topics', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @param {string[]} topics\n   * @param {number} [timeout=5000]\n   * @return {Promise}\n   */\n\n\n  const deleteTopics = async ({\n    topics,\n    timeout\n  }) => {\n    if (!topics || !Array.isArray(topics)) {\n      throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);\n    }\n\n    if (topics.filter(topic => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError('Invalid topics array, the names must be a valid string');\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata();\n        const broker = await cluster.findControllerBroker();\n        await broker.deleteTopics({\n          topics,\n          timeout\n        }); // Remove deleted topics\n\n        for (const topic of topics) {\n          cluster.targetTopics.delete(topic);\n        }\n\n        await cluster.refreshMetadata();\n      } catch (e) {\n        if (['NOT_CONTROLLER', 'UNKNOWN_TOPIC_OR_PARTITION'].includes(e.type)) {\n          logger.warn('Could not delete topics', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n          throw e;\n        }\n\n        if (e.type === 'REQUEST_TIMED_OUT') {\n          logger.error('Could not delete topics, check if \"delete.topic.enable\" is set to \"true\" (the default value is \"false\") or increase the timeout', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @param {string} topic\n   */\n\n\n  const fetchTopicOffsets = async topic => {\n    if (!topic || typeof topic !== 'string') {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.addTargetTopic(topic);\n        await cluster.refreshMetadataIfNecessary();\n        const metadata = cluster.findTopicPartitionMetadata(topic);\n        const high = await cluster.fetchTopicsOffset([{\n          topic,\n          fromBeginning: false,\n          partitions: metadata.map(p => ({\n            partition: p.partitionId\n          }))\n        }]);\n        const low = await cluster.fetchTopicsOffset([{\n          topic,\n          fromBeginning: true,\n          partitions: metadata.map(p => ({\n            partition: p.partitionId\n          }))\n        }]);\n        const {\n          partitions: highPartitions\n        } = high.pop();\n        const {\n          partitions: lowPartitions\n        } = low.pop();\n        return highPartitions.map(({\n          partition,\n          offset\n        }) => ({\n          partition,\n          offset,\n          high: offset,\n          low: lowPartitions.find(({\n            partition: lowPartition\n          }) => lowPartition === partition).offset\n        }));\n      } catch (e) {\n        if (e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n          await cluster.refreshMetadata();\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @param {string} topic\n   * @param {number} [timestamp]\n   */\n\n\n  const fetchTopicOffsetsByTimestamp = async (topic, timestamp) => {\n    if (!topic || typeof topic !== 'string') {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.addTargetTopic(topic);\n        await cluster.refreshMetadataIfNecessary();\n        const metadata = cluster.findTopicPartitionMetadata(topic);\n        const partitions = metadata.map(p => ({\n          partition: p.partitionId\n        }));\n        const high = await cluster.fetchTopicsOffset([{\n          topic,\n          fromBeginning: false,\n          partitions\n        }]);\n        const {\n          partitions: highPartitions\n        } = high.pop();\n        const offsets = await cluster.fetchTopicsOffset([{\n          topic,\n          fromTimestamp: timestamp,\n          partitions\n        }]);\n        const {\n          partitions: lowPartitions\n        } = offsets.pop();\n        return lowPartitions.map(({\n          partition,\n          offset\n        }) => ({\n          partition,\n          offset: parseInt(offset, 10) >= 0 ? offset : highPartitions.find(({\n            partition: highPartition\n          }) => highPartition === partition).offset\n        }));\n      } catch (e) {\n        if (e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n          await cluster.refreshMetadata();\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {boolean} [resolveOffsets=false]\n   * @return {Promise}\n   */\n\n\n  const fetchOffsets = async ({\n    groupId,\n    topic,\n    resolveOffsets = false\n  }) => {\n    if (!groupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`);\n    }\n\n    if (!topic) {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n    }\n\n    const partitions = await findTopicPartitions(cluster, topic);\n    const coordinator = await cluster.findGroupCoordinator({\n      groupId\n    });\n    const partitionsToFetch = partitions.map(partition => ({\n      partition\n    }));\n    let {\n      responses: consumerOffsets\n    } = await coordinator.offsetFetch({\n      groupId,\n      topics: [{\n        topic,\n        partitions: partitionsToFetch\n      }]\n    });\n\n    if (resolveOffsets) {\n      const indexedOffsets = indexByPartition(await fetchTopicOffsets(topic));\n      consumerOffsets = consumerOffsets.map(({\n        topic,\n        partitions\n      }) => ({\n        topic,\n        partitions: partitions.map(({\n          offset,\n          partition,\n          ...props\n        }) => {\n          let resolvedOffset = offset;\n\n          if (Number(offset) === EARLIEST_OFFSET) {\n            resolvedOffset = indexedOffsets[partition].low;\n          }\n\n          if (Number(offset) === LATEST_OFFSET) {\n            resolvedOffset = indexedOffsets[partition].high;\n          }\n\n          return {\n            partition,\n            offset: resolvedOffset,\n            ...props\n          };\n        })\n      }));\n      const [{\n        partitions\n      }] = consumerOffsets;\n      await setOffsets({\n        groupId,\n        topic,\n        partitions\n      });\n    }\n\n    return consumerOffsets.filter(response => response.topic === topic).map(({\n      partitions\n    }) => partitions.map(({\n      partition,\n      offset,\n      metadata\n    }) => ({\n      partition,\n      offset,\n      metadata: metadata || null\n    }))).pop();\n  };\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {boolean} [earliest=false]\n   * @return {Promise}\n   */\n\n\n  const resetOffsets = async ({\n    groupId,\n    topic,\n    earliest = false\n  }) => {\n    if (!groupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`);\n    }\n\n    if (!topic) {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n    }\n\n    const partitions = await findTopicPartitions(cluster, topic);\n    const partitionsToSeek = partitions.map(partition => ({\n      partition,\n      offset: cluster.defaultOffset({\n        fromBeginning: earliest\n      })\n    }));\n    return setOffsets({\n      groupId,\n      topic,\n      partitions: partitionsToSeek\n    });\n  };\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {Array<SeekEntry>} partitions\n   * @return {Promise}\n   *\n   * @typedef {Object} SeekEntry\n   * @property {number} partition\n   * @property {string} offset\n   */\n\n\n  const setOffsets = async ({\n    groupId,\n    topic,\n    partitions\n  }) => {\n    if (!groupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`);\n    }\n\n    if (!topic) {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n    }\n\n    if (!partitions || partitions.length === 0) {\n      throw new KafkaJSNonRetriableError(`Invalid partitions`);\n    }\n\n    const consumer = createConsumer({\n      logger: rootLogger.namespace('Admin', LEVELS.NOTHING),\n      cluster,\n      groupId\n    });\n    await consumer.subscribe({\n      topic,\n      fromBeginning: true\n    });\n    const description = await consumer.describeGroup();\n\n    if (!isConsumerGroupRunning(description)) {\n      throw new KafkaJSNonRetriableError(`The consumer group must have no running instances, current state: ${description.state}`);\n    }\n\n    return new Promise((resolve, reject) => {\n      consumer.on(consumer.events.FETCH, async () => consumer.stop().then(resolve).catch(reject));\n      consumer.run({\n        eachBatchAutoResolve: false,\n        eachBatch: async () => true\n      }).catch(reject); // This consumer doesn't need to consume any data\n\n      consumer.pause([{\n        topic\n      }]);\n\n      for (const seekData of partitions) {\n        consumer.seek({\n          topic,\n          ...seekData\n        });\n      }\n    });\n  };\n\n  const isBrokerConfig = type => [CONFIG_RESOURCE_TYPES.BROKER, CONFIG_RESOURCE_TYPES.BROKER_LOGGER].includes(type);\n  /**\n   * Broker configs can only be returned by the target broker\n   *\n   * @see\n   * https://github.com/apache/kafka/blob/821c1ac6641845aeca96a43bc2b946ecec5cba4f/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L3783\n   * https://github.com/apache/kafka/blob/821c1ac6641845aeca96a43bc2b946ecec5cba4f/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L2027\n   *\n   * @param {Broker} defaultBroker. Broker used in case the configuration is not a broker config\n   */\n\n\n  const groupResourcesByBroker = ({\n    resources,\n    defaultBroker\n  }) => groupBy(resources, async ({\n    type,\n    name: nodeId\n  }) => {\n    return isBrokerConfig(type) ? await cluster.findBroker({\n      nodeId: String(nodeId)\n    }) : defaultBroker;\n  });\n  /**\n   * @param {Array<ResourceConfigQuery>} resources\n   * @param {boolean} [includeSynonyms=false]\n   * @return {Promise}\n   *\n   * @typedef {Object} ResourceConfigQuery\n   * @property {ConfigResourceType} type\n   * @property {string} name\n   * @property {Array<String>} [configNames=[]]\n   */\n\n\n  const describeConfigs = async ({\n    resources,\n    includeSynonyms\n  }) => {\n    if (!resources || !Array.isArray(resources)) {\n      throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`);\n    }\n\n    if (resources.length === 0) {\n      throw new KafkaJSNonRetriableError('Resources array cannot be empty');\n    }\n\n    const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES);\n    const invalidType = resources.find(r => !validResourceTypes.includes(r.type));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`);\n    }\n\n    const invalidName = resources.find(r => !r.name || typeof r.name !== 'string');\n\n    if (invalidName) {\n      throw new KafkaJSNonRetriableError(`Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`);\n    }\n\n    const invalidConfigs = resources.find(r => !Array.isArray(r.configNames) && r.configNames != null);\n\n    if (invalidConfigs) {\n      const {\n        configNames\n      } = invalidConfigs;\n      throw new KafkaJSNonRetriableError(`Invalid resource configNames ${configNames}: ${JSON.stringify(invalidConfigs)}`);\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata();\n        const controller = await cluster.findControllerBroker();\n        const resourcerByBroker = await groupResourcesByBroker({\n          resources,\n          defaultBroker: controller\n        });\n\n        const describeConfigsAction = async broker => {\n          const targetBroker = broker || controller;\n          return targetBroker.describeConfigs({\n            resources: resourcerByBroker.get(targetBroker),\n            includeSynonyms\n          });\n        };\n\n        const brokers = Array.from(resourcerByBroker.keys());\n        const responses = await Promise.all(brokers.map(describeConfigsAction));\n        const responseResources = responses.reduce((result, {\n          resources\n        }) => [...result, ...resources], []);\n        return {\n          resources: responseResources\n        };\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not describe configs', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @param {Array<ResourceConfig>} resources\n   * @param {boolean} [validateOnly=false]\n   * @return {Promise}\n   *\n   * @typedef {Object} ResourceConfig\n   * @property {ConfigResourceType} type\n   * @property {string} name\n   * @property {Array<ResourceConfigEntry>} configEntries\n   *\n   * @typedef {Object} ResourceConfigEntry\n   * @property {string} name\n   * @property {string} value\n   */\n\n\n  const alterConfigs = async ({\n    resources,\n    validateOnly\n  }) => {\n    if (!resources || !Array.isArray(resources)) {\n      throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`);\n    }\n\n    if (resources.length === 0) {\n      throw new KafkaJSNonRetriableError('Resources array cannot be empty');\n    }\n\n    const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES);\n    const invalidType = resources.find(r => !validResourceTypes.includes(r.type));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`);\n    }\n\n    const invalidName = resources.find(r => !r.name || typeof r.name !== 'string');\n\n    if (invalidName) {\n      throw new KafkaJSNonRetriableError(`Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`);\n    }\n\n    const invalidConfigs = resources.find(r => !Array.isArray(r.configEntries));\n\n    if (invalidConfigs) {\n      const {\n        configEntries\n      } = invalidConfigs;\n      throw new KafkaJSNonRetriableError(`Invalid resource configEntries ${configEntries}: ${JSON.stringify(invalidConfigs)}`);\n    }\n\n    const invalidConfigValue = resources.find(r => r.configEntries.some(e => typeof e.name !== 'string' || typeof e.value !== 'string'));\n\n    if (invalidConfigValue) {\n      throw new KafkaJSNonRetriableError(`Invalid resource config value: ${JSON.stringify(invalidConfigValue)}`);\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata();\n        const controller = await cluster.findControllerBroker();\n        const resourcerByBroker = await groupResourcesByBroker({\n          resources,\n          defaultBroker: controller\n        });\n\n        const alterConfigsAction = async broker => {\n          const targetBroker = broker || controller;\n          return targetBroker.alterConfigs({\n            resources: resourcerByBroker.get(targetBroker),\n            validateOnly: !!validateOnly\n          });\n        };\n\n        const brokers = Array.from(resourcerByBroker.keys());\n        const responses = await Promise.all(brokers.map(alterConfigsAction));\n        const responseResources = responses.reduce((result, {\n          resources\n        }) => [...result, ...resources], []);\n        return {\n          resources: responseResources\n        };\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not alter configs', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @deprecated - This method was replaced by `fetchTopicMetadata`. This implementation\n   * is limited by the topics in the target group, so it can't fetch all topics when\n   * necessary.\n   *\n   * Fetch metadata for provided topics.\n   *\n   * If no topics are provided fetch metadata for all topics of which we are aware.\n   * @see https://kafka.apache.org/protocol#The_Messages_Metadata\n   *\n   * @param {Object} [options]\n   * @param {string[]} [options.topics]\n   * @return {Promise<TopicsMetadata>}\n   *\n   * @typedef {Object} TopicsMetadata\n   * @property {Array<TopicMetadata>} topics\n   *\n   * @typedef {Object} TopicMetadata\n   * @property {String} name\n   * @property {Array<PartitionMetadata>} partitions\n   *\n   * @typedef {Object} PartitionMetadata\n   * @property {number} partitionErrorCode Response error code\n   * @property {number} partitionId Topic partition id\n   * @property {number} leader  The id of the broker acting as leader for this partition.\n   * @property {Array<number>} replicas The set of all nodes that host this partition.\n   * @property {Array<number>} isr The set of nodes that are in sync with the leader for this partition.\n   */\n\n\n  const getTopicMetadata = async options => {\n    const {\n      topics\n    } = options || {};\n\n    if (topics) {\n      await Promise.all(topics.map(async topic => {\n        if (!topic) {\n          throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n        }\n\n        try {\n          await cluster.addTargetTopic(topic);\n        } catch (e) {\n          e.message = `Failed to add target topic ${topic}: ${e.message}`;\n          throw e;\n        }\n      }));\n    }\n\n    await cluster.refreshMetadataIfNecessary();\n    const targetTopics = topics || [...cluster.targetTopics];\n    return {\n      topics: await Promise.all(targetTopics.map(async topic => ({\n        name: topic,\n        partitions: cluster.findTopicPartitionMetadata(topic)\n      })))\n    };\n  };\n  /**\n   * Fetch metadata for provided topics.\n   *\n   * If no topics are provided fetch metadata for all topics.\n   * @see https://kafka.apache.org/protocol#The_Messages_Metadata\n   *\n   * @param {Object} [options]\n   * @param {string[]} [options.topics]\n   * @return {Promise<TopicsMetadata>}\n   *\n   * @typedef {Object} TopicsMetadata\n   * @property {Array<TopicMetadata>} topics\n   *\n   * @typedef {Object} TopicMetadata\n   * @property {String} name\n   * @property {Array<PartitionMetadata>} partitions\n   *\n   * @typedef {Object} PartitionMetadata\n   * @property {number} partitionErrorCode Response error code\n   * @property {number} partitionId Topic partition id\n   * @property {number} leader  The id of the broker acting as leader for this partition.\n   * @property {Array<number>} replicas The set of all nodes that host this partition.\n   * @property {Array<number>} isr The set of nodes that are in sync with the leader for this partition.\n   */\n\n\n  const fetchTopicMetadata = async ({\n    topics = []\n  } = {}) => {\n    if (topics) {\n      topics.forEach(topic => {\n        if (!topic || typeof topic !== 'string') {\n          throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);\n        }\n      });\n    }\n\n    const metadata = await cluster.metadata({\n      topics\n    });\n    return {\n      topics: metadata.topicMetadata.map(topicMetadata => ({\n        name: topicMetadata.topic,\n        partitions: topicMetadata.partitionMetadata\n      }))\n    };\n  };\n  /**\n   * Describe cluster\n   *\n   * @return {Promise<ClusterMetadata>}\n   *\n   * @typedef {Object} ClusterMetadata\n   * @property {Array<Broker>} brokers\n   * @property {Number} controller Current controller id. Returns null if unknown.\n   * @property {String} clusterId\n   *\n   * @typedef {Object} Broker\n   * @property {Number} nodeId\n   * @property {String} host\n   * @property {Number} port\n   */\n\n\n  const describeCluster = async () => {\n    const {\n      brokers: nodes,\n      clusterId,\n      controllerId\n    } = await cluster.metadata({\n      topics: []\n    });\n    const brokers = nodes.map(({\n      nodeId,\n      host,\n      port\n    }) => ({\n      nodeId,\n      host,\n      port\n    }));\n    const controller = controllerId == null || controllerId === NO_CONTROLLER_ID ? null : controllerId;\n    return {\n      brokers,\n      controller,\n      clusterId\n    };\n  };\n  /**\n   * List groups in a broker\n   *\n   * @return {Promise<ListGroups>}\n   *\n   * @typedef {Object} ListGroups\n   * @property {Array<ListGroup>} groups\n   *\n   * @typedef {Object} ListGroup\n   * @property {string} groupId\n   * @property {string} protocolType\n   */\n\n\n  const listGroups = async () => {\n    await cluster.refreshMetadata();\n    let groups = [];\n\n    for (var nodeId in cluster.brokerPool.brokers) {\n      const broker = await cluster.findBroker({\n        nodeId\n      });\n      const response = await broker.listGroups();\n      groups = groups.concat(response.groups);\n    }\n\n    return {\n      groups\n    };\n  };\n  /**\n   * Describe groups by group ids\n   * @param {Array<string>} groupIds\n   *\n   * @typedef {Object} GroupDescriptions\n   * @property {Array<GroupDescription>} groups\n   *\n   * @return {Promise<GroupDescriptions>}\n   */\n\n\n  const describeGroups = async groupIds => {\n    const coordinatorsForGroup = await Promise.all(groupIds.map(async groupId => {\n      const coordinator = await cluster.findGroupCoordinator({\n        groupId\n      });\n      return {\n        coordinator,\n        groupId\n      };\n    }));\n    const groupsByCoordinator = Object.values(coordinatorsForGroup.reduce((coordinators, {\n      coordinator,\n      groupId\n    }) => {\n      const group = coordinators[coordinator.nodeId];\n\n      if (group) {\n        coordinators[coordinator.nodeId] = { ...group,\n          groupIds: [...group.groupIds, groupId]\n        };\n      } else {\n        coordinators[coordinator.nodeId] = {\n          coordinator,\n          groupIds: [groupId]\n        };\n      }\n\n      return coordinators;\n    }, {}));\n    const responses = await Promise.all(groupsByCoordinator.map(async ({\n      coordinator,\n      groupIds\n    }) => {\n      const retrier = createRetry(retry);\n      const {\n        groups\n      } = await retrier(() => coordinator.describeGroups({\n        groupIds\n      }));\n      return groups;\n    }));\n    const groups = [].concat.apply([], responses);\n    return {\n      groups\n    };\n  };\n  /**\n   * Delete groups in a broker\n   *\n   * @param {string[]} [groupIds]\n   * @return {Promise<DeleteGroups>}\n   *\n   * @typedef {Array} DeleteGroups\n   * @property {string} groupId\n   * @property {number} errorCode\n   */\n\n\n  const deleteGroups = async groupIds => {\n    if (!groupIds || !Array.isArray(groupIds)) {\n      throw new KafkaJSNonRetriableError(`Invalid groupIds array ${groupIds}`);\n    }\n\n    const invalidGroupId = groupIds.some(g => typeof g !== 'string');\n\n    if (invalidGroupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId name: ${JSON.stringify(invalidGroupId)}`);\n    }\n\n    const retrier = createRetry(retry);\n    let results = [];\n    let clonedGroupIds = groupIds.slice();\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        if (clonedGroupIds.length === 0) return [];\n        await cluster.refreshMetadata();\n        const brokersPerGroups = {};\n        const brokersPerNode = {};\n\n        for (const groupId of clonedGroupIds) {\n          const broker = await cluster.findGroupCoordinator({\n            groupId\n          });\n          if (brokersPerGroups[broker.nodeId] === undefined) brokersPerGroups[broker.nodeId] = [];\n          brokersPerGroups[broker.nodeId].push(groupId);\n          brokersPerNode[broker.nodeId] = broker;\n        }\n\n        const res = await Promise.all(Object.keys(brokersPerNode).map(async nodeId => await brokersPerNode[nodeId].deleteGroups(brokersPerGroups[nodeId])));\n        const errors = flatten(res.map(({\n          results\n        }) => results.map(({\n          groupId,\n          errorCode,\n          error\n        }) => {\n          return {\n            groupId,\n            errorCode,\n            error\n          };\n        }))).filter(({\n          errorCode\n        }) => errorCode !== 0);\n        clonedGroupIds = errors.map(({\n          groupId\n        }) => groupId);\n        if (errors.length > 0) throw new KafkaJSDeleteGroupsError('Error in DeleteGroups', errors);\n        results = flatten(res.map(({\n          results\n        }) => results));\n        return results;\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER' || e.type === 'COORDINATOR_NOT_AVAILABLE') {\n          logger.warn('Could not delete groups', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * Delete topic records up to the selected partition offsets\n   *\n   * @param {string} topic\n   * @param {Array<SeekEntry>} partitions\n   * @return {Promise}\n   *\n   * @typedef {Object} SeekEntry\n   * @property {number} partition\n   * @property {string} offset\n   */\n\n\n  const deleteTopicRecords = async ({\n    topic,\n    partitions\n  }) => {\n    if (!topic || typeof topic !== 'string') {\n      throw new KafkaJSNonRetriableError(`Invalid topic \"${topic}\"`);\n    }\n\n    if (!partitions || partitions.length === 0) {\n      throw new KafkaJSNonRetriableError(`Invalid partitions`);\n    }\n\n    const partitionsByBroker = cluster.findLeaderForPartitions(topic, partitions.map(p => p.partition));\n    const partitionsFound = flatten(values(partitionsByBroker));\n    const topicOffsets = await fetchTopicOffsets(topic);\n    const leaderNotFoundErrors = [];\n    partitions.forEach(({\n      partition,\n      offset\n    }) => {\n      // throw if no leader found for partition\n      if (!partitionsFound.includes(partition)) {\n        leaderNotFoundErrors.push({\n          partition,\n          offset,\n          error: new KafkaJSBrokerNotFound('Could not find the leader for the partition', {\n            retriable: false\n          })\n        });\n        return;\n      }\n\n      const {\n        low\n      } = topicOffsets.find(p => p.partition === partition) || {\n        high: undefined,\n        low: undefined\n      }; // warn in case of offset below low watermark\n\n      if (parseInt(offset) < parseInt(low)) {\n        logger.warn('The requested offset is before the earliest offset maintained on the partition - no records will be deleted from this partition', {\n          topic,\n          partition,\n          offset\n        });\n      }\n    });\n\n    if (leaderNotFoundErrors.length > 0) {\n      throw new KafkaJSDeleteTopicRecordsError({\n        topic,\n        partitions: leaderNotFoundErrors\n      });\n    }\n\n    const seekEntriesByBroker = entries(partitionsByBroker).reduce((obj, [nodeId, nodePartitions]) => {\n      obj[nodeId] = {\n        topic,\n        partitions: partitions.filter(p => nodePartitions.includes(p.partition))\n      };\n      return obj;\n    }, {});\n    const retrier = createRetry(retry);\n    return retrier(async bail => {\n      try {\n        const partitionErrors = [];\n        const brokerRequests = entries(seekEntriesByBroker).map(([nodeId, {\n          topic,\n          partitions\n        }]) => async () => {\n          const broker = await cluster.findBroker({\n            nodeId\n          });\n          await broker.deleteRecords({\n            topics: [{\n              topic,\n              partitions\n            }]\n          }); // remove successful entry so it's ignored on retry\n\n          delete seekEntriesByBroker[nodeId];\n        });\n        await Promise.all(brokerRequests.map(request => request().catch(e => {\n          if (e.name === 'KafkaJSDeleteTopicRecordsError') {\n            e.partitions.forEach(({\n              partition,\n              offset,\n              error\n            }) => {\n              partitionErrors.push({\n                partition,\n                offset,\n                error\n              });\n            });\n          } else {\n            // then it's an unknown error, not from the broker response\n            throw e;\n          }\n        })));\n\n        if (partitionErrors.length > 0) {\n          throw new KafkaJSDeleteTopicRecordsError({\n            topic,\n            partitions: partitionErrors\n          });\n        }\n      } catch (e) {\n        if (e.retriable && e.partitions.some(({\n          error\n        }) => staleMetadata(error) || error.name === 'KafkaJSMetadataNotLoaded')) {\n          await cluster.refreshMetadata();\n        }\n\n        throw e;\n      }\n    });\n  };\n  /**\n   * @param {Array<ACLEntry>} acl\n   * @return {Promise<void>}\n   *\n   * @typedef {Object} ACLEntry\n   */\n\n\n  const createAcls = async ({\n    acl\n  }) => {\n    if (!acl || !Array.isArray(acl)) {\n      throw new KafkaJSNonRetriableError(`Invalid ACL array ${acl}`);\n    }\n\n    if (acl.length === 0) {\n      throw new KafkaJSNonRetriableError('Empty ACL array');\n    } // Validate principal\n\n\n    if (acl.some(({\n      principal\n    }) => typeof principal !== 'string')) {\n      throw new KafkaJSNonRetriableError('Invalid ACL array, the principals have to be a valid string');\n    } // Validate host\n\n\n    if (acl.some(({\n      host\n    }) => typeof host !== 'string')) {\n      throw new KafkaJSNonRetriableError('Invalid ACL array, the hosts have to be a valid string');\n    } // Validate resourceName\n\n\n    if (acl.some(({\n      resourceName\n    }) => typeof resourceName !== 'string')) {\n      throw new KafkaJSNonRetriableError('Invalid ACL array, the resourceNames have to be a valid string');\n    }\n\n    let invalidType; // Validate operation\n\n    const validOperationTypes = Object.values(ACL_OPERATION_TYPES);\n    invalidType = acl.find(i => !validOperationTypes.includes(i.operation));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`);\n    } // Validate resourcePatternTypes\n\n\n    const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);\n    invalidType = acl.find(i => !validResourcePatternTypes.includes(i.resourcePatternType));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(invalidType)}`);\n    } // Validate permissionTypes\n\n\n    const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);\n    invalidType = acl.find(i => !validPermissionTypes.includes(i.permissionType));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`);\n    } // Validate resourceTypes\n\n\n    const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);\n    invalidType = acl.find(i => !validResourceTypes.includes(i.resourceType));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`);\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata();\n        const broker = await cluster.findControllerBroker();\n        await broker.createAcls({\n          acl\n        });\n        return true;\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not create ACL', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @param {ACLResourceTypes} resourceType The type of resource\n   * @param {string} resourceName The name of the resource\n   * @param {ACLResourcePatternTypes} resourcePatternType The resource pattern type filter\n   * @param {string} principal The principal name\n   * @param {string} host The hostname\n   * @param {ACLOperationTypes} operation The type of operation\n   * @param {ACLPermissionTypes} permissionType The type of permission\n   * @return {Promise<void>}\n   *\n   * @typedef {number} ACLResourceTypes\n   * @typedef {number} ACLResourcePatternTypes\n   * @typedef {number} ACLOperationTypes\n   * @typedef {number} ACLPermissionTypes\n   */\n\n\n  const describeAcls = async ({\n    resourceType,\n    resourceName,\n    resourcePatternType,\n    principal,\n    host,\n    operation,\n    permissionType\n  }) => {\n    // Validate principal\n    if (typeof principal !== 'string' && typeof principal !== 'undefined') {\n      throw new KafkaJSNonRetriableError('Invalid principal, the principal have to be a valid string');\n    } // Validate host\n\n\n    if (typeof host !== 'string' && typeof host !== 'undefined') {\n      throw new KafkaJSNonRetriableError('Invalid host, the host have to be a valid string');\n    } // Validate resourceName\n\n\n    if (typeof resourceName !== 'string' && typeof resourceName !== 'undefined') {\n      throw new KafkaJSNonRetriableError('Invalid resourceName, the resourceName have to be a valid string');\n    } // Validate operation\n\n\n    const validOperationTypes = Object.values(ACL_OPERATION_TYPES);\n\n    if (!validOperationTypes.includes(operation)) {\n      throw new KafkaJSNonRetriableError(`Invalid operation type ${operation}`);\n    } // Validate resourcePatternType\n\n\n    const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);\n\n    if (!validResourcePatternTypes.includes(resourcePatternType)) {\n      throw new KafkaJSNonRetriableError(`Invalid resource pattern filter type ${resourcePatternType}`);\n    } // Validate permissionType\n\n\n    const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);\n\n    if (!validPermissionTypes.includes(permissionType)) {\n      throw new KafkaJSNonRetriableError(`Invalid permission type ${permissionType}`);\n    } // Validate resourceType\n\n\n    const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);\n\n    if (!validResourceTypes.includes(resourceType)) {\n      throw new KafkaJSNonRetriableError(`Invalid resource type ${resourceType}`);\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata();\n        const broker = await cluster.findControllerBroker();\n        const {\n          resources\n        } = await broker.describeAcls({\n          resourceType,\n          resourceName,\n          resourcePatternType,\n          principal,\n          host,\n          operation,\n          permissionType\n        });\n        return {\n          resources\n        };\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not describe ACL', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @param {Array<ACLFilter>} filters\n   * @return {Promise<void>}\n   *\n   * @typedef {Object} ACLFilter\n   */\n\n\n  const deleteAcls = async ({\n    filters\n  }) => {\n    if (!filters || !Array.isArray(filters)) {\n      throw new KafkaJSNonRetriableError(`Invalid ACL Filter array ${filters}`);\n    }\n\n    if (filters.length === 0) {\n      throw new KafkaJSNonRetriableError('Empty ACL Filter array');\n    } // Validate principal\n\n\n    if (filters.some(({\n      principal\n    }) => typeof principal !== 'string' && typeof principal !== 'undefined')) {\n      throw new KafkaJSNonRetriableError('Invalid ACL Filter array, the principals have to be a valid string');\n    } // Validate host\n\n\n    if (filters.some(({\n      host\n    }) => typeof host !== 'string' && typeof host !== 'undefined')) {\n      throw new KafkaJSNonRetriableError('Invalid ACL Filter array, the hosts have to be a valid string');\n    } // Validate resourceName\n\n\n    if (filters.some(({\n      resourceName\n    }) => typeof resourceName !== 'string' && typeof resourceName !== 'undefined')) {\n      throw new KafkaJSNonRetriableError('Invalid ACL Filter array, the resourceNames have to be a valid string');\n    }\n\n    let invalidType; // Validate operation\n\n    const validOperationTypes = Object.values(ACL_OPERATION_TYPES);\n    invalidType = filters.find(i => !validOperationTypes.includes(i.operation));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`);\n    } // Validate resourcePatternTypes\n\n\n    const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);\n    invalidType = filters.find(i => !validResourcePatternTypes.includes(i.resourcePatternType));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(invalidType)}`);\n    } // Validate permissionTypes\n\n\n    const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);\n    invalidType = filters.find(i => !validPermissionTypes.includes(i.permissionType));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`);\n    } // Validate resourceTypes\n\n\n    const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);\n    invalidType = filters.find(i => !validResourceTypes.includes(i.resourceType));\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`);\n    }\n\n    const retrier = createRetry(retry);\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata();\n        const broker = await cluster.findControllerBroker();\n        const {\n          filterResponses\n        } = await broker.deleteAcls({\n          filters\n        });\n        return {\n          filterResponses\n        };\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not delete ACL', {\n            error: e.message,\n            retryCount,\n            retryTime\n          });\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  };\n  /**\n   * @param {string} eventName\n   * @param {Function} listener\n   * @return {Function}\n   */\n\n\n  const on = (eventName, listener) => {\n    if (!eventNames.includes(eventName)) {\n      throw new KafkaJSNonRetriableError(`Event name should be one of ${eventKeys}`);\n    }\n\n    return instrumentationEmitter.addListener(unwrapEvent(eventName), event => {\n      event.type = wrapEvent(event.type);\n      Promise.resolve(listener(event)).catch(e => {\n        logger.error(`Failed to execute listener: ${e.message}`, {\n          eventName,\n          stack: e.stack\n        });\n      });\n    });\n  };\n  /**\n   * @return {Object} logger\n   */\n\n\n  const getLogger = () => logger;\n\n  return {\n    connect,\n    disconnect,\n    listTopics,\n    createTopics,\n    deleteTopics,\n    createPartitions,\n    getTopicMetadata,\n    fetchTopicMetadata,\n    describeCluster,\n    events,\n    fetchOffsets,\n    fetchTopicOffsets,\n    fetchTopicOffsetsByTimestamp,\n    setOffsets,\n    resetOffsets,\n    describeConfigs,\n    alterConfigs,\n    on,\n    logger: getLogger,\n    listGroups,\n    describeGroups,\n    deleteGroups,\n    describeAcls,\n    deleteAcls,\n    createAcls,\n    deleteTopicRecords\n  };\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/admin/index.js"],"names":["createRetry","require","flatten","waitFor","groupBy","createConsumer","InstrumentationEventEmitter","events","wrap","wrapEvent","unwrap","unwrapEvent","LEVELS","KafkaJSNonRetriableError","KafkaJSDeleteGroupsError","KafkaJSBrokerNotFound","KafkaJSDeleteTopicRecordsError","staleMetadata","CONFIG_RESOURCE_TYPES","ACL_RESOURCE_TYPES","ACL_OPERATION_TYPES","ACL_PERMISSION_TYPES","RESOURCE_PATTERN_TYPES","EARLIEST_OFFSET","LATEST_OFFSET","CONNECT","DISCONNECT","NO_CONTROLLER_ID","values","keys","entries","Object","eventNames","eventKeys","map","key","join","retryOnLeaderNotAvailable","fn","opts","callback","e","type","isConsumerGroupRunning","description","includes","state","findTopicPartitions","cluster","topic","addTargetTopic","refreshMetadataIfNecessary","findTopicPartitionMetadata","partitionId","sort","indexByPartition","array","reduce","obj","partition","props","assign","module","exports","logger","rootLogger","instrumentationEmitter","rootInstrumentationEmitter","retry","namespace","connect","emit","disconnect","listTopics","topicMetadata","metadata","topics","t","createTopics","validateOnly","timeout","waitForLeaders","Array","isArray","filter","length","topicNames","Set","size","retrier","bail","retryCount","retryTime","refreshMetadata","broker","findControllerBroker","topicNamesArray","from","delay","maxWait","timeoutMessage","warn","error","message","createPartitions","topicPartitions","deleteTopics","targetTopics","delete","fetchTopicOffsets","high","fetchTopicsOffset","fromBeginning","partitions","p","low","highPartitions","pop","lowPartitions","offset","find","lowPartition","fetchTopicOffsetsByTimestamp","timestamp","offsets","fromTimestamp","parseInt","highPartition","fetchOffsets","groupId","resolveOffsets","coordinator","findGroupCoordinator","partitionsToFetch","responses","consumerOffsets","offsetFetch","indexedOffsets","resolvedOffset","Number","setOffsets","response","resetOffsets","earliest","partitionsToSeek","defaultOffset","consumer","NOTHING","subscribe","describeGroup","Promise","resolve","reject","on","FETCH","stop","then","catch","run","eachBatchAutoResolve","eachBatch","pause","seekData","seek","isBrokerConfig","BROKER","BROKER_LOGGER","groupResourcesByBroker","resources","defaultBroker","name","nodeId","findBroker","String","describeConfigs","includeSynonyms","validResourceTypes","invalidType","r","JSON","stringify","invalidName","invalidConfigs","configNames","controller","resourcerByBroker","describeConfigsAction","targetBroker","get","brokers","all","responseResources","result","alterConfigs","configEntries","invalidConfigValue","some","value","alterConfigsAction","getTopicMetadata","options","fetchTopicMetadata","forEach","partitionMetadata","describeCluster","nodes","clusterId","controllerId","host","port","listGroups","groups","brokerPool","concat","describeGroups","groupIds","coordinatorsForGroup","groupsByCoordinator","coordinators","group","apply","deleteGroups","invalidGroupId","g","results","clonedGroupIds","slice","brokersPerGroups","brokersPerNode","undefined","push","res","errors","errorCode","deleteTopicRecords","partitionsByBroker","findLeaderForPartitions","partitionsFound","topicOffsets","leaderNotFoundErrors","retriable","seekEntriesByBroker","nodePartitions","partitionErrors","brokerRequests","deleteRecords","request","createAcls","acl","principal","resourceName","validOperationTypes","i","operation","validResourcePatternTypes","resourcePatternType","validPermissionTypes","permissionType","resourceType","describeAcls","deleteAcls","filters","filterResponses","eventName","listener","addListener","event","stack","getLogger"],"mappings":"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","sourcesContent":["const createRetry = require('../retry')\nconst flatten = require('../utils/flatten')\nconst waitFor = require('../utils/waitFor')\nconst groupBy = require('../utils/groupBy')\nconst createConsumer = require('../consumer')\nconst InstrumentationEventEmitter = require('../instrumentation/emitter')\nconst { events, wrap: wrapEvent, unwrap: unwrapEvent } = require('./instrumentationEvents')\nconst { LEVELS } = require('../loggers')\nconst {\n  KafkaJSNonRetriableError,\n  KafkaJSDeleteGroupsError,\n  KafkaJSBrokerNotFound,\n  KafkaJSDeleteTopicRecordsError,\n} = require('../errors')\nconst { staleMetadata } = require('../protocol/error')\nconst CONFIG_RESOURCE_TYPES = require('../protocol/configResourceTypes')\nconst ACL_RESOURCE_TYPES = require('../protocol/aclResourceTypes')\nconst ACL_OPERATION_TYPES = require('../protocol/aclOperationTypes')\nconst ACL_PERMISSION_TYPES = require('../protocol/aclPermissionTypes')\nconst RESOURCE_PATTERN_TYPES = require('../protocol/resourcePatternTypes')\nconst { EARLIEST_OFFSET, LATEST_OFFSET } = require('../constants')\n\nconst { CONNECT, DISCONNECT } = events\n\nconst NO_CONTROLLER_ID = -1\n\nconst { values, keys, entries } = Object\nconst eventNames = values(events)\nconst eventKeys = keys(events)\n  .map(key => `admin.events.${key}`)\n  .join(', ')\n\nconst retryOnLeaderNotAvailable = (fn, opts = {}) => {\n  const callback = async () => {\n    try {\n      return await fn()\n    } catch (e) {\n      if (e.type !== 'LEADER_NOT_AVAILABLE') {\n        throw e\n      }\n      return false\n    }\n  }\n\n  return waitFor(callback, opts)\n}\n\nconst isConsumerGroupRunning = description => ['Empty', 'Dead'].includes(description.state)\nconst findTopicPartitions = async (cluster, topic) => {\n  await cluster.addTargetTopic(topic)\n  await cluster.refreshMetadataIfNecessary()\n\n  return cluster\n    .findTopicPartitionMetadata(topic)\n    .map(({ partitionId }) => partitionId)\n    .sort()\n}\nconst indexByPartition = array =>\n  array.reduce(\n    (obj, { partition, ...props }) => Object.assign(obj, { [partition]: { ...props } }),\n    {}\n  )\n\n/**\n *\n * @param {Object} params\n * @param {import(\"../../types\").Logger} params.logger\n * @param {import('../instrumentation/emitter')} [params.instrumentationEmitter]\n * @param {import('../../types').RetryOptions} params.retry\n * @param {import(\"../../types\").Cluster} params.cluster\n *\n * @returns {import(\"../../types\").Admin}\n */\nmodule.exports = ({\n  logger: rootLogger,\n  instrumentationEmitter: rootInstrumentationEmitter,\n  retry,\n  cluster,\n}) => {\n  const logger = rootLogger.namespace('Admin')\n  const instrumentationEmitter = rootInstrumentationEmitter || new InstrumentationEventEmitter()\n\n  /**\n   * @returns {Promise}\n   */\n  const connect = async () => {\n    await cluster.connect()\n    instrumentationEmitter.emit(CONNECT)\n  }\n\n  /**\n   * @return {Promise}\n   */\n  const disconnect = async () => {\n    await cluster.disconnect()\n    instrumentationEmitter.emit(DISCONNECT)\n  }\n\n  /**\n   * @return {Promise}\n   */\n  const listTopics = async () => {\n    const { topicMetadata } = await cluster.metadata()\n    const topics = topicMetadata.map(t => t.topic)\n    return topics\n  }\n\n  /**\n   * @param {array} topics\n   * @param {boolean} [validateOnly=false]\n   * @param {number} [timeout=5000]\n   * @param {boolean} [waitForLeaders=true]\n   * @return {Promise}\n   */\n  const createTopics = async ({ topics, validateOnly, timeout, waitForLeaders = true }) => {\n    if (!topics || !Array.isArray(topics)) {\n      throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`)\n    }\n\n    if (topics.filter(({ topic }) => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topics array, the topic names have to be a valid string'\n      )\n    }\n\n    const topicNames = new Set(topics.map(({ topic }) => topic))\n    if (topicNames.size < topics.length) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topics array, it cannot have multiple entries for the same topic'\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        await broker.createTopics({ topics, validateOnly, timeout })\n\n        if (waitForLeaders) {\n          const topicNamesArray = Array.from(topicNames.values())\n          await retryOnLeaderNotAvailable(async () => await broker.metadata(topicNamesArray), {\n            delay: 100,\n            maxWait: timeout,\n            timeoutMessage: 'Timed out while waiting for topic leaders',\n          })\n        }\n\n        return true\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not create topics', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        if (e.type === 'TOPIC_ALREADY_EXISTS') {\n          return false\n        }\n\n        bail(e)\n      }\n    })\n  }\n  /**\n   * @param {array} topicPartitions\n   * @param {boolean} [validateOnly=false]\n   * @param {number} [timeout=5000]\n   * @return {Promise<void>}\n   */\n  const createPartitions = async ({ topicPartitions, validateOnly, timeout }) => {\n    if (!topicPartitions || !Array.isArray(topicPartitions)) {\n      throw new KafkaJSNonRetriableError(`Invalid topic partitions array ${topicPartitions}`)\n    }\n    if (topicPartitions.length === 0) {\n      throw new KafkaJSNonRetriableError(`Empty topic partitions array`)\n    }\n\n    if (topicPartitions.filter(({ topic }) => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topic partitions array, the topic names have to be a valid string'\n      )\n    }\n\n    const topicNames = new Set(topicPartitions.map(({ topic }) => topic))\n    if (topicNames.size < topicPartitions.length) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid topic partitions array, it cannot have multiple entries for the same topic'\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        await broker.createPartitions({ topicPartitions, validateOnly, timeout })\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not create topics', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {string[]} topics\n   * @param {number} [timeout=5000]\n   * @return {Promise}\n   */\n  const deleteTopics = async ({ topics, timeout }) => {\n    if (!topics || !Array.isArray(topics)) {\n      throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`)\n    }\n\n    if (topics.filter(topic => typeof topic !== 'string').length > 0) {\n      throw new KafkaJSNonRetriableError('Invalid topics array, the names must be a valid string')\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        await broker.deleteTopics({ topics, timeout })\n\n        // Remove deleted topics\n        for (const topic of topics) {\n          cluster.targetTopics.delete(topic)\n        }\n\n        await cluster.refreshMetadata()\n      } catch (e) {\n        if (['NOT_CONTROLLER', 'UNKNOWN_TOPIC_OR_PARTITION'].includes(e.type)) {\n          logger.warn('Could not delete topics', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        if (e.type === 'REQUEST_TIMED_OUT') {\n          logger.error(\n            'Could not delete topics, check if \"delete.topic.enable\" is set to \"true\" (the default value is \"false\") or increase the timeout',\n            {\n              error: e.message,\n              retryCount,\n              retryTime,\n            }\n          )\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {string} topic\n   */\n\n  const fetchTopicOffsets = async topic => {\n    if (!topic || typeof topic !== 'string') {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.addTargetTopic(topic)\n        await cluster.refreshMetadataIfNecessary()\n\n        const metadata = cluster.findTopicPartitionMetadata(topic)\n        const high = await cluster.fetchTopicsOffset([\n          {\n            topic,\n            fromBeginning: false,\n            partitions: metadata.map(p => ({ partition: p.partitionId })),\n          },\n        ])\n\n        const low = await cluster.fetchTopicsOffset([\n          {\n            topic,\n            fromBeginning: true,\n            partitions: metadata.map(p => ({ partition: p.partitionId })),\n          },\n        ])\n\n        const { partitions: highPartitions } = high.pop()\n        const { partitions: lowPartitions } = low.pop()\n        return highPartitions.map(({ partition, offset }) => ({\n          partition,\n          offset,\n          high: offset,\n          low: lowPartitions.find(({ partition: lowPartition }) => lowPartition === partition)\n            .offset,\n        }))\n      } catch (e) {\n        if (e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n          await cluster.refreshMetadata()\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {string} topic\n   * @param {number} [timestamp]\n   */\n\n  const fetchTopicOffsetsByTimestamp = async (topic, timestamp) => {\n    if (!topic || typeof topic !== 'string') {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.addTargetTopic(topic)\n        await cluster.refreshMetadataIfNecessary()\n\n        const metadata = cluster.findTopicPartitionMetadata(topic)\n        const partitions = metadata.map(p => ({ partition: p.partitionId }))\n\n        const high = await cluster.fetchTopicsOffset([\n          {\n            topic,\n            fromBeginning: false,\n            partitions,\n          },\n        ])\n        const { partitions: highPartitions } = high.pop()\n\n        const offsets = await cluster.fetchTopicsOffset([\n          {\n            topic,\n            fromTimestamp: timestamp,\n            partitions,\n          },\n        ])\n        const { partitions: lowPartitions } = offsets.pop()\n\n        return lowPartitions.map(({ partition, offset }) => ({\n          partition,\n          offset:\n            parseInt(offset, 10) >= 0\n              ? offset\n              : highPartitions.find(({ partition: highPartition }) => highPartition === partition)\n                  .offset,\n        }))\n      } catch (e) {\n        if (e.type === 'UNKNOWN_TOPIC_OR_PARTITION') {\n          await cluster.refreshMetadata()\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {boolean} [resolveOffsets=false]\n   * @return {Promise}\n   */\n  const fetchOffsets = async ({ groupId, topic, resolveOffsets = false }) => {\n    if (!groupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`)\n    }\n\n    if (!topic) {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n    }\n\n    const partitions = await findTopicPartitions(cluster, topic)\n    const coordinator = await cluster.findGroupCoordinator({ groupId })\n    const partitionsToFetch = partitions.map(partition => ({ partition }))\n\n    let { responses: consumerOffsets } = await coordinator.offsetFetch({\n      groupId,\n      topics: [{ topic, partitions: partitionsToFetch }],\n    })\n\n    if (resolveOffsets) {\n      const indexedOffsets = indexByPartition(await fetchTopicOffsets(topic))\n      consumerOffsets = consumerOffsets.map(({ topic, partitions }) => ({\n        topic,\n        partitions: partitions.map(({ offset, partition, ...props }) => {\n          let resolvedOffset = offset\n          if (Number(offset) === EARLIEST_OFFSET) {\n            resolvedOffset = indexedOffsets[partition].low\n          }\n          if (Number(offset) === LATEST_OFFSET) {\n            resolvedOffset = indexedOffsets[partition].high\n          }\n          return {\n            partition,\n            offset: resolvedOffset,\n            ...props,\n          }\n        }),\n      }))\n      const [{ partitions }] = consumerOffsets\n      await setOffsets({ groupId, topic, partitions })\n    }\n\n    return consumerOffsets\n      .filter(response => response.topic === topic)\n      .map(({ partitions }) =>\n        partitions.map(({ partition, offset, metadata }) => ({\n          partition,\n          offset,\n          metadata: metadata || null,\n        }))\n      )\n      .pop()\n  }\n\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {boolean} [earliest=false]\n   * @return {Promise}\n   */\n  const resetOffsets = async ({ groupId, topic, earliest = false }) => {\n    if (!groupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`)\n    }\n\n    if (!topic) {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n    }\n\n    const partitions = await findTopicPartitions(cluster, topic)\n    const partitionsToSeek = partitions.map(partition => ({\n      partition,\n      offset: cluster.defaultOffset({ fromBeginning: earliest }),\n    }))\n\n    return setOffsets({ groupId, topic, partitions: partitionsToSeek })\n  }\n\n  /**\n   * @param {string} groupId\n   * @param {string} topic\n   * @param {Array<SeekEntry>} partitions\n   * @return {Promise}\n   *\n   * @typedef {Object} SeekEntry\n   * @property {number} partition\n   * @property {string} offset\n   */\n  const setOffsets = async ({ groupId, topic, partitions }) => {\n    if (!groupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`)\n    }\n\n    if (!topic) {\n      throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n    }\n\n    if (!partitions || partitions.length === 0) {\n      throw new KafkaJSNonRetriableError(`Invalid partitions`)\n    }\n\n    const consumer = createConsumer({\n      logger: rootLogger.namespace('Admin', LEVELS.NOTHING),\n      cluster,\n      groupId,\n    })\n\n    await consumer.subscribe({ topic, fromBeginning: true })\n    const description = await consumer.describeGroup()\n\n    if (!isConsumerGroupRunning(description)) {\n      throw new KafkaJSNonRetriableError(\n        `The consumer group must have no running instances, current state: ${description.state}`\n      )\n    }\n\n    return new Promise((resolve, reject) => {\n      consumer.on(consumer.events.FETCH, async () =>\n        consumer\n          .stop()\n          .then(resolve)\n          .catch(reject)\n      )\n\n      consumer\n        .run({\n          eachBatchAutoResolve: false,\n          eachBatch: async () => true,\n        })\n        .catch(reject)\n\n      // This consumer doesn't need to consume any data\n      consumer.pause([{ topic }])\n\n      for (const seekData of partitions) {\n        consumer.seek({ topic, ...seekData })\n      }\n    })\n  }\n\n  const isBrokerConfig = type =>\n    [CONFIG_RESOURCE_TYPES.BROKER, CONFIG_RESOURCE_TYPES.BROKER_LOGGER].includes(type)\n\n  /**\n   * Broker configs can only be returned by the target broker\n   *\n   * @see\n   * https://github.com/apache/kafka/blob/821c1ac6641845aeca96a43bc2b946ecec5cba4f/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L3783\n   * https://github.com/apache/kafka/blob/821c1ac6641845aeca96a43bc2b946ecec5cba4f/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L2027\n   *\n   * @param {Broker} defaultBroker. Broker used in case the configuration is not a broker config\n   */\n  const groupResourcesByBroker = ({ resources, defaultBroker }) =>\n    groupBy(resources, async ({ type, name: nodeId }) => {\n      return isBrokerConfig(type)\n        ? await cluster.findBroker({ nodeId: String(nodeId) })\n        : defaultBroker\n    })\n\n  /**\n   * @param {Array<ResourceConfigQuery>} resources\n   * @param {boolean} [includeSynonyms=false]\n   * @return {Promise}\n   *\n   * @typedef {Object} ResourceConfigQuery\n   * @property {ConfigResourceType} type\n   * @property {string} name\n   * @property {Array<String>} [configNames=[]]\n   */\n  const describeConfigs = async ({ resources, includeSynonyms }) => {\n    if (!resources || !Array.isArray(resources)) {\n      throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`)\n    }\n\n    if (resources.length === 0) {\n      throw new KafkaJSNonRetriableError('Resources array cannot be empty')\n    }\n\n    const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES)\n    const invalidType = resources.find(r => !validResourceTypes.includes(r.type))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    const invalidName = resources.find(r => !r.name || typeof r.name !== 'string')\n\n    if (invalidName) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`\n      )\n    }\n\n    const invalidConfigs = resources.find(\n      r => !Array.isArray(r.configNames) && r.configNames != null\n    )\n\n    if (invalidConfigs) {\n      const { configNames } = invalidConfigs\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource configNames ${configNames}: ${JSON.stringify(invalidConfigs)}`\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const controller = await cluster.findControllerBroker()\n        const resourcerByBroker = await groupResourcesByBroker({\n          resources,\n          defaultBroker: controller,\n        })\n\n        const describeConfigsAction = async broker => {\n          const targetBroker = broker || controller\n          return targetBroker.describeConfigs({\n            resources: resourcerByBroker.get(targetBroker),\n            includeSynonyms,\n          })\n        }\n\n        const brokers = Array.from(resourcerByBroker.keys())\n        const responses = await Promise.all(brokers.map(describeConfigsAction))\n        const responseResources = responses.reduce(\n          (result, { resources }) => [...result, ...resources],\n          []\n        )\n\n        return { resources: responseResources }\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not describe configs', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {Array<ResourceConfig>} resources\n   * @param {boolean} [validateOnly=false]\n   * @return {Promise}\n   *\n   * @typedef {Object} ResourceConfig\n   * @property {ConfigResourceType} type\n   * @property {string} name\n   * @property {Array<ResourceConfigEntry>} configEntries\n   *\n   * @typedef {Object} ResourceConfigEntry\n   * @property {string} name\n   * @property {string} value\n   */\n  const alterConfigs = async ({ resources, validateOnly }) => {\n    if (!resources || !Array.isArray(resources)) {\n      throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`)\n    }\n\n    if (resources.length === 0) {\n      throw new KafkaJSNonRetriableError('Resources array cannot be empty')\n    }\n\n    const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES)\n    const invalidType = resources.find(r => !validResourceTypes.includes(r.type))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    const invalidName = resources.find(r => !r.name || typeof r.name !== 'string')\n\n    if (invalidName) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`\n      )\n    }\n\n    const invalidConfigs = resources.find(r => !Array.isArray(r.configEntries))\n\n    if (invalidConfigs) {\n      const { configEntries } = invalidConfigs\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource configEntries ${configEntries}: ${JSON.stringify(invalidConfigs)}`\n      )\n    }\n\n    const invalidConfigValue = resources.find(r =>\n      r.configEntries.some(e => typeof e.name !== 'string' || typeof e.value !== 'string')\n    )\n\n    if (invalidConfigValue) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource config value: ${JSON.stringify(invalidConfigValue)}`\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const controller = await cluster.findControllerBroker()\n        const resourcerByBroker = await groupResourcesByBroker({\n          resources,\n          defaultBroker: controller,\n        })\n\n        const alterConfigsAction = async broker => {\n          const targetBroker = broker || controller\n          return targetBroker.alterConfigs({\n            resources: resourcerByBroker.get(targetBroker),\n            validateOnly: !!validateOnly,\n          })\n        }\n\n        const brokers = Array.from(resourcerByBroker.keys())\n        const responses = await Promise.all(brokers.map(alterConfigsAction))\n        const responseResources = responses.reduce(\n          (result, { resources }) => [...result, ...resources],\n          []\n        )\n\n        return { resources: responseResources }\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not alter configs', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @deprecated - This method was replaced by `fetchTopicMetadata`. This implementation\n   * is limited by the topics in the target group, so it can't fetch all topics when\n   * necessary.\n   *\n   * Fetch metadata for provided topics.\n   *\n   * If no topics are provided fetch metadata for all topics of which we are aware.\n   * @see https://kafka.apache.org/protocol#The_Messages_Metadata\n   *\n   * @param {Object} [options]\n   * @param {string[]} [options.topics]\n   * @return {Promise<TopicsMetadata>}\n   *\n   * @typedef {Object} TopicsMetadata\n   * @property {Array<TopicMetadata>} topics\n   *\n   * @typedef {Object} TopicMetadata\n   * @property {String} name\n   * @property {Array<PartitionMetadata>} partitions\n   *\n   * @typedef {Object} PartitionMetadata\n   * @property {number} partitionErrorCode Response error code\n   * @property {number} partitionId Topic partition id\n   * @property {number} leader  The id of the broker acting as leader for this partition.\n   * @property {Array<number>} replicas The set of all nodes that host this partition.\n   * @property {Array<number>} isr The set of nodes that are in sync with the leader for this partition.\n   */\n  const getTopicMetadata = async options => {\n    const { topics } = options || {}\n\n    if (topics) {\n      await Promise.all(\n        topics.map(async topic => {\n          if (!topic) {\n            throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n          }\n\n          try {\n            await cluster.addTargetTopic(topic)\n          } catch (e) {\n            e.message = `Failed to add target topic ${topic}: ${e.message}`\n            throw e\n          }\n        })\n      )\n    }\n\n    await cluster.refreshMetadataIfNecessary()\n    const targetTopics = topics || [...cluster.targetTopics]\n\n    return {\n      topics: await Promise.all(\n        targetTopics.map(async topic => ({\n          name: topic,\n          partitions: cluster.findTopicPartitionMetadata(topic),\n        }))\n      ),\n    }\n  }\n\n  /**\n   * Fetch metadata for provided topics.\n   *\n   * If no topics are provided fetch metadata for all topics.\n   * @see https://kafka.apache.org/protocol#The_Messages_Metadata\n   *\n   * @param {Object} [options]\n   * @param {string[]} [options.topics]\n   * @return {Promise<TopicsMetadata>}\n   *\n   * @typedef {Object} TopicsMetadata\n   * @property {Array<TopicMetadata>} topics\n   *\n   * @typedef {Object} TopicMetadata\n   * @property {String} name\n   * @property {Array<PartitionMetadata>} partitions\n   *\n   * @typedef {Object} PartitionMetadata\n   * @property {number} partitionErrorCode Response error code\n   * @property {number} partitionId Topic partition id\n   * @property {number} leader  The id of the broker acting as leader for this partition.\n   * @property {Array<number>} replicas The set of all nodes that host this partition.\n   * @property {Array<number>} isr The set of nodes that are in sync with the leader for this partition.\n   */\n  const fetchTopicMetadata = async ({ topics = [] } = {}) => {\n    if (topics) {\n      topics.forEach(topic => {\n        if (!topic || typeof topic !== 'string') {\n          throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`)\n        }\n      })\n    }\n\n    const metadata = await cluster.metadata({ topics })\n\n    return {\n      topics: metadata.topicMetadata.map(topicMetadata => ({\n        name: topicMetadata.topic,\n        partitions: topicMetadata.partitionMetadata,\n      })),\n    }\n  }\n\n  /**\n   * Describe cluster\n   *\n   * @return {Promise<ClusterMetadata>}\n   *\n   * @typedef {Object} ClusterMetadata\n   * @property {Array<Broker>} brokers\n   * @property {Number} controller Current controller id. Returns null if unknown.\n   * @property {String} clusterId\n   *\n   * @typedef {Object} Broker\n   * @property {Number} nodeId\n   * @property {String} host\n   * @property {Number} port\n   */\n  const describeCluster = async () => {\n    const { brokers: nodes, clusterId, controllerId } = await cluster.metadata({ topics: [] })\n    const brokers = nodes.map(({ nodeId, host, port }) => ({\n      nodeId,\n      host,\n      port,\n    }))\n    const controller =\n      controllerId == null || controllerId === NO_CONTROLLER_ID ? null : controllerId\n\n    return {\n      brokers,\n      controller,\n      clusterId,\n    }\n  }\n\n  /**\n   * List groups in a broker\n   *\n   * @return {Promise<ListGroups>}\n   *\n   * @typedef {Object} ListGroups\n   * @property {Array<ListGroup>} groups\n   *\n   * @typedef {Object} ListGroup\n   * @property {string} groupId\n   * @property {string} protocolType\n   */\n  const listGroups = async () => {\n    await cluster.refreshMetadata()\n    let groups = []\n    for (var nodeId in cluster.brokerPool.brokers) {\n      const broker = await cluster.findBroker({ nodeId })\n      const response = await broker.listGroups()\n      groups = groups.concat(response.groups)\n    }\n\n    return { groups }\n  }\n\n  /**\n   * Describe groups by group ids\n   * @param {Array<string>} groupIds\n   *\n   * @typedef {Object} GroupDescriptions\n   * @property {Array<GroupDescription>} groups\n   *\n   * @return {Promise<GroupDescriptions>}\n   */\n  const describeGroups = async groupIds => {\n    const coordinatorsForGroup = await Promise.all(\n      groupIds.map(async groupId => {\n        const coordinator = await cluster.findGroupCoordinator({ groupId })\n        return {\n          coordinator,\n          groupId,\n        }\n      })\n    )\n\n    const groupsByCoordinator = Object.values(\n      coordinatorsForGroup.reduce((coordinators, { coordinator, groupId }) => {\n        const group = coordinators[coordinator.nodeId]\n\n        if (group) {\n          coordinators[coordinator.nodeId] = {\n            ...group,\n            groupIds: [...group.groupIds, groupId],\n          }\n        } else {\n          coordinators[coordinator.nodeId] = { coordinator, groupIds: [groupId] }\n        }\n        return coordinators\n      }, {})\n    )\n\n    const responses = await Promise.all(\n      groupsByCoordinator.map(async ({ coordinator, groupIds }) => {\n        const retrier = createRetry(retry)\n        const { groups } = await retrier(() => coordinator.describeGroups({ groupIds }))\n        return groups\n      })\n    )\n\n    const groups = [].concat.apply([], responses)\n\n    return { groups }\n  }\n\n  /**\n   * Delete groups in a broker\n   *\n   * @param {string[]} [groupIds]\n   * @return {Promise<DeleteGroups>}\n   *\n   * @typedef {Array} DeleteGroups\n   * @property {string} groupId\n   * @property {number} errorCode\n   */\n  const deleteGroups = async groupIds => {\n    if (!groupIds || !Array.isArray(groupIds)) {\n      throw new KafkaJSNonRetriableError(`Invalid groupIds array ${groupIds}`)\n    }\n\n    const invalidGroupId = groupIds.some(g => typeof g !== 'string')\n\n    if (invalidGroupId) {\n      throw new KafkaJSNonRetriableError(`Invalid groupId name: ${JSON.stringify(invalidGroupId)}`)\n    }\n\n    const retrier = createRetry(retry)\n\n    let results = []\n\n    let clonedGroupIds = groupIds.slice()\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        if (clonedGroupIds.length === 0) return []\n\n        await cluster.refreshMetadata()\n\n        const brokersPerGroups = {}\n        const brokersPerNode = {}\n        for (const groupId of clonedGroupIds) {\n          const broker = await cluster.findGroupCoordinator({ groupId })\n          if (brokersPerGroups[broker.nodeId] === undefined) brokersPerGroups[broker.nodeId] = []\n          brokersPerGroups[broker.nodeId].push(groupId)\n          brokersPerNode[broker.nodeId] = broker\n        }\n\n        const res = await Promise.all(\n          Object.keys(brokersPerNode).map(\n            async nodeId => await brokersPerNode[nodeId].deleteGroups(brokersPerGroups[nodeId])\n          )\n        )\n\n        const errors = flatten(\n          res.map(({ results }) =>\n            results.map(({ groupId, errorCode, error }) => {\n              return { groupId, errorCode, error }\n            })\n          )\n        ).filter(({ errorCode }) => errorCode !== 0)\n\n        clonedGroupIds = errors.map(({ groupId }) => groupId)\n\n        if (errors.length > 0) throw new KafkaJSDeleteGroupsError('Error in DeleteGroups', errors)\n\n        results = flatten(res.map(({ results }) => results))\n\n        return results\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER' || e.type === 'COORDINATOR_NOT_AVAILABLE') {\n          logger.warn('Could not delete groups', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * Delete topic records up to the selected partition offsets\n   *\n   * @param {string} topic\n   * @param {Array<SeekEntry>} partitions\n   * @return {Promise}\n   *\n   * @typedef {Object} SeekEntry\n   * @property {number} partition\n   * @property {string} offset\n   */\n  const deleteTopicRecords = async ({ topic, partitions }) => {\n    if (!topic || typeof topic !== 'string') {\n      throw new KafkaJSNonRetriableError(`Invalid topic \"${topic}\"`)\n    }\n\n    if (!partitions || partitions.length === 0) {\n      throw new KafkaJSNonRetriableError(`Invalid partitions`)\n    }\n\n    const partitionsByBroker = cluster.findLeaderForPartitions(\n      topic,\n      partitions.map(p => p.partition)\n    )\n\n    const partitionsFound = flatten(values(partitionsByBroker))\n    const topicOffsets = await fetchTopicOffsets(topic)\n\n    const leaderNotFoundErrors = []\n    partitions.forEach(({ partition, offset }) => {\n      // throw if no leader found for partition\n      if (!partitionsFound.includes(partition)) {\n        leaderNotFoundErrors.push({\n          partition,\n          offset,\n          error: new KafkaJSBrokerNotFound('Could not find the leader for the partition', {\n            retriable: false,\n          }),\n        })\n        return\n      }\n      const { low } = topicOffsets.find(p => p.partition === partition) || {\n        high: undefined,\n        low: undefined,\n      }\n      // warn in case of offset below low watermark\n      if (parseInt(offset) < parseInt(low)) {\n        logger.warn(\n          'The requested offset is before the earliest offset maintained on the partition - no records will be deleted from this partition',\n          {\n            topic,\n            partition,\n            offset,\n          }\n        )\n      }\n    })\n\n    if (leaderNotFoundErrors.length > 0) {\n      throw new KafkaJSDeleteTopicRecordsError({ topic, partitions: leaderNotFoundErrors })\n    }\n\n    const seekEntriesByBroker = entries(partitionsByBroker).reduce(\n      (obj, [nodeId, nodePartitions]) => {\n        obj[nodeId] = {\n          topic,\n          partitions: partitions.filter(p => nodePartitions.includes(p.partition)),\n        }\n        return obj\n      },\n      {}\n    )\n\n    const retrier = createRetry(retry)\n    return retrier(async bail => {\n      try {\n        const partitionErrors = []\n\n        const brokerRequests = entries(seekEntriesByBroker).map(\n          ([nodeId, { topic, partitions }]) => async () => {\n            const broker = await cluster.findBroker({ nodeId })\n            await broker.deleteRecords({ topics: [{ topic, partitions }] })\n            // remove successful entry so it's ignored on retry\n            delete seekEntriesByBroker[nodeId]\n          }\n        )\n\n        await Promise.all(\n          brokerRequests.map(request =>\n            request().catch(e => {\n              if (e.name === 'KafkaJSDeleteTopicRecordsError') {\n                e.partitions.forEach(({ partition, offset, error }) => {\n                  partitionErrors.push({\n                    partition,\n                    offset,\n                    error,\n                  })\n                })\n              } else {\n                // then it's an unknown error, not from the broker response\n                throw e\n              }\n            })\n          )\n        )\n\n        if (partitionErrors.length > 0) {\n          throw new KafkaJSDeleteTopicRecordsError({\n            topic,\n            partitions: partitionErrors,\n          })\n        }\n      } catch (e) {\n        if (\n          e.retriable &&\n          e.partitions.some(\n            ({ error }) => staleMetadata(error) || error.name === 'KafkaJSMetadataNotLoaded'\n          )\n        ) {\n          await cluster.refreshMetadata()\n        }\n        throw e\n      }\n    })\n  }\n\n  /**\n   * @param {Array<ACLEntry>} acl\n   * @return {Promise<void>}\n   *\n   * @typedef {Object} ACLEntry\n   */\n  const createAcls = async ({ acl }) => {\n    if (!acl || !Array.isArray(acl)) {\n      throw new KafkaJSNonRetriableError(`Invalid ACL array ${acl}`)\n    }\n    if (acl.length === 0) {\n      throw new KafkaJSNonRetriableError('Empty ACL array')\n    }\n\n    // Validate principal\n    if (acl.some(({ principal }) => typeof principal !== 'string')) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL array, the principals have to be a valid string'\n      )\n    }\n\n    // Validate host\n    if (acl.some(({ host }) => typeof host !== 'string')) {\n      throw new KafkaJSNonRetriableError('Invalid ACL array, the hosts have to be a valid string')\n    }\n\n    // Validate resourceName\n    if (acl.some(({ resourceName }) => typeof resourceName !== 'string')) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL array, the resourceNames have to be a valid string'\n      )\n    }\n\n    let invalidType\n    // Validate operation\n    const validOperationTypes = Object.values(ACL_OPERATION_TYPES)\n    invalidType = acl.find(i => !validOperationTypes.includes(i.operation))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    // Validate resourcePatternTypes\n    const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES)\n    invalidType = acl.find(i => !validResourcePatternTypes.includes(i.resourcePatternType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(\n          invalidType\n        )}`\n      )\n    }\n\n    // Validate permissionTypes\n    const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES)\n    invalidType = acl.find(i => !validPermissionTypes.includes(i.permissionType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    // Validate resourceTypes\n    const validResourceTypes = Object.values(ACL_RESOURCE_TYPES)\n    invalidType = acl.find(i => !validResourceTypes.includes(i.resourceType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        await broker.createAcls({ acl })\n\n        return true\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not create ACL', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {ACLResourceTypes} resourceType The type of resource\n   * @param {string} resourceName The name of the resource\n   * @param {ACLResourcePatternTypes} resourcePatternType The resource pattern type filter\n   * @param {string} principal The principal name\n   * @param {string} host The hostname\n   * @param {ACLOperationTypes} operation The type of operation\n   * @param {ACLPermissionTypes} permissionType The type of permission\n   * @return {Promise<void>}\n   *\n   * @typedef {number} ACLResourceTypes\n   * @typedef {number} ACLResourcePatternTypes\n   * @typedef {number} ACLOperationTypes\n   * @typedef {number} ACLPermissionTypes\n   */\n  const describeAcls = async ({\n    resourceType,\n    resourceName,\n    resourcePatternType,\n    principal,\n    host,\n    operation,\n    permissionType,\n  }) => {\n    // Validate principal\n    if (typeof principal !== 'string' && typeof principal !== 'undefined') {\n      throw new KafkaJSNonRetriableError(\n        'Invalid principal, the principal have to be a valid string'\n      )\n    }\n\n    // Validate host\n    if (typeof host !== 'string' && typeof host !== 'undefined') {\n      throw new KafkaJSNonRetriableError('Invalid host, the host have to be a valid string')\n    }\n\n    // Validate resourceName\n    if (typeof resourceName !== 'string' && typeof resourceName !== 'undefined') {\n      throw new KafkaJSNonRetriableError(\n        'Invalid resourceName, the resourceName have to be a valid string'\n      )\n    }\n\n    // Validate operation\n    const validOperationTypes = Object.values(ACL_OPERATION_TYPES)\n    if (!validOperationTypes.includes(operation)) {\n      throw new KafkaJSNonRetriableError(`Invalid operation type ${operation}`)\n    }\n\n    // Validate resourcePatternType\n    const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES)\n    if (!validResourcePatternTypes.includes(resourcePatternType)) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource pattern filter type ${resourcePatternType}`\n      )\n    }\n\n    // Validate permissionType\n    const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES)\n    if (!validPermissionTypes.includes(permissionType)) {\n      throw new KafkaJSNonRetriableError(`Invalid permission type ${permissionType}`)\n    }\n\n    // Validate resourceType\n    const validResourceTypes = Object.values(ACL_RESOURCE_TYPES)\n    if (!validResourceTypes.includes(resourceType)) {\n      throw new KafkaJSNonRetriableError(`Invalid resource type ${resourceType}`)\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        const { resources } = await broker.describeAcls({\n          resourceType,\n          resourceName,\n          resourcePatternType,\n          principal,\n          host,\n          operation,\n          permissionType,\n        })\n        return { resources }\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not describe ACL', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {Array<ACLFilter>} filters\n   * @return {Promise<void>}\n   *\n   * @typedef {Object} ACLFilter\n   */\n  const deleteAcls = async ({ filters }) => {\n    if (!filters || !Array.isArray(filters)) {\n      throw new KafkaJSNonRetriableError(`Invalid ACL Filter array ${filters}`)\n    }\n\n    if (filters.length === 0) {\n      throw new KafkaJSNonRetriableError('Empty ACL Filter array')\n    }\n\n    // Validate principal\n    if (\n      filters.some(\n        ({ principal }) => typeof principal !== 'string' && typeof principal !== 'undefined'\n      )\n    ) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL Filter array, the principals have to be a valid string'\n      )\n    }\n\n    // Validate host\n    if (filters.some(({ host }) => typeof host !== 'string' && typeof host !== 'undefined')) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL Filter array, the hosts have to be a valid string'\n      )\n    }\n\n    // Validate resourceName\n    if (\n      filters.some(\n        ({ resourceName }) =>\n          typeof resourceName !== 'string' && typeof resourceName !== 'undefined'\n      )\n    ) {\n      throw new KafkaJSNonRetriableError(\n        'Invalid ACL Filter array, the resourceNames have to be a valid string'\n      )\n    }\n\n    let invalidType\n    // Validate operation\n    const validOperationTypes = Object.values(ACL_OPERATION_TYPES)\n    invalidType = filters.find(i => !validOperationTypes.includes(i.operation))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    // Validate resourcePatternTypes\n    const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES)\n    invalidType = filters.find(i => !validResourcePatternTypes.includes(i.resourcePatternType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(\n          invalidType\n        )}`\n      )\n    }\n\n    // Validate permissionTypes\n    const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES)\n    invalidType = filters.find(i => !validPermissionTypes.includes(i.permissionType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    // Validate resourceTypes\n    const validResourceTypes = Object.values(ACL_RESOURCE_TYPES)\n    invalidType = filters.find(i => !validResourceTypes.includes(i.resourceType))\n\n    if (invalidType) {\n      throw new KafkaJSNonRetriableError(\n        `Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`\n      )\n    }\n\n    const retrier = createRetry(retry)\n\n    return retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await cluster.refreshMetadata()\n        const broker = await cluster.findControllerBroker()\n        const { filterResponses } = await broker.deleteAcls({ filters })\n        return { filterResponses }\n      } catch (e) {\n        if (e.type === 'NOT_CONTROLLER') {\n          logger.warn('Could not delete ACL', { error: e.message, retryCount, retryTime })\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {Function} listener\n   * @return {Function}\n   */\n  const on = (eventName, listener) => {\n    if (!eventNames.includes(eventName)) {\n      throw new KafkaJSNonRetriableError(`Event name should be one of ${eventKeys}`)\n    }\n\n    return instrumentationEmitter.addListener(unwrapEvent(eventName), event => {\n      event.type = wrapEvent(event.type)\n      Promise.resolve(listener(event)).catch(e => {\n        logger.error(`Failed to execute listener: ${e.message}`, {\n          eventName,\n          stack: e.stack,\n        })\n      })\n    })\n  }\n\n  /**\n   * @return {Object} logger\n   */\n  const getLogger = () => logger\n\n  return {\n    connect,\n    disconnect,\n    listTopics,\n    createTopics,\n    deleteTopics,\n    createPartitions,\n    getTopicMetadata,\n    fetchTopicMetadata,\n    describeCluster,\n    events,\n    fetchOffsets,\n    fetchTopicOffsets,\n    fetchTopicOffsetsByTimestamp,\n    setOffsets,\n    resetOffsets,\n    describeConfigs,\n    alterConfigs,\n    on,\n    logger: getLogger,\n    listGroups,\n    describeGroups,\n    deleteGroups,\n    describeAcls,\n    deleteAcls,\n    createAcls,\n    deleteTopicRecords,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}