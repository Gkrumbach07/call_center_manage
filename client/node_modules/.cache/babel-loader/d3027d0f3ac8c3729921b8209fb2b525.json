{"ast":null,"code":"const Broker = require('../broker');\n\nconst createRetry = require('../retry');\n\nconst shuffle = require('../utils/shuffle');\n\nconst arrayDiff = require('../utils/arrayDiff');\n\nconst {\n  KafkaJSBrokerNotFound,\n  KafkaJSProtocolError\n} = require('../errors');\n\nconst {\n  keys,\n  assign,\n  values\n} = Object;\n\nconst hasBrokerBeenReplaced = (broker, {\n  host,\n  port,\n  rack\n}) => broker.connection.host !== host || broker.connection.port !== port || broker.connection.rack !== rack;\n\nmodule.exports = class BrokerPool {\n  /**\n   * @param {ConnectionBuilder} connectionBuilder\n   * @param {Logger} logger\n   * @param {Object} retry\n   * @param {number} authenticationTimeout\n   * @param {number} reauthenticationThreshold\n   * @param {number} metadataMaxAge\n   */\n  constructor({\n    connectionBuilder,\n    logger,\n    retry,\n    allowAutoTopicCreation,\n    authenticationTimeout,\n    reauthenticationThreshold,\n    metadataMaxAge\n  }) {\n    this.rootLogger = logger;\n    this.connectionBuilder = connectionBuilder;\n    this.metadataMaxAge = metadataMaxAge || 0;\n    this.logger = logger.namespace('BrokerPool');\n    this.retrier = createRetry(assign({}, retry));\n\n    this.createBroker = options => new Broker({\n      allowAutoTopicCreation,\n      authenticationTimeout,\n      reauthenticationThreshold,\n      ...options\n    });\n\n    this.brokers = {};\n    this.metadata = null;\n    this.metadataExpireAt = null;\n    this.versions = null;\n    this.supportAuthenticationProtocol = null;\n  }\n  /**\n   * @public\n   * @returns {Boolean}\n   */\n\n\n  hasConnectedBrokers() {\n    const brokers = values(this.brokers);\n    return !!brokers.find(broker => broker.isConnected()) || (this.seedBroker ? this.seedBroker.isConnected() : false);\n  }\n\n  async createSeedBroker() {\n    if (this.seedBroker) {\n      await this.seedBroker.disconnect();\n    }\n\n    this.seedBroker = this.createBroker({\n      connection: await this.connectionBuilder.build(),\n      logger: this.rootLogger\n    });\n  }\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n\n\n  async connect() {\n    if (this.hasConnectedBrokers()) {\n      return;\n    }\n\n    if (!this.seedBroker) {\n      await this.createSeedBroker();\n    }\n\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await this.seedBroker.connect();\n        this.versions = this.seedBroker.versions;\n      } catch (e) {\n        if (e.name === 'KafkaJSConnectionError' || e.type === 'ILLEGAL_SASL_STATE') {\n          // Connection builder will always rotate the seed broker\n          await this.createSeedBroker();\n          this.logger.error(`Failed to connect to seed broker, trying another broker from the list: ${e.message}`, {\n            retryCount,\n            retryTime\n          });\n        } else {\n          this.logger.error(e.message, {\n            retryCount,\n            retryTime\n          });\n        }\n\n        if (e.retriable) throw e;\n        bail(e);\n      }\n    });\n  }\n  /**\n   * @public\n   * @returns {Promise}\n   */\n\n\n  async disconnect() {\n    this.seedBroker && (await this.seedBroker.disconnect());\n    await Promise.all(values(this.brokers).map(broker => broker.disconnect()));\n    this.brokers = {};\n    this.metadata = null;\n    this.versions = null;\n    this.supportAuthenticationProtocol = null;\n  }\n  /**\n   * @public\n   * @param {String} host\n   * @param {Number} port\n   */\n\n\n  removeBroker({\n    host,\n    port\n  }) {\n    const removedBroker = values(this.brokers).find(broker => broker.connection.host === host && broker.connection.port === port);\n\n    if (removedBroker) {\n      delete this.brokers[removedBroker.nodeId];\n      this.metadataExpireAt = null;\n\n      if (this.seedBroker.nodeId === removedBroker.nodeId) {\n        this.seedBroker = shuffle(values(this.brokers))[0];\n      }\n    }\n  }\n  /**\n   * @public\n   * @param {Array<String>} topics\n   * @returns {Promise<null>}\n   */\n\n\n  async refreshMetadata(topics) {\n    const broker = await this.findConnectedBroker();\n    const {\n      host: seedHost,\n      port: seedPort\n    } = this.seedBroker.connection;\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        this.metadata = await broker.metadata(topics);\n        this.metadataExpireAt = Date.now() + this.metadataMaxAge;\n        const replacedBrokers = [];\n        this.brokers = await this.metadata.brokers.reduce(async (resultPromise, {\n          nodeId,\n          host,\n          port,\n          rack\n        }) => {\n          const result = await resultPromise;\n\n          if (result[nodeId]) {\n            if (!hasBrokerBeenReplaced(result[nodeId], {\n              host,\n              port,\n              rack\n            })) {\n              return result;\n            }\n\n            replacedBrokers.push(result[nodeId]);\n          }\n\n          if (host === seedHost && port === seedPort) {\n            this.seedBroker.nodeId = nodeId;\n            this.seedBroker.connection.rack = rack;\n            return assign(result, {\n              [nodeId]: this.seedBroker\n            });\n          }\n\n          return assign(result, {\n            [nodeId]: this.createBroker({\n              logger: this.rootLogger,\n              versions: this.versions,\n              supportAuthenticationProtocol: this.supportAuthenticationProtocol,\n              connection: await this.connectionBuilder.build({\n                host,\n                port,\n                rack\n              }),\n              nodeId\n            })\n          });\n        }, this.brokers);\n        const freshBrokerIds = this.metadata.brokers.map(({\n          nodeId\n        }) => `${nodeId}`).sort();\n        const currentBrokerIds = keys(this.brokers).sort();\n        const unusedBrokerIds = arrayDiff(currentBrokerIds, freshBrokerIds);\n        const brokerDisconnects = unusedBrokerIds.map(nodeId => {\n          const broker = this.brokers[nodeId];\n          return broker.disconnect().then(() => {\n            delete this.brokers[nodeId];\n          });\n        });\n        const replacedBrokersDisconnects = replacedBrokers.map(broker => broker.disconnect());\n        await Promise.all([...brokerDisconnects, ...replacedBrokersDisconnects]);\n      } catch (e) {\n        if (e.type === 'LEADER_NOT_AVAILABLE') {\n          throw e;\n        }\n\n        bail(e);\n      }\n    });\n  }\n  /**\n   * Only refreshes metadata if the data is stale according to the `metadataMaxAge` param\n   *\n   * @public\n   * @param {Array<String>} topics\n   * @returns {Promise<null>}\n   */\n\n\n  async refreshMetadataIfNecessary(topics) {\n    const shouldRefresh = this.metadata == null || this.metadataExpireAt == null || Date.now() > this.metadataExpireAt || !topics.every(topic => this.metadata.topicMetadata.some(topicMetadata => topicMetadata.topic === topic));\n\n    if (shouldRefresh) {\n      return this.refreshMetadata(topics);\n    }\n  }\n  /**\n   * @public\n   * @param {string} nodeId\n   * @returns {Promise<Broker>}\n   */\n\n\n  async findBroker({\n    nodeId\n  }) {\n    const broker = this.brokers[nodeId];\n\n    if (!broker) {\n      throw new KafkaJSBrokerNotFound(`Broker ${nodeId} not found in the cached metadata`);\n    }\n\n    await this.connectBroker(broker);\n    return broker;\n  }\n  /**\n   * @public\n   * @param {Promise<{ nodeId<String>, broker<Broker> }>} callback\n   * @returns {Promise<null>}\n   */\n\n\n  async withBroker(callback) {\n    const brokers = shuffle(keys(this.brokers));\n\n    if (brokers.length === 0) {\n      throw new KafkaJSBrokerNotFound('No brokers in the broker pool');\n    }\n\n    for (const nodeId of brokers) {\n      const broker = await this.findBroker({\n        nodeId\n      });\n\n      try {\n        return await callback({\n          nodeId,\n          broker\n        });\n      } catch (e) {}\n    }\n\n    return null;\n  }\n  /**\n   * @public\n   * @returns {Promise<Broker>}\n   */\n\n\n  async findConnectedBroker() {\n    const nodeIds = shuffle(keys(this.brokers));\n    const connectedBrokerId = nodeIds.find(nodeId => this.brokers[nodeId].isConnected());\n\n    if (connectedBrokerId) {\n      return await this.findBroker({\n        nodeId: connectedBrokerId\n      });\n    } // Cycle through the nodes until one connects\n\n\n    for (const nodeId of nodeIds) {\n      try {\n        return await this.findBroker({\n          nodeId\n        });\n      } catch (e) {}\n    } // Failed to connect to all known brokers, metadata might be old\n\n\n    await this.connect();\n    return this.seedBroker;\n  }\n  /**\n   * @private\n   * @param {Broker} broker\n   * @returns {Promise<null>}\n   */\n\n\n  async connectBroker(broker) {\n    if (broker.isConnected()) {\n      return;\n    }\n\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await broker.connect();\n      } catch (e) {\n        if (e.name === 'KafkaJSConnectionError' || e.type === 'ILLEGAL_SASL_STATE') {\n          await broker.disconnect();\n        } // To avoid reconnecting to an unavailable host, we bail on connection errors\n        // and refresh metadata on a higher level before reconnecting\n\n\n        if (e.name === 'KafkaJSConnectionError') {\n          return bail(e);\n        }\n\n        if (e.type === 'ILLEGAL_SASL_STATE') {\n          // Rebuild the connection since it can't recover from illegal SASL state\n          broker.connection = await this.connectionBuilder.build({\n            host: broker.connection.host,\n            port: broker.connection.port,\n            rack: broker.connection.rack\n          });\n          this.logger.error(`Failed to connect to broker, reconnecting`, {\n            retryCount,\n            retryTime\n          });\n          throw new KafkaJSProtocolError(e, {\n            retriable: true\n          });\n        }\n\n        if (e.retriable) throw e;\n        this.logger.error(e, {\n          retryCount,\n          retryTime,\n          stack: e.stack\n        });\n        bail(e);\n      }\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/cluster/brokerPool.js"],"names":["Broker","require","createRetry","shuffle","arrayDiff","KafkaJSBrokerNotFound","KafkaJSProtocolError","keys","assign","values","Object","hasBrokerBeenReplaced","broker","host","port","rack","connection","module","exports","BrokerPool","constructor","connectionBuilder","logger","retry","allowAutoTopicCreation","authenticationTimeout","reauthenticationThreshold","metadataMaxAge","rootLogger","namespace","retrier","createBroker","options","brokers","metadata","metadataExpireAt","versions","supportAuthenticationProtocol","hasConnectedBrokers","find","isConnected","seedBroker","createSeedBroker","disconnect","build","connect","bail","retryCount","retryTime","e","name","type","error","message","retriable","Promise","all","map","removeBroker","removedBroker","nodeId","refreshMetadata","topics","findConnectedBroker","seedHost","seedPort","Date","now","replacedBrokers","reduce","resultPromise","result","push","freshBrokerIds","sort","currentBrokerIds","unusedBrokerIds","brokerDisconnects","then","replacedBrokersDisconnects","refreshMetadataIfNecessary","shouldRefresh","every","topic","topicMetadata","some","findBroker","connectBroker","withBroker","callback","length","nodeIds","connectedBrokerId","stack"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,UAAD,CAA3B;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,oBAAD,CAAzB;;AACA,MAAM;AAAEI,EAAAA,qBAAF;AAAyBC,EAAAA;AAAzB,IAAkDL,OAAO,CAAC,WAAD,CAA/D;;AAEA,MAAM;AAAEM,EAAAA,IAAF;AAAQC,EAAAA,MAAR;AAAgBC,EAAAA;AAAhB,IAA2BC,MAAjC;;AACA,MAAMC,qBAAqB,GAAG,CAACC,MAAD,EAAS;AAAEC,EAAAA,IAAF;AAAQC,EAAAA,IAAR;AAAcC,EAAAA;AAAd,CAAT,KAC5BH,MAAM,CAACI,UAAP,CAAkBH,IAAlB,KAA2BA,IAA3B,IACAD,MAAM,CAACI,UAAP,CAAkBF,IAAlB,KAA2BA,IAD3B,IAEAF,MAAM,CAACI,UAAP,CAAkBD,IAAlB,KAA2BA,IAH7B;;AAKAE,MAAM,CAACC,OAAP,GAAiB,MAAMC,UAAN,CAAiB;AAChC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAAC;AACVC,IAAAA,iBADU;AAEVC,IAAAA,MAFU;AAGVC,IAAAA,KAHU;AAIVC,IAAAA,sBAJU;AAKVC,IAAAA,qBALU;AAMVC,IAAAA,yBANU;AAOVC,IAAAA;AAPU,GAAD,EAQR;AACD,SAAKC,UAAL,GAAkBN,MAAlB;AACA,SAAKD,iBAAL,GAAyBA,iBAAzB;AACA,SAAKM,cAAL,GAAsBA,cAAc,IAAI,CAAxC;AACA,SAAKL,MAAL,GAAcA,MAAM,CAACO,SAAP,CAAiB,YAAjB,CAAd;AACA,SAAKC,OAAL,GAAe5B,WAAW,CAACM,MAAM,CAAC,EAAD,EAAKe,KAAL,CAAP,CAA1B;;AAEA,SAAKQ,YAAL,GAAoBC,OAAO,IACzB,IAAIhC,MAAJ,CAAW;AACTwB,MAAAA,sBADS;AAETC,MAAAA,qBAFS;AAGTC,MAAAA,yBAHS;AAIT,SAAGM;AAJM,KAAX,CADF;;AAQA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKC,6BAAL,GAAqC,IAArC;AACD;AAED;AACF;AACA;AACA;;;AACEC,EAAAA,mBAAmB,GAAG;AACpB,UAAML,OAAO,GAAGxB,MAAM,CAAC,KAAKwB,OAAN,CAAtB;AACA,WACE,CAAC,CAACA,OAAO,CAACM,IAAR,CAAa3B,MAAM,IAAIA,MAAM,CAAC4B,WAAP,EAAvB,CAAF,KACC,KAAKC,UAAL,GAAkB,KAAKA,UAAL,CAAgBD,WAAhB,EAAlB,GAAkD,KADnD,CADF;AAID;;AAED,QAAME,gBAAN,GAAyB;AACvB,QAAI,KAAKD,UAAT,EAAqB;AACnB,YAAM,KAAKA,UAAL,CAAgBE,UAAhB,EAAN;AACD;;AAED,SAAKF,UAAL,GAAkB,KAAKV,YAAL,CAAkB;AAClCf,MAAAA,UAAU,EAAE,MAAM,KAAKK,iBAAL,CAAuBuB,KAAvB,EADgB;AAElCtB,MAAAA,MAAM,EAAE,KAAKM;AAFqB,KAAlB,CAAlB;AAID;AAED;AACF;AACA;AACA;;;AACE,QAAMiB,OAAN,GAAgB;AACd,QAAI,KAAKP,mBAAL,EAAJ,EAAgC;AAC9B;AACD;;AAED,QAAI,CAAC,KAAKG,UAAV,EAAsB;AACpB,YAAM,KAAKC,gBAAL,EAAN;AACD;;AAED,WAAO,KAAKZ,OAAL,CAAa,OAAOgB,IAAP,EAAaC,UAAb,EAAyBC,SAAzB,KAAuC;AACzD,UAAI;AACF,cAAM,KAAKP,UAAL,CAAgBI,OAAhB,EAAN;AACA,aAAKT,QAAL,GAAgB,KAAKK,UAAL,CAAgBL,QAAhC;AACD,OAHD,CAGE,OAAOa,CAAP,EAAU;AACV,YAAIA,CAAC,CAACC,IAAF,KAAW,wBAAX,IAAuCD,CAAC,CAACE,IAAF,KAAW,oBAAtD,EAA4E;AAC1E;AACA,gBAAM,KAAKT,gBAAL,EAAN;AACA,eAAKpB,MAAL,CAAY8B,KAAZ,CACG,0EAAyEH,CAAC,CAACI,OAAQ,EADtF,EAEE;AAAEN,YAAAA,UAAF;AAAcC,YAAAA;AAAd,WAFF;AAID,SAPD,MAOO;AACL,eAAK1B,MAAL,CAAY8B,KAAZ,CAAkBH,CAAC,CAACI,OAApB,EAA6B;AAAEN,YAAAA,UAAF;AAAcC,YAAAA;AAAd,WAA7B;AACD;;AAED,YAAIC,CAAC,CAACK,SAAN,EAAiB,MAAML,CAAN;AACjBH,QAAAA,IAAI,CAACG,CAAD,CAAJ;AACD;AACF,KAnBM,CAAP;AAoBD;AAED;AACF;AACA;AACA;;;AACE,QAAMN,UAAN,GAAmB;AACjB,SAAKF,UAAL,KAAoB,MAAM,KAAKA,UAAL,CAAgBE,UAAhB,EAA1B;AACA,UAAMY,OAAO,CAACC,GAAR,CAAY/C,MAAM,CAAC,KAAKwB,OAAN,CAAN,CAAqBwB,GAArB,CAAyB7C,MAAM,IAAIA,MAAM,CAAC+B,UAAP,EAAnC,CAAZ,CAAN;AAEA,SAAKV,OAAL,GAAe,EAAf;AACA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKE,QAAL,GAAgB,IAAhB;AACA,SAAKC,6BAAL,GAAqC,IAArC;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEqB,EAAAA,YAAY,CAAC;AAAE7C,IAAAA,IAAF;AAAQC,IAAAA;AAAR,GAAD,EAAiB;AAC3B,UAAM6C,aAAa,GAAGlD,MAAM,CAAC,KAAKwB,OAAN,CAAN,CAAqBM,IAArB,CACpB3B,MAAM,IAAIA,MAAM,CAACI,UAAP,CAAkBH,IAAlB,KAA2BA,IAA3B,IAAmCD,MAAM,CAACI,UAAP,CAAkBF,IAAlB,KAA2BA,IADpD,CAAtB;;AAIA,QAAI6C,aAAJ,EAAmB;AACjB,aAAO,KAAK1B,OAAL,CAAa0B,aAAa,CAACC,MAA3B,CAAP;AACA,WAAKzB,gBAAL,GAAwB,IAAxB;;AAEA,UAAI,KAAKM,UAAL,CAAgBmB,MAAhB,KAA2BD,aAAa,CAACC,MAA7C,EAAqD;AACnD,aAAKnB,UAAL,GAAkBtC,OAAO,CAACM,MAAM,CAAC,KAAKwB,OAAN,CAAP,CAAP,CAA8B,CAA9B,CAAlB;AACD;AACF;AACF;AAED;AACF;AACA;AACA;AACA;;;AACE,QAAM4B,eAAN,CAAsBC,MAAtB,EAA8B;AAC5B,UAAMlD,MAAM,GAAG,MAAM,KAAKmD,mBAAL,EAArB;AACA,UAAM;AAAElD,MAAAA,IAAI,EAAEmD,QAAR;AAAkBlD,MAAAA,IAAI,EAAEmD;AAAxB,QAAqC,KAAKxB,UAAL,CAAgBzB,UAA3D;AAEA,WAAO,KAAKc,OAAL,CAAa,OAAOgB,IAAP,EAAaC,UAAb,EAAyBC,SAAzB,KAAuC;AACzD,UAAI;AACF,aAAKd,QAAL,GAAgB,MAAMtB,MAAM,CAACsB,QAAP,CAAgB4B,MAAhB,CAAtB;AACA,aAAK3B,gBAAL,GAAwB+B,IAAI,CAACC,GAAL,KAAa,KAAKxC,cAA1C;AAEA,cAAMyC,eAAe,GAAG,EAAxB;AAEA,aAAKnC,OAAL,GAAe,MAAM,KAAKC,QAAL,CAAcD,OAAd,CAAsBoC,MAAtB,CACnB,OAAOC,aAAP,EAAsB;AAAEV,UAAAA,MAAF;AAAU/C,UAAAA,IAAV;AAAgBC,UAAAA,IAAhB;AAAsBC,UAAAA;AAAtB,SAAtB,KAAuD;AACrD,gBAAMwD,MAAM,GAAG,MAAMD,aAArB;;AAEA,cAAIC,MAAM,CAACX,MAAD,CAAV,EAAoB;AAClB,gBAAI,CAACjD,qBAAqB,CAAC4D,MAAM,CAACX,MAAD,CAAP,EAAiB;AAAE/C,cAAAA,IAAF;AAAQC,cAAAA,IAAR;AAAcC,cAAAA;AAAd,aAAjB,CAA1B,EAAkE;AAChE,qBAAOwD,MAAP;AACD;;AAEDH,YAAAA,eAAe,CAACI,IAAhB,CAAqBD,MAAM,CAACX,MAAD,CAA3B;AACD;;AAED,cAAI/C,IAAI,KAAKmD,QAAT,IAAqBlD,IAAI,KAAKmD,QAAlC,EAA4C;AAC1C,iBAAKxB,UAAL,CAAgBmB,MAAhB,GAAyBA,MAAzB;AACA,iBAAKnB,UAAL,CAAgBzB,UAAhB,CAA2BD,IAA3B,GAAkCA,IAAlC;AACA,mBAAOP,MAAM,CAAC+D,MAAD,EAAS;AACpB,eAACX,MAAD,GAAU,KAAKnB;AADK,aAAT,CAAb;AAGD;;AAED,iBAAOjC,MAAM,CAAC+D,MAAD,EAAS;AACpB,aAACX,MAAD,GAAU,KAAK7B,YAAL,CAAkB;AAC1BT,cAAAA,MAAM,EAAE,KAAKM,UADa;AAE1BQ,cAAAA,QAAQ,EAAE,KAAKA,QAFW;AAG1BC,cAAAA,6BAA6B,EAAE,KAAKA,6BAHV;AAI1BrB,cAAAA,UAAU,EAAE,MAAM,KAAKK,iBAAL,CAAuBuB,KAAvB,CAA6B;AAAE/B,gBAAAA,IAAF;AAAQC,gBAAAA,IAAR;AAAcC,gBAAAA;AAAd,eAA7B,CAJQ;AAK1B6C,cAAAA;AAL0B,aAAlB;AADU,WAAT,CAAb;AASD,SA7BkB,EA8BnB,KAAK3B,OA9Bc,CAArB;AAiCA,cAAMwC,cAAc,GAAG,KAAKvC,QAAL,CAAcD,OAAd,CAAsBwB,GAAtB,CAA0B,CAAC;AAAEG,UAAAA;AAAF,SAAD,KAAiB,GAAEA,MAAO,EAApD,EAAuDc,IAAvD,EAAvB;AACA,cAAMC,gBAAgB,GAAGpE,IAAI,CAAC,KAAK0B,OAAN,CAAJ,CAAmByC,IAAnB,EAAzB;AACA,cAAME,eAAe,GAAGxE,SAAS,CAACuE,gBAAD,EAAmBF,cAAnB,CAAjC;AAEA,cAAMI,iBAAiB,GAAGD,eAAe,CAACnB,GAAhB,CAAoBG,MAAM,IAAI;AACtD,gBAAMhD,MAAM,GAAG,KAAKqB,OAAL,CAAa2B,MAAb,CAAf;AACA,iBAAOhD,MAAM,CAAC+B,UAAP,GAAoBmC,IAApB,CAAyB,MAAM;AACpC,mBAAO,KAAK7C,OAAL,CAAa2B,MAAb,CAAP;AACD,WAFM,CAAP;AAGD,SALyB,CAA1B;AAOA,cAAMmB,0BAA0B,GAAGX,eAAe,CAACX,GAAhB,CAAoB7C,MAAM,IAAIA,MAAM,CAAC+B,UAAP,EAA9B,CAAnC;AACA,cAAMY,OAAO,CAACC,GAAR,CAAY,CAAC,GAAGqB,iBAAJ,EAAuB,GAAGE,0BAA1B,CAAZ,CAAN;AACD,OApDD,CAoDE,OAAO9B,CAAP,EAAU;AACV,YAAIA,CAAC,CAACE,IAAF,KAAW,sBAAf,EAAuC;AACrC,gBAAMF,CAAN;AACD;;AAEDH,QAAAA,IAAI,CAACG,CAAD,CAAJ;AACD;AACF,KA5DM,CAAP;AA6DD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACE,QAAM+B,0BAAN,CAAiClB,MAAjC,EAAyC;AACvC,UAAMmB,aAAa,GACjB,KAAK/C,QAAL,IAAiB,IAAjB,IACA,KAAKC,gBAAL,IAAyB,IADzB,IAEA+B,IAAI,CAACC,GAAL,KAAa,KAAKhC,gBAFlB,IAGA,CAAC2B,MAAM,CAACoB,KAAP,CAAaC,KAAK,IACjB,KAAKjD,QAAL,CAAckD,aAAd,CAA4BC,IAA5B,CAAiCD,aAAa,IAAIA,aAAa,CAACD,KAAd,KAAwBA,KAA1E,CADD,CAJH;;AAQA,QAAIF,aAAJ,EAAmB;AACjB,aAAO,KAAKpB,eAAL,CAAqBC,MAArB,CAAP;AACD;AACF;AAED;AACF;AACA;AACA;AACA;;;AACE,QAAMwB,UAAN,CAAiB;AAAE1B,IAAAA;AAAF,GAAjB,EAA6B;AAC3B,UAAMhD,MAAM,GAAG,KAAKqB,OAAL,CAAa2B,MAAb,CAAf;;AAEA,QAAI,CAAChD,MAAL,EAAa;AACX,YAAM,IAAIP,qBAAJ,CAA2B,UAASuD,MAAO,mCAA3C,CAAN;AACD;;AAED,UAAM,KAAK2B,aAAL,CAAmB3E,MAAnB,CAAN;AACA,WAAOA,MAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,QAAM4E,UAAN,CAAiBC,QAAjB,EAA2B;AACzB,UAAMxD,OAAO,GAAG9B,OAAO,CAACI,IAAI,CAAC,KAAK0B,OAAN,CAAL,CAAvB;;AACA,QAAIA,OAAO,CAACyD,MAAR,KAAmB,CAAvB,EAA0B;AACxB,YAAM,IAAIrF,qBAAJ,CAA0B,+BAA1B,CAAN;AACD;;AAED,SAAK,MAAMuD,MAAX,IAAqB3B,OAArB,EAA8B;AAC5B,YAAMrB,MAAM,GAAG,MAAM,KAAK0E,UAAL,CAAgB;AAAE1B,QAAAA;AAAF,OAAhB,CAArB;;AACA,UAAI;AACF,eAAO,MAAM6B,QAAQ,CAAC;AAAE7B,UAAAA,MAAF;AAAUhD,UAAAA;AAAV,SAAD,CAArB;AACD,OAFD,CAEE,OAAOqC,CAAP,EAAU,CAAE;AACf;;AAED,WAAO,IAAP;AACD;AAED;AACF;AACA;AACA;;;AACE,QAAMc,mBAAN,GAA4B;AAC1B,UAAM4B,OAAO,GAAGxF,OAAO,CAACI,IAAI,CAAC,KAAK0B,OAAN,CAAL,CAAvB;AACA,UAAM2D,iBAAiB,GAAGD,OAAO,CAACpD,IAAR,CAAaqB,MAAM,IAAI,KAAK3B,OAAL,CAAa2B,MAAb,EAAqBpB,WAArB,EAAvB,CAA1B;;AAEA,QAAIoD,iBAAJ,EAAuB;AACrB,aAAO,MAAM,KAAKN,UAAL,CAAgB;AAAE1B,QAAAA,MAAM,EAAEgC;AAAV,OAAhB,CAAb;AACD,KANyB,CAQ1B;;;AACA,SAAK,MAAMhC,MAAX,IAAqB+B,OAArB,EAA8B;AAC5B,UAAI;AACF,eAAO,MAAM,KAAKL,UAAL,CAAgB;AAAE1B,UAAAA;AAAF,SAAhB,CAAb;AACD,OAFD,CAEE,OAAOX,CAAP,EAAU,CAAE;AACf,KAbyB,CAe1B;;;AACA,UAAM,KAAKJ,OAAL,EAAN;AACA,WAAO,KAAKJ,UAAZ;AACD;AAED;AACF;AACA;AACA;AACA;;;AACE,QAAM8C,aAAN,CAAoB3E,MAApB,EAA4B;AAC1B,QAAIA,MAAM,CAAC4B,WAAP,EAAJ,EAA0B;AACxB;AACD;;AAED,WAAO,KAAKV,OAAL,CAAa,OAAOgB,IAAP,EAAaC,UAAb,EAAyBC,SAAzB,KAAuC;AACzD,UAAI;AACF,cAAMpC,MAAM,CAACiC,OAAP,EAAN;AACD,OAFD,CAEE,OAAOI,CAAP,EAAU;AACV,YAAIA,CAAC,CAACC,IAAF,KAAW,wBAAX,IAAuCD,CAAC,CAACE,IAAF,KAAW,oBAAtD,EAA4E;AAC1E,gBAAMvC,MAAM,CAAC+B,UAAP,EAAN;AACD,SAHS,CAKV;AACA;;;AACA,YAAIM,CAAC,CAACC,IAAF,KAAW,wBAAf,EAAyC;AACvC,iBAAOJ,IAAI,CAACG,CAAD,CAAX;AACD;;AAED,YAAIA,CAAC,CAACE,IAAF,KAAW,oBAAf,EAAqC;AACnC;AACAvC,UAAAA,MAAM,CAACI,UAAP,GAAoB,MAAM,KAAKK,iBAAL,CAAuBuB,KAAvB,CAA6B;AACrD/B,YAAAA,IAAI,EAAED,MAAM,CAACI,UAAP,CAAkBH,IAD6B;AAErDC,YAAAA,IAAI,EAAEF,MAAM,CAACI,UAAP,CAAkBF,IAF6B;AAGrDC,YAAAA,IAAI,EAAEH,MAAM,CAACI,UAAP,CAAkBD;AAH6B,WAA7B,CAA1B;AAMA,eAAKO,MAAL,CAAY8B,KAAZ,CAAmB,2CAAnB,EAA+D;AAAEL,YAAAA,UAAF;AAAcC,YAAAA;AAAd,WAA/D;AACA,gBAAM,IAAI1C,oBAAJ,CAAyB2C,CAAzB,EAA4B;AAAEK,YAAAA,SAAS,EAAE;AAAb,WAA5B,CAAN;AACD;;AAED,YAAIL,CAAC,CAACK,SAAN,EAAiB,MAAML,CAAN;AACjB,aAAK3B,MAAL,CAAY8B,KAAZ,CAAkBH,CAAlB,EAAqB;AAAEF,UAAAA,UAAF;AAAcC,UAAAA,SAAd;AAAyB6C,UAAAA,KAAK,EAAE5C,CAAC,CAAC4C;AAAlC,SAArB;AACA/C,QAAAA,IAAI,CAACG,CAAD,CAAJ;AACD;AACF,KA9BM,CAAP;AA+BD;;AAtU+B,CAAlC","sourcesContent":["const Broker = require('../broker')\nconst createRetry = require('../retry')\nconst shuffle = require('../utils/shuffle')\nconst arrayDiff = require('../utils/arrayDiff')\nconst { KafkaJSBrokerNotFound, KafkaJSProtocolError } = require('../errors')\n\nconst { keys, assign, values } = Object\nconst hasBrokerBeenReplaced = (broker, { host, port, rack }) =>\n  broker.connection.host !== host ||\n  broker.connection.port !== port ||\n  broker.connection.rack !== rack\n\nmodule.exports = class BrokerPool {\n  /**\n   * @param {ConnectionBuilder} connectionBuilder\n   * @param {Logger} logger\n   * @param {Object} retry\n   * @param {number} authenticationTimeout\n   * @param {number} reauthenticationThreshold\n   * @param {number} metadataMaxAge\n   */\n  constructor({\n    connectionBuilder,\n    logger,\n    retry,\n    allowAutoTopicCreation,\n    authenticationTimeout,\n    reauthenticationThreshold,\n    metadataMaxAge,\n  }) {\n    this.rootLogger = logger\n    this.connectionBuilder = connectionBuilder\n    this.metadataMaxAge = metadataMaxAge || 0\n    this.logger = logger.namespace('BrokerPool')\n    this.retrier = createRetry(assign({}, retry))\n\n    this.createBroker = options =>\n      new Broker({\n        allowAutoTopicCreation,\n        authenticationTimeout,\n        reauthenticationThreshold,\n        ...options,\n      })\n\n    this.brokers = {}\n    this.metadata = null\n    this.metadataExpireAt = null\n    this.versions = null\n    this.supportAuthenticationProtocol = null\n  }\n\n  /**\n   * @public\n   * @returns {Boolean}\n   */\n  hasConnectedBrokers() {\n    const brokers = values(this.brokers)\n    return (\n      !!brokers.find(broker => broker.isConnected()) ||\n      (this.seedBroker ? this.seedBroker.isConnected() : false)\n    )\n  }\n\n  async createSeedBroker() {\n    if (this.seedBroker) {\n      await this.seedBroker.disconnect()\n    }\n\n    this.seedBroker = this.createBroker({\n      connection: await this.connectionBuilder.build(),\n      logger: this.rootLogger,\n    })\n  }\n\n  /**\n   * @public\n   * @returns {Promise<null>}\n   */\n  async connect() {\n    if (this.hasConnectedBrokers()) {\n      return\n    }\n\n    if (!this.seedBroker) {\n      await this.createSeedBroker()\n    }\n\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await this.seedBroker.connect()\n        this.versions = this.seedBroker.versions\n      } catch (e) {\n        if (e.name === 'KafkaJSConnectionError' || e.type === 'ILLEGAL_SASL_STATE') {\n          // Connection builder will always rotate the seed broker\n          await this.createSeedBroker()\n          this.logger.error(\n            `Failed to connect to seed broker, trying another broker from the list: ${e.message}`,\n            { retryCount, retryTime }\n          )\n        } else {\n          this.logger.error(e.message, { retryCount, retryTime })\n        }\n\n        if (e.retriable) throw e\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * @public\n   * @returns {Promise}\n   */\n  async disconnect() {\n    this.seedBroker && (await this.seedBroker.disconnect())\n    await Promise.all(values(this.brokers).map(broker => broker.disconnect()))\n\n    this.brokers = {}\n    this.metadata = null\n    this.versions = null\n    this.supportAuthenticationProtocol = null\n  }\n\n  /**\n   * @public\n   * @param {String} host\n   * @param {Number} port\n   */\n  removeBroker({ host, port }) {\n    const removedBroker = values(this.brokers).find(\n      broker => broker.connection.host === host && broker.connection.port === port\n    )\n\n    if (removedBroker) {\n      delete this.brokers[removedBroker.nodeId]\n      this.metadataExpireAt = null\n\n      if (this.seedBroker.nodeId === removedBroker.nodeId) {\n        this.seedBroker = shuffle(values(this.brokers))[0]\n      }\n    }\n  }\n\n  /**\n   * @public\n   * @param {Array<String>} topics\n   * @returns {Promise<null>}\n   */\n  async refreshMetadata(topics) {\n    const broker = await this.findConnectedBroker()\n    const { host: seedHost, port: seedPort } = this.seedBroker.connection\n\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        this.metadata = await broker.metadata(topics)\n        this.metadataExpireAt = Date.now() + this.metadataMaxAge\n\n        const replacedBrokers = []\n\n        this.brokers = await this.metadata.brokers.reduce(\n          async (resultPromise, { nodeId, host, port, rack }) => {\n            const result = await resultPromise\n\n            if (result[nodeId]) {\n              if (!hasBrokerBeenReplaced(result[nodeId], { host, port, rack })) {\n                return result\n              }\n\n              replacedBrokers.push(result[nodeId])\n            }\n\n            if (host === seedHost && port === seedPort) {\n              this.seedBroker.nodeId = nodeId\n              this.seedBroker.connection.rack = rack\n              return assign(result, {\n                [nodeId]: this.seedBroker,\n              })\n            }\n\n            return assign(result, {\n              [nodeId]: this.createBroker({\n                logger: this.rootLogger,\n                versions: this.versions,\n                supportAuthenticationProtocol: this.supportAuthenticationProtocol,\n                connection: await this.connectionBuilder.build({ host, port, rack }),\n                nodeId,\n              }),\n            })\n          },\n          this.brokers\n        )\n\n        const freshBrokerIds = this.metadata.brokers.map(({ nodeId }) => `${nodeId}`).sort()\n        const currentBrokerIds = keys(this.brokers).sort()\n        const unusedBrokerIds = arrayDiff(currentBrokerIds, freshBrokerIds)\n\n        const brokerDisconnects = unusedBrokerIds.map(nodeId => {\n          const broker = this.brokers[nodeId]\n          return broker.disconnect().then(() => {\n            delete this.brokers[nodeId]\n          })\n        })\n\n        const replacedBrokersDisconnects = replacedBrokers.map(broker => broker.disconnect())\n        await Promise.all([...brokerDisconnects, ...replacedBrokersDisconnects])\n      } catch (e) {\n        if (e.type === 'LEADER_NOT_AVAILABLE') {\n          throw e\n        }\n\n        bail(e)\n      }\n    })\n  }\n\n  /**\n   * Only refreshes metadata if the data is stale according to the `metadataMaxAge` param\n   *\n   * @public\n   * @param {Array<String>} topics\n   * @returns {Promise<null>}\n   */\n  async refreshMetadataIfNecessary(topics) {\n    const shouldRefresh =\n      this.metadata == null ||\n      this.metadataExpireAt == null ||\n      Date.now() > this.metadataExpireAt ||\n      !topics.every(topic =>\n        this.metadata.topicMetadata.some(topicMetadata => topicMetadata.topic === topic)\n      )\n\n    if (shouldRefresh) {\n      return this.refreshMetadata(topics)\n    }\n  }\n\n  /**\n   * @public\n   * @param {string} nodeId\n   * @returns {Promise<Broker>}\n   */\n  async findBroker({ nodeId }) {\n    const broker = this.brokers[nodeId]\n\n    if (!broker) {\n      throw new KafkaJSBrokerNotFound(`Broker ${nodeId} not found in the cached metadata`)\n    }\n\n    await this.connectBroker(broker)\n    return broker\n  }\n\n  /**\n   * @public\n   * @param {Promise<{ nodeId<String>, broker<Broker> }>} callback\n   * @returns {Promise<null>}\n   */\n  async withBroker(callback) {\n    const brokers = shuffle(keys(this.brokers))\n    if (brokers.length === 0) {\n      throw new KafkaJSBrokerNotFound('No brokers in the broker pool')\n    }\n\n    for (const nodeId of brokers) {\n      const broker = await this.findBroker({ nodeId })\n      try {\n        return await callback({ nodeId, broker })\n      } catch (e) {}\n    }\n\n    return null\n  }\n\n  /**\n   * @public\n   * @returns {Promise<Broker>}\n   */\n  async findConnectedBroker() {\n    const nodeIds = shuffle(keys(this.brokers))\n    const connectedBrokerId = nodeIds.find(nodeId => this.brokers[nodeId].isConnected())\n\n    if (connectedBrokerId) {\n      return await this.findBroker({ nodeId: connectedBrokerId })\n    }\n\n    // Cycle through the nodes until one connects\n    for (const nodeId of nodeIds) {\n      try {\n        return await this.findBroker({ nodeId })\n      } catch (e) {}\n    }\n\n    // Failed to connect to all known brokers, metadata might be old\n    await this.connect()\n    return this.seedBroker\n  }\n\n  /**\n   * @private\n   * @param {Broker} broker\n   * @returns {Promise<null>}\n   */\n  async connectBroker(broker) {\n    if (broker.isConnected()) {\n      return\n    }\n\n    return this.retrier(async (bail, retryCount, retryTime) => {\n      try {\n        await broker.connect()\n      } catch (e) {\n        if (e.name === 'KafkaJSConnectionError' || e.type === 'ILLEGAL_SASL_STATE') {\n          await broker.disconnect()\n        }\n\n        // To avoid reconnecting to an unavailable host, we bail on connection errors\n        // and refresh metadata on a higher level before reconnecting\n        if (e.name === 'KafkaJSConnectionError') {\n          return bail(e)\n        }\n\n        if (e.type === 'ILLEGAL_SASL_STATE') {\n          // Rebuild the connection since it can't recover from illegal SASL state\n          broker.connection = await this.connectionBuilder.build({\n            host: broker.connection.host,\n            port: broker.connection.port,\n            rack: broker.connection.rack,\n          })\n\n          this.logger.error(`Failed to connect to broker, reconnecting`, { retryCount, retryTime })\n          throw new KafkaJSProtocolError(e, { retriable: true })\n        }\n\n        if (e.retriable) throw e\n        this.logger.error(e, { retryCount, retryTime, stack: e.stack })\n        bail(e)\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}