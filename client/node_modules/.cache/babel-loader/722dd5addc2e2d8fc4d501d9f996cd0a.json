{"ast":null,"code":"const {\n  KafkaJSNumberOfRetriesExceeded\n} = require('../errors');\n\nconst isTestMode = process.env.NODE_ENV === 'test';\nconst RETRY_DEFAULT = isTestMode ? require('./defaults.test') : require('./defaults');\n\nconst random = (min, max) => {\n  return Math.random() * (max - min) + min;\n};\n\nconst randomFromRetryTime = (factor, retryTime) => {\n  const delta = factor * retryTime;\n  return Math.ceil(random(retryTime - delta, retryTime + delta));\n};\n\nconst UNRECOVERABLE_ERRORS = ['RangeError', 'ReferenceError', 'SyntaxError', 'TypeError'];\n\nconst isErrorUnrecoverable = e => UNRECOVERABLE_ERRORS.includes(e.name);\n\nconst isErrorRetriable = error => (error.retriable || error.retriable !== false) && !isErrorUnrecoverable(error);\n\nconst createRetriable = (configs, resolve, reject, fn) => {\n  let aborted = false;\n  const {\n    factor,\n    multiplier,\n    maxRetryTime,\n    retries\n  } = configs;\n\n  const bail = error => {\n    aborted = true;\n    reject(error || new Error('Aborted'));\n  };\n\n  const calculateExponentialRetryTime = retryTime => {\n    return Math.min(randomFromRetryTime(factor, retryTime) * multiplier, maxRetryTime);\n  };\n\n  const retry = (retryTime, retryCount = 0) => {\n    if (aborted) return;\n    const nextRetryTime = calculateExponentialRetryTime(retryTime);\n    const shouldRetry = retryCount < retries;\n\n    const scheduleRetry = () => {\n      setTimeout(() => retry(nextRetryTime, retryCount + 1), retryTime);\n    };\n\n    fn(bail, retryCount, retryTime).then(resolve).catch(e => {\n      if (shouldRetry && isErrorRetriable(e)) {\n        scheduleRetry();\n      } else {\n        reject(new KafkaJSNumberOfRetriesExceeded(e, {\n          retryCount,\n          retryTime\n        }));\n      }\n    });\n  };\n\n  return retry;\n};\n\nmodule.exports = (opts = {}) => fn => {\n  return new Promise((resolve, reject) => {\n    const configs = Object.assign({}, RETRY_DEFAULT, opts);\n    const start = createRetriable(configs, resolve, reject, fn);\n    start(randomFromRetryTime(configs.factor, configs.initialRetryTime));\n  });\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/retry/index.js"],"names":["KafkaJSNumberOfRetriesExceeded","require","isTestMode","process","env","NODE_ENV","RETRY_DEFAULT","random","min","max","Math","randomFromRetryTime","factor","retryTime","delta","ceil","UNRECOVERABLE_ERRORS","isErrorUnrecoverable","e","includes","name","isErrorRetriable","error","retriable","createRetriable","configs","resolve","reject","fn","aborted","multiplier","maxRetryTime","retries","bail","Error","calculateExponentialRetryTime","retry","retryCount","nextRetryTime","shouldRetry","scheduleRetry","setTimeout","then","catch","module","exports","opts","Promise","Object","assign","start","initialRetryTime"],"mappings":"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","sourcesContent":["const { KafkaJSNumberOfRetriesExceeded } = require('../errors')\n\nconst isTestMode = process.env.NODE_ENV === 'test'\nconst RETRY_DEFAULT = isTestMode ? require('./defaults.test') : require('./defaults')\n\nconst random = (min, max) => {\n  return Math.random() * (max - min) + min\n}\n\nconst randomFromRetryTime = (factor, retryTime) => {\n  const delta = factor * retryTime\n  return Math.ceil(random(retryTime - delta, retryTime + delta))\n}\n\nconst UNRECOVERABLE_ERRORS = ['RangeError', 'ReferenceError', 'SyntaxError', 'TypeError']\nconst isErrorUnrecoverable = e => UNRECOVERABLE_ERRORS.includes(e.name)\nconst isErrorRetriable = error =>\n  (error.retriable || error.retriable !== false) && !isErrorUnrecoverable(error)\n\nconst createRetriable = (configs, resolve, reject, fn) => {\n  let aborted = false\n  const { factor, multiplier, maxRetryTime, retries } = configs\n\n  const bail = error => {\n    aborted = true\n    reject(error || new Error('Aborted'))\n  }\n\n  const calculateExponentialRetryTime = retryTime => {\n    return Math.min(randomFromRetryTime(factor, retryTime) * multiplier, maxRetryTime)\n  }\n\n  const retry = (retryTime, retryCount = 0) => {\n    if (aborted) return\n\n    const nextRetryTime = calculateExponentialRetryTime(retryTime)\n    const shouldRetry = retryCount < retries\n\n    const scheduleRetry = () => {\n      setTimeout(() => retry(nextRetryTime, retryCount + 1), retryTime)\n    }\n\n    fn(bail, retryCount, retryTime)\n      .then(resolve)\n      .catch(e => {\n        if (shouldRetry && isErrorRetriable(e)) {\n          scheduleRetry()\n        } else {\n          reject(new KafkaJSNumberOfRetriesExceeded(e, { retryCount, retryTime }))\n        }\n      })\n  }\n\n  return retry\n}\n\nmodule.exports = (opts = {}) => fn => {\n  return new Promise((resolve, reject) => {\n    const configs = Object.assign({}, RETRY_DEFAULT, opts)\n    const start = createRetriable(configs, resolve, reject, fn)\n    start(randomFromRetryTime(configs.factor, configs.initialRetryTime))\n  })\n}\n"]},"metadata":{},"sourceType":"script"}