{"ast":null,"code":"const {\n  EventEmitter\n} = require('events');\n\nconst {\n  KafkaJSNonRetriableError\n} = require('../../errors');\n\nconst STATES = require('./transactionStates');\n\nconst VALID_STATE_TRANSITIONS = {\n  [STATES.UNINITIALIZED]: [STATES.READY],\n  [STATES.READY]: [STATES.READY, STATES.TRANSACTING],\n  [STATES.TRANSACTING]: [STATES.COMMITTING, STATES.ABORTING],\n  [STATES.COMMITTING]: [STATES.READY],\n  [STATES.ABORTING]: [STATES.READY]\n};\n\nmodule.exports = ({\n  logger,\n  initialState = STATES.UNINITIALIZED\n}) => {\n  let currentState = initialState;\n\n  const guard = (object, method, {\n    legalStates,\n    async: isAsync = true\n  }) => {\n    if (!object[method]) {\n      throw new KafkaJSNonRetriableError(`Cannot add guard on missing method \"${method}\"`);\n    }\n\n    return (...args) => {\n      const fn = object[method];\n\n      if (!legalStates.includes(currentState)) {\n        const error = new KafkaJSNonRetriableError(`Transaction state exception: Cannot call \"${method}\" in state \"${currentState}\"`);\n\n        if (isAsync) {\n          return Promise.reject(error);\n        } else {\n          throw error;\n        }\n      }\n\n      return fn.apply(object, args);\n    };\n  };\n\n  const stateMachine = Object.assign(new EventEmitter(), {\n    /**\n     * Create a clone of \"object\" where we ensure state machine is in correct state\n     * prior to calling any of the configured methods\n     * @param {Object} object The object whose methods we will guard\n     * @param {Object} methodStateMapping Keys are method names on \"object\"\n     * @param {string[]} methodStateMapping.legalStates Legal states for this method\n     * @param {boolean=true} methodStateMapping.async Whether this method is async (throw vs reject)\n     */\n    createGuarded(object, methodStateMapping) {\n      const guardedMethods = Object.keys(methodStateMapping).reduce((guards, method) => {\n        guards[method] = guard(object, method, methodStateMapping[method]);\n        return guards;\n      }, {});\n      return { ...object,\n        ...guardedMethods\n      };\n    },\n\n    /**\n     * Transition safely to a new state\n     */\n    transitionTo(state) {\n      logger.debug(`Transaction state transition ${currentState} --> ${state}`);\n\n      if (!VALID_STATE_TRANSITIONS[currentState].includes(state)) {\n        throw new KafkaJSNonRetriableError(`Transaction state exception: Invalid transition ${currentState} --> ${state}`);\n      }\n\n      stateMachine.emit('transition', {\n        to: state,\n        from: currentState\n      });\n      currentState = state;\n    },\n\n    state() {\n      return currentState;\n    }\n\n  });\n  return stateMachine;\n};","map":{"version":3,"sources":["/Users/gagekrumbach/Documents/call-center-manage/node_modules/kafkajs/src/producer/eosManager/transactionStateMachine.js"],"names":["EventEmitter","require","KafkaJSNonRetriableError","STATES","VALID_STATE_TRANSITIONS","UNINITIALIZED","READY","TRANSACTING","COMMITTING","ABORTING","module","exports","logger","initialState","currentState","guard","object","method","legalStates","async","isAsync","args","fn","includes","error","Promise","reject","apply","stateMachine","Object","assign","createGuarded","methodStateMapping","guardedMethods","keys","reduce","guards","transitionTo","state","debug","emit","to","from"],"mappings":"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","sourcesContent":["const { EventEmitter } = require('events')\nconst { KafkaJSNonRetriableError } = require('../../errors')\nconst STATES = require('./transactionStates')\n\nconst VALID_STATE_TRANSITIONS = {\n  [STATES.UNINITIALIZED]: [STATES.READY],\n  [STATES.READY]: [STATES.READY, STATES.TRANSACTING],\n  [STATES.TRANSACTING]: [STATES.COMMITTING, STATES.ABORTING],\n  [STATES.COMMITTING]: [STATES.READY],\n  [STATES.ABORTING]: [STATES.READY],\n}\n\nmodule.exports = ({ logger, initialState = STATES.UNINITIALIZED }) => {\n  let currentState = initialState\n\n  const guard = (object, method, { legalStates, async: isAsync = true }) => {\n    if (!object[method]) {\n      throw new KafkaJSNonRetriableError(`Cannot add guard on missing method \"${method}\"`)\n    }\n\n    return (...args) => {\n      const fn = object[method]\n\n      if (!legalStates.includes(currentState)) {\n        const error = new KafkaJSNonRetriableError(\n          `Transaction state exception: Cannot call \"${method}\" in state \"${currentState}\"`\n        )\n\n        if (isAsync) {\n          return Promise.reject(error)\n        } else {\n          throw error\n        }\n      }\n\n      return fn.apply(object, args)\n    }\n  }\n\n  const stateMachine = Object.assign(new EventEmitter(), {\n    /**\n     * Create a clone of \"object\" where we ensure state machine is in correct state\n     * prior to calling any of the configured methods\n     * @param {Object} object The object whose methods we will guard\n     * @param {Object} methodStateMapping Keys are method names on \"object\"\n     * @param {string[]} methodStateMapping.legalStates Legal states for this method\n     * @param {boolean=true} methodStateMapping.async Whether this method is async (throw vs reject)\n     */\n    createGuarded(object, methodStateMapping) {\n      const guardedMethods = Object.keys(methodStateMapping).reduce((guards, method) => {\n        guards[method] = guard(object, method, methodStateMapping[method])\n        return guards\n      }, {})\n\n      return { ...object, ...guardedMethods }\n    },\n    /**\n     * Transition safely to a new state\n     */\n    transitionTo(state) {\n      logger.debug(`Transaction state transition ${currentState} --> ${state}`)\n\n      if (!VALID_STATE_TRANSITIONS[currentState].includes(state)) {\n        throw new KafkaJSNonRetriableError(\n          `Transaction state exception: Invalid transition ${currentState} --> ${state}`\n        )\n      }\n\n      stateMachine.emit('transition', { to: state, from: currentState })\n      currentState = state\n    },\n\n    state() {\n      return currentState\n    },\n  })\n\n  return stateMachine\n}\n"]},"metadata":{},"sourceType":"script"}